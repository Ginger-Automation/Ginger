!function () { function a(a, b) { a.prototype = c(b.prototype), a.prototype.constructor = a, a.base = b.prototype } function c(a) { function b() { } return b.prototype = a, new b } function e(a, b, c) { return "millisecond" === c ? a.setMilliseconds(a.getMilliseconds() + 1 * b) : "second" === c ? a.setSeconds(a.getSeconds() + 1 * b) : "minute" === c ? a.setMinutes(a.getMinutes() + 1 * b) : "hour" === c ? a.setHours(a.getHours() + 1 * b) : "day" === c ? a.setDate(a.getDate() + 1 * b) : "week" === c ? a.setDate(a.getDate() + 7 * b) : "month" === c ? a.setMonth(a.getMonth() + 1 * b) : "year" === c && a.setFullYear(a.getFullYear() + 1 * b), a } function f(a, b) { var c = !1; for (0 > a && (c = !0, a *= -1), a = "" + a, b = b || 1; a.length < b;)a = "0" + a; return c ? "-" + a : a } function g(a) { if (!a) return a; a = a.replace(/^\s\s*/, ""); for (var b = /\s/, c = a.length; b.test(a.charAt(--c));); return a.slice(0, c + 1) } function h(a) { a.roundRect = function (a, b, c, d, e, f, g, h) { g && (this.fillStyle = g), h && (this.strokeStyle = h), void 0 === e && (e = 5), this.lineWidth = f, this.beginPath(), this.moveTo(a + e, b), this.lineTo(a + c - e, b), this.quadraticCurveTo(a + c, b, a + c, b + e), this.lineTo(a + c, b + d - e), this.quadraticCurveTo(a + c, b + d, a + c - e, b + d), this.lineTo(a + e, b + d), this.quadraticCurveTo(a, b + d, a, b + d - e), this.lineTo(a, b + e), this.quadraticCurveTo(a, b, a + e, b), this.closePath(), g && this.fill(), h && 0 < f && this.stroke() } } function k(a, b) { return a - b } function l(a, b) { return a.x - b.x } function m(a) { var b = ((16711680 & a) >> 16).toString(16), c = ((65280 & a) >> 8).toString(16); return a = ((255 & a) >> 0).toString(16), b = 2 > b.length ? "0" + b : b, c = 2 > c.length ? "0" + c : c, a = 2 > a.length ? "0" + a : a, "#" + b + c + a } function n(a, b) { var c = this.length >>> 0, d = Number(b) || 0, d = 0 > d ? Math.ceil(d) : Math.floor(d); for (0 > d && (d += c); d < c; d++)if (d in this && this[d] === a) return d; return -1 } function o(a) { return null === a || void 0 === a } function p(a, b, c) { c = c || "normal"; var d = a + "_" + b + "_" + c, e = Y[d]; if (isNaN(e)) { try { if (a = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + a + "; font-size:" + b + "px; font-weight:" + c + ";", !Z) { var f = document.body; Z = document.createElement("span"), Z.innerHTML = ""; var g = document.createTextNode("Mpgyi"); Z.appendChild(g), f.appendChild(Z) } Z.style.display = "", Z.setAttribute("style", a), e = Math.round(Z.offsetHeight), Z.style.display = "none" } catch (a) { e = Math.ceil(1.1 * b) } e = Math.max(e, b), Y[d] = e } return e } function q(a, b) { var c = []; if (c = { solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4, 2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2] }[a || "solid"]) for (var d = 0; d < c.length; d++)c[d] *= b; else c = []; return c } function r(a, b, c, d) { if (a.addEventListener) a.addEventListener(b, c, d || !1); else { if (!a.attachEvent) return !1; a.attachEvent("on" + b, function (b) { b = b || window.event, b.preventDefault = b.preventDefault || function () { b.returnValue = !1 }, b.stopPropagation = b.stopPropagation || function () { b.cancelBubble = !0 }, c.call(a, b) }) } } function s(a, b, c) { for (a *= ea, b *= ea, a = c.getImageData(a, b, 2, 2).data, b = !0, c = 0; 4 > c; c++)if (a[c] !== a[c + 4] | a[c] !== a[c + 8] | a[c] !== a[c + 12]) { b = !1; break } return b ? a[0] << 16 | a[1] << 8 | a[2] : 0 } function t(a, b, c) { return a in b ? b[a] : c[a] } function u(a, b, c) { if (S && ba) { var d = a.getContext("2d"); da = d.webkitBackingStorePixelRatio || d.mozBackingStorePixelRatio || d.msBackingStorePixelRatio || d.oBackingStorePixelRatio || d.backingStorePixelRatio || 1, ea = ca / da, a.width = b * ea, a.height = c * ea, ca !== da && (a.style.width = b + "px", a.style.height = c + "px", d.scale(ea, ea)) } else a.width = b, a.height = c } function v(a) { var b = a.ctx; b.textBaseline = "top", b.font = "11px Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif", b.fillStyle = "grey", b.fillText("", 2, a.height - 11 - 2) } function w(a, b) { var c = document.createElement("canvas"); return c.setAttribute("class", "canvasjs-chart-canvas"), u(c, a, b), S || "undefined" == typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(c), c } function x(a, b, c) { if (a && b && c) { c = c + "." + b; var d = "image/" + b; a = a.toDataURL(d); var e = !1, f = document.createElement("a"); if (f.download = c, f.href = a, f.target = "_blank", "undefined" != typeof Blob && new Blob) { for (var g = a.replace(/^data:[a-z\/]*;base64,/, ""), g = atob(g), h = new ArrayBuffer(g.length), h = new Uint8Array(h), i = 0; i < g.length; i++)h[i] = g.charCodeAt(i); b = new Blob([h.buffer], { type: "image/" + b }); try { window.navigator.msSaveBlob(b, c), e = !0 } catch (a) { f.dataset.downloadurl = [d, f.download, f.href].join(":"), f.href = window.URL.createObjectURL(b) } } if (!e) try { event = document.createEvent("MouseEvents"), event.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), f.dispatchEvent ? f.dispatchEvent(event) : f.fireEvent && f.fireEvent("onclick") } catch (c) { b = window.open(), b.document.write("<img src='" + a + "'></img><div>Please right click on the image and save it to your device</div>"), b.document.close() } } } function y(a, b, c) { b.getAttribute("state") !== c && (b.setAttribute("state", c), b.setAttribute("type", "button"), b.style.position = "relative", b.style.margin = "0px 0px 0px 0px", b.style.padding = "3px 4px 0px 4px", b.style.cssFloat = "left", b.setAttribute("title", a._cultureInfo[c + "Text"]), b.innerHTML = "<img style='height:16px;' src='" + fa[c].image + "' alt='" + a._cultureInfo[c + "Text"] + "' />") } function z() { for (var a = null, b = 0; b < arguments.length; b++)a = arguments[b], a.style && (a.style.display = "inline") } function A() { for (var a = null, b = 0; b < arguments.length; b++)(a = arguments[b]) && a.style && (a.style.display = "none") } function B(a, b, c, d) { this._defaultsKey = a, this.parent = d, this._eventListeners = [], d = {}, c && W[c] && W[c][a] && (d = W[c][a]), this._options = b || {}, this.setOptions(this._options, d) } function C(a, b, c) { this._publicChartReference = c, b = b || {}, C.base.constructor.call(this, "Chart", b, b.theme ? b.theme : "theme1"); var d = this; this._containerId = a, this._objectsInitialized = !1, this.overlaidCanvasCtx = this.ctx = null, this._indexLabels = [], this._panTimerId = 0, this._lastTouchEventType = "", this._lastTouchData = null, this.isAnimating = !1, this.renderCount = 0, this.panEnabled = this.disableToolTip = this.animatedRender = !1, this._defaultCursor = "default", this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 }, this._dataInRenderedOrder = [], (this._container = "string" == typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this._container.innerHTML = "", b = a = 0, a = this._options.width ? this.width : 0 < this._container.clientWidth ? this._container.clientWidth : this.width, b = this._options.height ? this.height : 0 < this._container.clientHeight ? this._container.clientHeight : this.height, this.width = a, this.height = b, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this._selectedColorSet = void 0 !== V[this.colorSet] ? V[this.colorSet] : V.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", S || (this._canvasJSContainer.style.height = "0px"), this.percentCircle = document.createElement("span"), this.percentCircle.setAttribute("class", "makeCirclefix"), this.percentCircle.innerHTML = this._options.total_Count, this._canvasJSContainer.appendChild(this.percentCircle), this._container.appendChild(this._canvasJSContainer), this.canvas = w(a, b), this.canvas.style.position = "relavtive", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", h(this.ctx), S ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = w(a, b), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = w(a, b), this.overlaidCanvas.style.position = "absolute", this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", this._eventManager = new P(this), r(window, "resize", function () { d._updateSize() && d.render() }), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, r(this.overlaidCanvas, "click", function (a) { d._mouseEventHandler(a) }), r(this.overlaidCanvas, "mousemove", function (a) { d._mouseEventHandler(a) }), r(this.overlaidCanvas, "mouseup", function (a) { d._mouseEventHandler(a) }), r(this.overlaidCanvas, "mousedown", function (a) { d._mouseEventHandler(a), A(d._dropdownMenu) }), r(this.overlaidCanvas, "mouseout", function (a) { d._mouseEventHandler(a) }), r(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (a) { d._touchEventHandler(a) }), r(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function (a) { d._touchEventHandler(a) }), r(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function (a) { d._touchEventHandler(a) }), r(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function (a) { d._touchEventHandler(a) }), this._creditLink || (this._creditLink = document.createElement("a"), this._creditLink.setAttribute("class", "canvasjs-chart-credit"), this._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (this.height - 13) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"), this._creditLink.setAttribute("tabIndex", -1), this._creditLink.setAttribute("target", "_blank")), this._toolTip = new O(this, this._options.toolTip, this.theme), this.axisY2 = this.axisY = this.axisX = this.data = null, this.sessionVariables = { axisX: {}, axisY: {}, axisY2: {} })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found') } function D(a, b) { for (var c, d = [], e = 0; e < a.length; e++)if (0 == e) d.push(a[0]); else { var f, g, h; h = e - 1, f = 0 === h ? 0 : h - 1, g = h === a.length - 1 ? h : h + 1, c = Math.abs((a[g].x - a[f].x) / (0 == a[g].x - a[h].x ? .01 : a[g].x - a[h].x)) * (b - 1) / 2 + 1; var i = (a[g].x - a[f].x) / c; c = (a[g].y - a[f].y) / c, d[d.length] = a[h].x > a[f].x && 0 < i || a[h].x < a[f].x && 0 > i ? { x: a[h].x + i / 3, y: a[h].y + c / 3 } : { x: a[h].x, y: a[h].y + c / 9 }, h = e, f = 0 === h ? 0 : h - 1, g = h === a.length - 1 ? h : h + 1, c = Math.abs((a[g].x - a[f].x) / (0 == a[h].x - a[f].x ? .01 : a[h].x - a[f].x)) * (b - 1) / 2 + 1, i = (a[g].x - a[f].x) / c, c = (a[g].y - a[f].y) / c, d[d.length] = a[h].x > a[f].x && 0 < i || a[h].x < a[f].x && 0 > i ? { x: a[h].x - i / 3, y: a[h].y - c / 3 } : { x: a[h].x, y: a[h].y - c / 9 }, d[d.length] = a[e] } return d } function E(a, b) { if (null === a || void 0 === a) return b; var c = parseFloat(a.toString()) * (0 <= a.toString().indexOf("%") ? b / 100 : 1); return !isNaN(c) && c <= b && 0 <= c ? c : b } function F(a, b, c, d, e) { void 0 === e && (e = 0), this._padding = e, this._x1 = a, this._y1 = b, this._x2 = c, this._y2 = d, this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding } function G(a, b) { G.base.constructor.call(this, "TextBlock", b), this.ctx = a, this._isDirty = !0, this._wrappedText = null } function H(a, b) { if (H.base.constructor.call(this, "Title", b, a.theme), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, o(this._options.margin) && a._options.subtitles) for (var c = a._options.subtitles, d = 0; d < c.length; d++)if ((o(c[d].horizontalAlign) && "center" === this.horizontalAlign || c[d].horizontalAlign === this.horizontalAlign) && (o(c[d].verticalAlign) && "top" === this.verticalAlign || c[d].verticalAlign === this.verticalAlign) && !c[d].dockInsidePlotArea == !this.dockInsidePlotArea) { this.margin = 0; break } void 0 === this._options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = { x1: null, y1: null, x2: null, y2: null } } function I(a, b) { I.base.constructor.call(this, "Subtitle", b, a.theme), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, void 0 === this._options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = { x1: null, y1: null, x2: null, y2: null } } function J(a, b, c) { J.base.constructor.call(this, "Legend", b, c), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, this.ghostCtx = this.chart._eventManager.ghostCtx, this.items = [], this.height = this.width = 0, this.orientation = null, this.dataSeries = [], this.bounds = { x1: null, y1: null, x2: null, y2: null }, void 0 === this._options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.lineHeight = p(this.fontFamily, this.fontSize, this.fontWeight), this.horizontalSpacing = this.fontSize } function K(a, b) { K.base.constructor.call(this, b), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx } function L(a, b, c, d, e) { L.base.constructor.call(this, "DataSeries", b, c), this.chart = a, this.canvas = a.canvas, this._ctx = a.canvas.ctx, this.index = d, this.noDataPointsInPlotArea = 0, this.id = e, this.chart._eventManager.objectMap[e] = { id: e, objectType: "dataSeries", dataSeriesIndex: d }, this.dataPointIds = [], this.plotUnit = [], this.axisY = this.axisX = null, null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = .7 : this.fillOpacity = 1), this.axisPlacement = this.getDefaultAxisPlacement(), void 0 === this._options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize)) } function M(a, b, c, d) { if (M.base.constructor.call(this, "Axis", b, a.theme), this.chart = a, this.canvas = a.canvas, this.ctx = a.ctx, this.intervalStartPosition = this.maxHeight = this.maxWidth = 0, this.labels = [], this._stripLineLabels = this._ticks = this._labels = null, this.dataInfo = { min: 1 / 0, max: -1 / 0, viewPortMin: 1 / 0, viewPortMax: -1 / 0, minDiff: 1 / 0 }, "axisX" === c ? (this.sessionVariables = this.chart.sessionVariables[c], this._options.interval || (this.intervalType = null), "theme2" === this.chart.theme && o(this._options.lineThickness) && (this.lineThickness = 2)) : this.sessionVariables = "left" === d || "top" === d ? this.chart.sessionVariables.axisY : this.chart.sessionVariables.axisY2, void 0 === this._options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize)), void 0 === this._options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize)), this.type = c, "axisX" !== c || b && void 0 !== b.gridThickness || (this.gridThickness = 0), this._position = d, this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null }, this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360), this._options.stripLines && 0 < this._options.stripLines.length) for (this.stripLines = [], b = 0; b < this._options.stripLines.length; b++)this.stripLines.push(new N(this.chart, this._options.stripLines[b], a.theme, ++this.chart._eventManager.lastObjectId, this)); this._titleTextBlock = null, this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this._options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null), this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum, this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this._options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null), this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum, null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)), null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)), this.trackChanges("viewportMinimum"), this.trackChanges("viewportMaximum") } function N(a, b, c, d, e) { N.base.constructor.call(this, "StripLine", b, c, e), this.id = d, this.chart = a, this.ctx = this.chart.ctx, this.label = this.label, this._thicknessType = "pixel", null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this.thickness = e.logarithmic ? Math.log(this.endValue / this.startValue) / Math.log(e.logarithmBase) : Math.max(this.endValue - this.startValue), this._thicknessType = "value") } function O(a, b, c) { O.base.constructor.call(this, "ToolTip", b, c), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, this.currentDataPointIndex = this.currentSeriesIndex = -1, this._timerId = 0, this._prevY = this._prevX = NaN, this._initialize() } function P(a) { this.chart = a, this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.ghostCanvas = w(this.chart.width, this.chart.height), this.ghostCtx = this.ghostCanvas.getContext("2d"), this.mouseoveredObjectMaps = [] } function Q(a) { var b; a && U[a] && (b = U[a]), Q.base.constructor.call(this, "CultureInfo", b) } function R(a) { this.chart = a, this.ctx = this.chart.plotArea.ctx, this.animations = [], this.animationRequestId = null } var S = !!document.createElement("canvas").getContext, T = { Chart: { width: 500, height: 400, zoomEnabled: !1, zoomType: "x", backgroundColor: "white", theme: "theme1", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: "colorSet1", culture: "en", creditText: "CanvasJS", interactivityEnabled: !0, exportEnabled: !1, exportFileName: "Chart", rangeChanging: null, rangeChanged: null }, Title: { padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 20, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1 }, Subtitle: { padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 14, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null, dockInsidePlotArea: !1 }, Legend: { name: null, verticalAlign: "center", horizontalAlign: "right", fontSize: 14, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", cursor: null, itemmouseover: null, itemmouseout: null, itemmousemove: null, itemclick: null, dockInsidePlotArea: !1, reversed: !1, maxWidth: null, maxHeight: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null }, ToolTip: { enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: null, borderColor: null, borderThickness: 2, cornerRadius: 5, fontSize: 14, fontColor: null, fontFamily: "Calibri, Arial, Georgia, serif;", fontWeight: "normal", fontStyle: "italic" }, Axis: { minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: "black", titleFontSize: 20, titleFontFamily: "arial", titleFontWeight: "normal", titleFontStyle: "normal", titleWrap: !0, titleMaxWidth: null, labelAngle: 0, labelFontFamily: "arial", labelFontColor: "black", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, prefix: "", suffix: "", includeZero: !0, tickLength: 5, tickColor: "black", tickThickness: 1, lineColor: "black", lineThickness: 1, lineDashType: "solid", gridColor: "A0A0A0", gridThickness: 0, gridDashType: "solid", interlacedColor: null, valueFormatString: null, margin: 2, stripLines: [] }, StripLine: { value: null, startValue: null, endValue: null, color: "orange", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelPlacement: "inside", labelAlign: "far", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: "transparent", labelFontFamily: "arial", labelFontColor: "orange", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, showOnTop: !1 }, DataSeries: { name: null, dataPoints: null, label: "", bevelEnabled: !1, highlightEnabled: !0, cursor: null, indexLabel: "", indexLabelPlacement: "auto", indexLabelOrientation: "horizontal", indexLabelFontColor: "black", indexLabelFontSize: 12, indexLabelFontStyle: "normal", indexLabelFontFamily: "Arial", indexLabelFontWeight: "normal", indexLabelBackgroundColor: null, indexLabelLineColor: null, indexLabelLineThickness: 1, indexLabelLineDashType: "solid", indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null, lineThickness: 2, lineDashType: "solid", connectNullData: !1, nullDataLineDashType: "dash", color: null, lineColor: null, risingColor: "white", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, type: "column", xValueType: "number", axisYType: "primary", xValueFormatString: null, yValueFormatString: null, zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: null, legendMarkerBorderThickness: null, markerType: "circle", markerColor: null, markerSize: null, markerBorderColor: null, markerBorderThickness: null, mouseover: null, mouseout: null, mousemove: null, click: null, toolTipContent: null, visible: !0 }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: "", horizontalAlign: "center", fontSize: 12, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, textBaseline: "top" }, CultureInfo: { decimalSeparator: ".", digitGroupSeparator: ",", zoomText: "Zoom", panText: "Pan", resetText: "Reset", menuText: "More Options", saveJPGText: "Save as JPEG", savePNGText: "Save as PNG", days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "), months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ") } }, U = { en: {} }, V = { colorSet1: "#369EAD #C24642 #7F6084 #86B402 #A2D1CF #C8B631 #6DBCEB #52514E #4F81BC #A064A1 #F79647".split(" "), colorSet2: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #33558B".split(" "), colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ") }, W = { theme1: { Chart: { colorSet: "colorSet1" }, Title: { fontFamily: S ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", fontSize: 33, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, Subtitle: { fontFamily: S ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", fontSize: 16, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, Axis: { titleFontSize: 26, titleFontColor: "#666666", titleFontFamily: S ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontFamily: S ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 18, labelFontColor: "grey", tickColor: "#BBBBBB", tickThickness: 2, gridThickness: 2, gridColor: "#BBBBBB", lineThickness: 2, lineColor: "#BBBBBB" }, Legend: { verticalAlign: "bottom", horizontalAlign: "center", fontFamily: S ? "monospace, sans-serif,arial black" : "calibri" }, DataSeries: { indexLabelFontColor: "grey", indexLabelFontFamily: S ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", indexLabelFontSize: 18, indexLabelLineThickness: 1 } }, theme2: { Chart: { colorSet: "colorSet2" }, Title: { fontFamily: "impact, charcoal, arial black, sans-serif", fontSize: 32, fontColor: "#333333", verticalAlign: "top", margin: 5 }, Subtitle: { fontFamily: "impact, charcoal, arial black, sans-serif", fontSize: 14, fontColor: "#333333", verticalAlign: "top", margin: 5 }, Axis: { titleFontSize: 22, titleFontColor: "rgb(98,98,98)", titleFontFamily: S ? "monospace, sans-serif,arial black" : "arial", titleFontWeight: "bold", labelFontFamily: S ? "monospace, Courier New, Courier" : "arial", labelFontSize: 16, labelFontColor: "grey", labelFontWeight: "bold", tickColor: "grey", tickThickness: 2, gridThickness: 2, gridColor: "grey", lineColor: "grey", lineThickness: 0 }, Legend: { verticalAlign: "bottom", horizontalAlign: "center", fontFamily: S ? "monospace, sans-serif,arial black" : "arial" }, DataSeries: { indexLabelFontColor: "grey", indexLabelFontFamily: S ? "Courier New, Courier, monospace" : "arial", indexLabelFontWeight: "bold", indexLabelFontSize: 18, indexLabelLineThickness: 1 } }, theme3: { Chart: { colorSet: "colorSet1" }, Title: { fontFamily: S ? "Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif" : "calibri", fontSize: 32, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, Subtitle: { fontFamily: S ? "Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif" : "calibri", fontSize: 16, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, Axis: { titleFontSize: 22, titleFontColor: "rgb(98,98,98)", titleFontFamily: S ? "Verdana, Geneva, Calibri, sans-serif" : "calibri", labelFontFamily: S ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 18, labelFontColor: "grey", tickColor: "grey", tickThickness: 2, gridThickness: 2, gridColor: "grey", lineThickness: 2, lineColor: "grey" }, Legend: { verticalAlign: "bottom", horizontalAlign: "center", fontFamily: S ? "monospace, sans-serif,arial black" : "calibri" }, DataSeries: { bevelEnabled: !0, indexLabelFontColor: "grey", indexLabelFontFamily: S ? "Candara, Optima, Calibri, Verdana, Geneva, sans-serif" : "calibri", indexLabelFontSize: 18, indexLabelLineColor: "lightgrey", indexLabelLineThickness: 2 } } }, X = { numberDuration: 1, yearDuration: 314496e5, monthDuration: 2592e6, weekDuration: 6048e5, dayDuration: 864e5, hourDuration: 36e5, minuteDuration: 6e4, secondDuration: 1e3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") }, Y = {}, Z = null, $ = function () { var a = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, b = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), c = "Sun Mon Tue Wed Thu Fri Sat".split(" "), d = "January February March April May June July August September October November December".split(" "), e = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), g = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, h = /[^-+\dA-Z]/g; return function (i, j, k) { var l = k ? k.days : b, m = k ? k.months : d, n = k ? k.shortDays : c, o = k ? k.shortMonths : e; k = ""; var p = !1; if (i = i && i.getTime ? i : i ? new Date(i) : new Date, isNaN(i)) throw SyntaxError("invalid date"); "UTC:" === j.slice(0, 4) && (j = j.slice(4), p = !0), k = p ? "getUTC" : "get"; var q = i[k + "Date"](), r = i[k + "Day"](), s = i[k + "Month"](), t = i[k + "FullYear"](), u = i[k + "Hours"](), v = i[k + "Minutes"](), w = i[k + "Seconds"](), x = i[k + "Milliseconds"](), y = p ? 0 : i.getTimezoneOffset(); return k = j.replace(a, function (a) { switch (a) { case "D": return q; case "DD": return f(q, 2); case "DDD": return n[r]; case "DDDD": return l[r]; case "M": return s + 1; case "MM": return f(s + 1, 2); case "MMM": return o[s]; case "MMMM": return m[s]; case "Y": return parseInt(String(t).slice(-2)); case "YY": return f(String(t).slice(-2), 2); case "YYY": return f(String(t).slice(-3), 3); case "YYYY": return f(t, 4); case "h": return u % 12 || 12; case "hh": return f(u % 12 || 12, 2); case "H": return u; case "HH": return f(u, 2); case "m": return v; case "mm": return f(v, 2); case "s": return w; case "ss": return f(w, 2); case "f": return String(x).slice(0, 1); case "ff": return f(String(x).slice(0, 2), 2); case "fff": return f(String(x).slice(0, 3), 3); case "t": return 12 > u ? "a" : "p"; case "tt": return 12 > u ? "am" : "pm"; case "T": return 12 > u ? "A" : "P"; case "TT": return 12 > u ? "AM" : "PM"; case "K": return p ? "UTC" : (String(i).match(g) || [""]).pop().replace(h, ""); case "z": return (0 < y ? "-" : "+") + Math.floor(Math.abs(y) / 60); case "zz": return (0 < y ? "-" : "+") + f(Math.floor(Math.abs(y) / 60), 2); case "zzz": return (0 < y ? "-" : "+") + f(Math.floor(Math.abs(y) / 60), 2) + f(Math.abs(y) % 60, 2); default: return a.slice(1, a.length - 1) } }) } }(), _ = function (a, b, c) { if (null === a) return ""; a = Number(a); var d = 0 > a; d && (a *= -1); var e = c ? c.decimalSeparator : ".", g = c ? c.digitGroupSeparator : ",", h = ""; b = String(b); var h = 1, i = c = "", j = -1, k = [], l = [], m = 0, n = 0, o = 0, p = !1, q = 0, i = b.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g); b = null; for (var r = 0; i && r < i.length; r++)if ("." === (b = i[r]) && 0 > j) j = r; else { if ("%" === b) h *= 100; else { if ("‰" === b) { h *= 1e3; continue } if ("," === b[0] && "." === b[b.length - 1]) { h /= Math.pow(1e3, b.length - 1), j = r + b.length - 1; continue } "E" !== b[0] && "e" !== b[0] || "0" !== b[b.length - 1] || (p = !0) } 0 > j ? (k.push(b), "#" === b || "0" === b ? m++ : "," === b && o++) : (l.push(b), "#" !== b && "0" !== b || n++) } for (p && (b = Math.floor(a), q = (0 === b ? "" : String(b)).length - m, h /= Math.pow(10, q)), 0 > j && (j = r), h = (a * h).toFixed(n), b = h.split("."), h = (b[0] + "").split(""), a = (b[1] + "").split(""), h && "0" === h[0] && h.shift(), r = p = i = n = j = 0; 0 < k.length;)if ("#" === (b = k.pop()) || "0" === b) if (++j === m) { var s = h, h = []; if ("0" === b) for (b = m - n - (s ? s.length : 0); 0 < b;)s.unshift("0"), b--; for (; 0 < s.length;)c = s.pop() + c, 0 == ++r % p && i === o && 0 < s.length && (c = g + c); d && (c = "-" + c) } else 0 < h.length ? (c = h.pop() + c, n++ , r++) : "0" === b && (c = "0" + c, n++ , r++), 0 == r % p && i === o && 0 < h.length && (c = g + c); else "E" !== b[0] && "e" !== b[0] || "0" !== b[b.length - 1] || !/[eE][+-]*[0]+/.test(b) ? "," === b ? (i++ , p = r, r = 0, 0 < h.length && (c = g + c)) : c = 1 < b.length && ('"' === b[0] && '"' === b[b.length - 1] || "'" === b[0] && "'" === b[b.length - 1]) ? b.slice(1, b.length - 1) + c : b + c : (b = 0 > q ? b.replace("+", "").replace("-", "") : b.replace("-", ""), c += b.replace(/[0]+/, function (a) { return f(q, a.length) })); for (d = "", g = !1; 0 < l.length;)b = l.shift(), "#" === b || "0" === b ? 0 < a.length && 0 !== Number(a.join("")) ? (d += a.shift(), g = !0) : "0" === b && (d += "0", g = !0) : 1 < b.length && ('"' === b[0] && '"' === b[b.length - 1] || "'" === b[0] && "'" === b[b.length - 1]) ? d += b.slice(1, b.length - 1) : "E" !== b[0] && "e" !== b[0] || "0" !== b[b.length - 1] || !/[eE][+-]*[0]+/.test(b) ? d += b : (b = 0 > q ? b.replace("+", "").replace("-", "") : b.replace("-", ""), d += b.replace(/[0]+/, function (a) { return f(q, a.length) })); return c + ((g ? e : "") + d) }, aa = function (a) { var b = 0, c = 0; return a = a || window.event, a.offsetX || 0 === a.offsetX ? (b = a.offsetX, c = a.offsetY) : a.layerX || 0 == a.layerX ? (b = a.layerX, c = a.layerY) : (b = a.pageX - a.target.offsetLeft, c = a.pageY - a.target.offsetTop), { x: b, y: c } }, ba = !0, ca = window.devicePixelRatio || 1, da = 1, ea = ba ? ca / da : 1, fa = { reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAcCAYAAAAAwr0iAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAKRSURBVEiJrdY/iF1FFMfxzwnZrGISUSR/JLGIhoh/QiRNBLWxMLIWEkwbgiAoFgoW2mhlY6dgpY2IlRBRxBSKhSAKIklWJRYuMZKAhiyopAiaTY7FvRtmZ+/ed9/zHRjezLw5v/O9d86cuZGZpmURAfdn5o9DfdZNLXpjz+LziPgyIl6MiG0jPTJzZBuyDrP4BVm0P/AKbljTb4ToY/gGewYA7KyCl+1b3DUYANvwbiHw0gCAGRzBOzjTAXEOu0cC4Ch+r5x/HrpdrcZmvIDFSucMtnYCYC++6HmNDw8FKDT34ETrf639/azOr5vwRk/g5fbeuABtgC04XWk9VQLciMP4EH/3AFzErRNC7MXlQmsesSoHsGPE23hmEoBW+61K66HMXFmIMvN8myilXS36R01ub+KfYvw43ZXwYDX+AHP4BAci4pFJomfmr/ihmNofESsBImJGk7mlncrM45n5JPbhz0kAWpsv+juxaX21YIPmVJS2uNzJMS6ZNexC0d+I7fUWXLFyz2kSZlpWPvASlmqAf/FXNXf3FAF2F/1LuFifAlionB6dRuSI2IwHi6lzmXmp6xR8XY0fiIh7psAwh+3FuDkRHQVjl+a8lkXjo0kLUKH7XaV5oO86PmZ1FTzyP4K/XGl9v/zwfbW7BriiuETGCP5ch9bc9f97HF/vcFzCa5gdEPgWq+t/4v0V63oE1uF4h0DiFJ7HnSWMppDdh1dxtsPvJ2wcBNAKbsJXa0Ck5opdaBPsRNu/usba09i1KsaAVzmLt3sghrRjuK1Tf4xkegInxwy8gKf7dKMVH2QRsV5zXR/Cftyu+aKaKbbkQrsdH+PTzLzcqzkOQAVzM+7FHdiqqe2/YT4zF/t8S/sPmawyvC974vcAAAAASUVORK5CYII=" }, pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAJVSURBVFiFvZe7a1RBGMV/x2hWI4JpfKCIiSBKOoOCkID/wP4BFqIIFkE02ChIiC8QDKlSiI3YqRBsBVGwUNAUdiIEUgjiAzQIIsuKJsfizsXr5t7d+8jmwLDfzHz3nLOzc7+ZxTZlGyDgZiWOCuJ9wH2gCUyuqQFgF/AGcKJNrYkBYBj40CIet+muGQi/96kM4WS7C/Tm5VUg7whJg8BkEGkCR4BDYfodsADUgP6wErO5iCtswsuJb32hdbXy8qzL5TIdmzJinHdZoZIBZcSFkGlAKs1Z3YCketZcBtouuaQNkrblMiBpBrhme7mAgU4wMCvpcFsDkq4C54DFVRTH9h+i6vlE0r5UA5ImgCuh28jB28iIs7BIVCOeStoZD64P4uPAjUTygKSx2FsK2TIwkugfk9Qkfd/E+yMWHQCeSRqx/R3gOp3LazfaS2C4B5gHDgD7U9x3E3uAH7KNpC3AHHAwTL4FHgM9GQ8vAaPA0dB/Abxqk2/gBLA9MXba9r1k/d4LfA3JtwueBeM58ucS+edXnAW23wP10N3advEi9CXizTnyN4bPS7Zn4sH/dq3t18AY4e1YLYSy3g/csj2VnFshZPuOpOeSKHCodUINuGj7YetE6je1PV9QoNPJ9StNHKodx7nRbiWrGHBGXAi5DUiqtQwtpcWK0Jubt8CltA5MEV1IfwO7+VffPwGfia5m34CT4bXujIIX0Qna1/cGMNqV/wUJE2czxD8CQ4X5Sl7Jz7SILwCDpbjKPBRMHAd+EtX4HWV5Spdc2w8kDQGPbH8py/MXMygM69/FKz4AAAAASUVORK5CYII=" }, zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAMqSURBVFiFvdfbj91TFMDxz57U6GUEMS1aYzyMtCSSDhWjCZMInpAI3khE/QHtgzdRkXgSCS8SES9epKLi0oRKNETjRahREq2KS1stdRujtDPtbA97n5zdn9+5zJxTK9k5v3POXmt991p7r71+IcaoGwkhTOIebMRqzOBTvIG3Y4zTXRmqSoyx5cAKbMJOHMFJnMZ8/jyFaXyMR7G6nb1aH22cP4BvcBxziG3GKfyTIR9D6BYg1KUghPBCDveFlb/24Av8iuUYw41YVsz5G7uxKcZ4aMEpwGt5NY3V/YbHsQ6rcAHOw/kYxigewr5CZw4fYGxBKcCLOFEYehXrMdRhr5yLETxVScsOLOkKAPfn1TYMPIvLFrShUlS2FDZm8XRHACzFAWl3R2xbqPMCYhmeLCAOYEMngAczbcTvuHYxzguIy/FesR9e6gSwU/OoPYHBHgHgviIKX2Flq7k34KhmcVnbi/PC8JX4MgMcxb118wZwdz5aISscqx7VRcox7MrPQ7i+btIAJrAkf9+bI9EPmZY2IAxiTSuAldLq4Y9+AcSUh78KP0tbAcwU35cXMD1JCIFUoGiehlqAz6TNB1f1C0DK+0h+nsNPrQC2a4bqGmlD9kOGcWt+Po6pVgDvSxfJaSkFd4UQBvoAsBYbCoB3a2flM7slA0R8iyt6rAFDeDPbm8eOTpVwGD9qVq7nLbIaZnmksPU1JtsCZMXNmpdRxFasWITzh6Xj3LCzra1OxcD2QjHiGVzdpfORnMqZio2PcF23ABdJF1Np4BPptlyPi6WzPYBzpJZtHe7A6xW9cnyP8TqA//SEIYRL8Bxul7rihvwgtVn78WcGGZXa9HGd5TDujDHuOePXNiHdKjWgZX/YbsxLx/ktqbjVzTlcjUSnvI5JrdlUVp6WesZZ6R1hRrpq9+EVTGS9jTjYAuKIouGpbcurEkIYxC051KNSamazsc+xK8b4S0VnEi/j0hqTP+M27O258egQwZuzs7pI7Mf4WQXIEDc5s9sux+5+1Py2EmP8UOq6GvWhIScxfdYjUERiAt9Jd84J6a16zf8JEKT3yCm8g1UxRv8CC4pyRhzR1uUAAAAASUVORK5CYII=" }, menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAgCAYAAAAbifjMAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAAWdEVYdENyZWF0aW9uIFRpbWUAMDcvMTUvMTTPsvU0AAAAP0lEQVRIie2SMQoAIBDDUvH/X667g8sJJ9KOhYYOkW0qGaU1MPdC0vGSbV19EACo3YMPAFH5BUBUjsqfAPpVXtNgGDfxEDCtAAAAAElFTkSuQmCC" } }; B.prototype.setOptions = function (a, b) { if (T[this._defaultsKey]) { var c, d = T[this._defaultsKey]; for (c in d) d.hasOwnProperty(c) && (this[c] = a && c in a ? a[c] : b && c in b ? b[c] : d[c]) } }, B.prototype.updateOption = function (a) { var b = T[this._defaultsKey], c = this._options.theme ? this._options.theme : this.chart && this.chart._options.theme ? this.chart._options.theme : "theme1", d = {}, e = this[a]; return c && W[c] && W[c][this._defaultsKey] && (d = W[c][this._defaultsKey]), a in b && (e = a in this._options ? this._options[a] : d && a in d ? d[a] : b[a]), e !== this[a] && (this[a] = e, !0) }, B.prototype.trackChanges = function (a) { if (!this.sessionVariables) throw "Session Variable Store not set"; this.sessionVariables[a] = this._options[a] }, B.prototype.isBeingTracked = function (a) { return this._options._oldOptions || (this._options._oldOptions = {}), !!this._options._oldOptions[a] }, B.prototype.hasOptionChanged = function (a) { if (!this.sessionVariables) throw "Session Variable Store not set"; return this.sessionVariables[a] !== this._options[a] }, B.prototype.addEventListener = function (a, b, c) { a && b && (this._eventListeners[a] = this._eventListeners[a] || [], this._eventListeners[a].push({ context: c || this, eventHandler: b })) }, B.prototype.removeEventListener = function (a, b) { if (a && b && this._eventListeners[a]) for (var c = this._eventListeners[a], d = 0; d < c.length; d++)if (c[d].eventHandler === b) { c[d].splice(d, 1); break } }, B.prototype.removeAllEventListeners = function () { this._eventListeners = [] }, B.prototype.dispatchEvent = function (a, b, c) { if (a && this._eventListeners[a]) { b = b || {}; for (var d = this._eventListeners[a], e = 0; e < d.length; e++)d[e].eventHandler.call(d[e].context, b) } "function" == typeof this[a] && this[a].call(c || this.chart._publicChartReference, b) }, a(C, B), C.prototype._updateOptions = function () { var a = this; if (this.updateOption("width"), this.updateOption("height"), this.updateOption("dataPointWidth"), this.updateOption("dataPointMinWidth"), this.updateOption("dataPointMaxWidth"), this.updateOption("interactivityEnabled"), this.updateOption("theme"), this.updateOption("colorSet") && (this._selectedColorSet = void 0 !== V[this.colorSet] ? V[this.colorSet] : V.colorSet1), this.updateOption("backgroundColor"), this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"), this.updateOption("culture"), this._cultureInfo = new Q(this._options.culture), this.updateOption("animationEnabled"), this.animationEnabled = this.animationEnabled && S, this.updateOption("animationDuration"), this.updateOption("rangeChanging"), this.updateOption("rangeChanged"), this.updateOption("exportEnabled"), this.updateOption("exportFileName"), this.updateOption("zoomType"), this._options.zoomEnabled ? (this._zoomButton || (A(this._zoomButton = document.createElement("button")), y(this, this._zoomButton, "pan"), this._toolBar.appendChild(this._zoomButton), r(this._zoomButton, "click", function () { a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, y(a, a._zoomButton, "zoom")) : (a.zoomEnabled = !0, a.panEnabled = !1, y(a, a._zoomButton, "pan")), a.render() })), this._resetButton || (A(this._resetButton = document.createElement("button")), y(this, this._resetButton, "reset"), this._toolBar.appendChild(this._resetButton), r(this._resetButton, "click", function () { a._toolTip.hide(), a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, y(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1), a.sessionVariables.axisX && (a.sessionVariables.axisX.newViewportMinimum = null, a.sessionVariables.axisX.newViewportMaximum = null), a.sessionVariables.axisY && (a.sessionVariables.axisY.newViewportMinimum = null, a.sessionVariables.axisY.newViewportMaximum = null), a.sessionVariables.axisY2 && (a.sessionVariables.axisY2.newViewportMinimum = null, a.sessionVariables.axisY2.newViewportMaximum = null), a.resetOverlayedCanvas(), A(a._zoomButton, a._resetButton), a._dispatchRangeEvent("rangeChanging", "reset"), a.render(), a._dispatchRangeEvent("rangeChanged", "reset") }), this.overlaidCanvas.style.cursor = a._defaultCursor), this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), z(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1))) : this.panEnabled = this.zoomEnabled = !1, this._menuButton ? this.exportEnabled ? z(this._menuButton) : A(this._menuButton) : this.exportEnabled && S && (this._menuButton = document.createElement("button"), y(this, this._menuButton, "menu"), this._toolBar.appendChild(this._menuButton), r(this._menuButton, "click", function () { "none" !== a._dropdownMenu.style.display || a._dropDownCloseTime && 500 >= (new Date).getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = "block", a._menuButton.blur(), a._dropdownMenu.focus()) }, !0)), !this._dropdownMenu && this.exportEnabled && S) { this._dropdownMenu = document.createElement("div"), this._dropdownMenu.setAttribute("tabindex", -1), this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 1px;top: 25px;min-width: 120px;outline: 0;border: 1px solid silver;font-size: 14px;font-family: Calibri, Verdana, sans-serif;padding: 5px 0px 5px 0px;text-align: left;background-color: #fff;line-height: 20px;box-shadow: 2px 2px 10px #888888;", a._dropdownMenu.style.display = "none", this._toolBar.appendChild(this._dropdownMenu), r(this._dropdownMenu, "blur", function () { A(a._dropdownMenu), a._dropDownCloseTime = new Date }, !0); var c = document.createElement("div"); c.style.cssText = "padding: 2px 15px 2px 10px", c.innerHTML = this._cultureInfo.saveJPGText, this._dropdownMenu.appendChild(c), r(c, "mouseover", function () { this.style.backgroundColor = "#EEEEEE" }, !0), r(c, "mouseout", function () { this.style.backgroundColor = "transparent" }, !0), r(c, "click", function () { x(a.canvas, "jpeg", a.exportFileName), A(a._dropdownMenu) }, !0), c = document.createElement("div"), c.style.cssText = "padding: 2px 15px 2px 10px", c.innerHTML = this._cultureInfo.savePNGText, this._dropdownMenu.appendChild(c), r(c, "mouseover", function () { this.style.backgroundColor = "#EEEEEE" }, !0), r(c, "mouseout", function () { this.style.backgroundColor = "transparent" }, !0), r(c, "click", function () { x(a.canvas, "png", a.exportFileName), A(a._dropdownMenu) }, !0) } "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? y(a, a._zoomButton, "zoom") : y(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && y(a, a._resetButton, "reset")), (0 === this.renderCount || b || d) && (this._creditLink.setAttribute("href", this.creditHref), this._creditLink.innerHTML = this.creditText), this.creditHref && this.creditText ? this._creditLink.parentElement || this._canvasJSContainer.appendChild(this._creditLink) : this._creditLink.parentElement && this._canvasJSContainer.removeChild(this._creditLink), this._options.toolTip && this._toolTip._options !== this._options.toolTip && (this._toolTip._options = this._options.toolTip); for (var e in this._toolTip._options) this._toolTip._options.hasOwnProperty(e) && this._toolTip.updateOption(e) }, C.prototype._updateSize = function () { var a = 0, b = 0; return this._options.width ? a = this.width : this.width = a = 0 < this._container.clientWidth ? this._container.clientWidth : this.width, this._options.height ? b = this.height : this.height = b = 0 < this._container.clientHeight ? this._container.clientHeight : this.height, (this.canvas.width !== a * ea || this.canvas.height !== b * ea) && (u(this.canvas, a, b), u(this.overlaidCanvas, a, b), u(this._eventManager.ghostCanvas, a, b), !0) }, C.prototype._initialize = function () { this._animator ? this._animator.cancelAllAnimations() : this._animator = new R(this), this.removeAllEventListeners(), this.disableToolTip = !1, this._axes = [], this.pieDoughnutClickHandler = null, this.animationRequestId && this.cancelRequestAnimFrame.call(window, this.animationRequestId), this._updateOptions(), this.animatedRender = S && this.animationEnabled && 0 === this.renderCount, this._updateSize(), this._creditLink && this.creditHref && this.creditText && (this._creditLink.style.top = this.height - 14 + "px"), this.clearCanvas(), this.ctx.beginPath(), this.axisY2 = this.axisY = this.axisX = null, this._indexLabels = [], this._dataInRenderedOrder = [], this._events = [], this._eventManager && this._eventManager.reset(), this.plotInfo = { axisPlacement: null, axisXValueType: null, plotTypes: [] }, this.layoutManager = new F(0, 0, this.width, this.height, 2), this.plotArea.layoutManager && this.plotArea.layoutManager.reset(), this.data = []; var a = 0; if (this._options.data) for (var b = 0; b < this._options.data.length; b++)if (a++ , !this._options.data[b].type || 0 <= C._supportedChartTypes.indexOf(this._options.data[b].type)) { var c = new L(this, this._options.data[b], this.theme, a - 1, ++this._eventManager.lastObjectId); null === c.name && (c.name = "DataSeries " + a), null === c.color ? 1 < this._options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "candlestick" === c.type || "ohlc" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color], null === c.markerSize && (("line" === c.type || "stepLine" === c.type || "spline" === c.type || 0 <= c.type.toLowerCase().indexOf("area")) && c.dataPoints && c.dataPoints.length < this.width / 16 || "scatter" === c.type) && (c.markerSize = 8), "bubble" !== c.type && "scatter" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function (a) { return a.x }) && c.dataPoints.sort(l) : c.dataPoints.sort(l)), this.data.push(c); var d, e = c.axisPlacement; if ("normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? d = 'You cannot combine "' + c.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? d = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? d = 'You cannot combine "' + c.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? d = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" == e && ("normal" === this.plotInfo.axisPlacement ? d = 'You cannot combine "' + c.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? d = 'You cannot combine "' + c.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none")), d && window.console) return void window.console.log(d) } this._objectsInitialized = !0 }, C._supportedChartTypes = function (a) { return a.indexOf || (a.indexOf = n), a }("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc rangeColumn rangeBar rangeArea rangeSplineArea pie doughnut funnel".split(" ")), C.prototype.render = function (a) { a && (this._options = a), this._initialize(), void 0 === T.Chart.creditHref && v(this); var b = []; for (a = 0; a < this.data.length; a++)"normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || (this.data[a].axisYType && "primary" !== this.data[a].axisYType ? "secondary" === this.data[a].axisYType && (this.axisY2 || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2 = new M(this, this._options.axisY2, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2 = new M(this, this._options.axisY2, "axisY", "top"))), this.data[a].axisY = this.axisY2) : (this.axisY || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY = new M(this, this._options.axisY, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY = new M(this, this._options.axisY, "axisY", "bottom"))), this.data[a].axisY = this.axisY), this.axisX || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX = new M(this, this._options.axisX, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX = new M(this, this._options.axisX, "axisX", "left"))), this.data[a].axisX = this.axisX); this.axisY && this.axisY2 && (0 < this.axisY.gridThickness && void 0 === this.axisY2._options.gridThickness ? this.axisY2.gridThickness = 0 : 0 < this.axisY2.gridThickness && void 0 === this.axisY._options.gridThickness && (this.axisY.gridThickness = 0)); var c = !1; if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled)) for (a = 0; a < this._axes.length; a++)if (null !== this._axes[a].viewportMinimum || null !== this._axes[a].viewportMaximum) { c = !0; break } if (c ? z(this._zoomButton, this._resetButton) : (A(this._zoomButton, this._resetButton), this._options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1)), this._processData(), this._options.title && (this._title = new H(this, this._options.title), this._title.dockInsidePlotArea ? b.push(this._title) : this._title.render()), this._options.subtitles) for (a = 0; a < this._options.subtitles.length; a++)this.subtitles = [], c = new I(this, this._options.subtitles[a]), this.subtitles.push(c), c.dockInsidePlotArea ? b.push(c) : c.render(); for (this.legend = new J(this, this._options.legend, this.theme), a = 0; a < this.data.length; a++)(this.data[a].showInLegend || "pie" === this.data[a].type || "doughnut" === this.data[a].type) && this.legend.dataSeries.push(this.data[a]); if (this.legend.dockInsidePlotArea ? b.push(this.legend) : this.legend.render(), "normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) M.setLayoutAndRender(this.axisX, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace()); else { if ("none" !== this.plotInfo.axisPlacement) return; this.preparePlotArea() } for (a = 0; a < b.length; a++)b[a].render(); var d = []; if (this.animatedRender) { var e = w(this.width, this.height); e.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height) } for (a = 0; a < this.plotInfo.plotTypes.length; a++)for (b = this.plotInfo.plotTypes[a], c = 0; c < b.plotUnits.length; c++) { var f = b.plotUnits[c], g = null; f.targetCanvas = null, this.animatedRender && (f.targetCanvas = w(this.width, this.height), f.targetCanvasCtx = f.targetCanvas.getContext("2d")), "line" === f.type ? g = this.renderLine(f) : "stepLine" === f.type ? g = this.renderStepLine(f) : "spline" === f.type ? g = this.renderSpline(f) : "column" === f.type ? g = this.renderColumn(f) : "bar" === f.type ? g = this.renderBar(f) : "area" === f.type ? g = this.renderArea(f) : "stepArea" === f.type ? g = this.renderStepArea(f) : "splineArea" === f.type ? g = this.renderSplineArea(f) : "stackedColumn" === f.type ? g = this.renderStackedColumn(f) : "stackedColumn100" === f.type ? g = this.renderStackedColumn100(f) : "stackedBar" === f.type ? g = this.renderStackedBar(f) : "stackedBar100" === f.type ? g = this.renderStackedBar100(f) : "stackedArea" === f.type ? g = this.renderStackedArea(f) : "stackedArea100" === f.type ? g = this.renderStackedArea100(f) : "bubble" === f.type ? g = g = this.renderBubble(f) : "scatter" === f.type ? g = this.renderScatter(f) : "pie" === f.type ? this.renderPie(f) : "doughnut" === f.type ? this.renderPie(f) : "candlestick" === f.type ? g = this.renderCandlestick(f) : "ohlc" === f.type ? g = this.renderCandlestick(f) : "rangeColumn" === f.type ? g = this.renderRangeColumn(f) : "rangeBar" === f.type ? g = this.renderRangeBar(f) : "rangeArea" === f.type ? g = this.renderRangeArea(f) : "rangeSplineArea" === f.type && (g = this.renderRangeSplineArea(f)); for (var h = 0; h < f.dataSeriesIndexes.length; h++)this._dataInRenderedOrder.push(this.data[f.dataSeriesIndexes[h]]); this.animatedRender && g && d.push(g) } this.animatedRender && 0 < this._indexLabels.length && (a = w(this.width, this.height).getContext("2d"), d.push(this.renderIndexLabels(a))); var i = this; 0 < d.length ? (i.disableToolTip = !0, i._animator.animate(200, i.animationDuration, function (a) { i.ctx.clearRect(0, 0, i.width, i.height), i.ctx.drawImage(e, 0, 0, Math.floor(i.width * ea), Math.floor(i.height * ea), 0, 0, i.width, i.height); for (var b = 0; b < d.length; b++)g = d[b], 1 > a && void 0 !== g.startTimePercent ? a >= g.startTimePercent && g.animationCallback(g.easingFunction(a - g.startTimePercent, 0, 1, 1 - g.startTimePercent), g) : g.animationCallback(g.easingFunction(a, 0, 1, 1), g); i.dispatchEvent("dataAnimationIterationEnd", { chart: i }) }, function () { d = []; for (var a = 0; a < i.plotInfo.plotTypes.length; a++)for (var b = i.plotInfo.plotTypes[a], c = 0; c < b.plotUnits.length; c++)b.plotUnits[c].targetCanvas = null; e = null, i.disableToolTip = !1 })) : (0 < i._indexLabels.length && i.renderIndexLabels(), i.dispatchEvent("dataAnimationIterationEnd", { chart: i })), this.attachPlotAreaEventHandlers(), this.zoomEnabled || this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display || A(this._zoomButton, this._resetButton), this._toolTip._updateToolTip(), this.renderCount++ }, C.prototype.attachPlotAreaEventHandlers = function () { this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.zoomEnabled ? "col-resize" : "move", cursor: this.panEnabled ? "move" : "default", capture: !0, bounds: this.plotArea }) }, C.prototype.categoriseDataSeries = function () { for (var a = "", b = 0; b < this.data.length; b++)if (a = this.data[b], a.dataPoints && 0 !== a.dataPoints.length && a.visible && 0 <= C._supportedChartTypes.indexOf(a.type)) { for (var c = null, d = !1, e = null, f = !1, g = 0; g < this.plotInfo.plotTypes.length; g++)if (this.plotInfo.plotTypes[g].type === a.type) { d = !0, c = this.plotInfo.plotTypes[g]; break } for (d || (c = { type: a.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(c)), g = 0; g < c.plotUnits.length; g++)if (c.plotUnits[g].axisYType === a.axisYType) { f = !0, e = c.plotUnits[g]; break } f || (e = { type: a.type, previousDataSeriesCount: 0, index: c.plotUnits.length, plotType: c, axisYType: a.axisYType, axisY: "primary" === a.axisYType ? this.axisY : this.axisY2, axisX: this.axisX, dataSeriesIndexes: [], yTotals: [] }, c.plotUnits.push(e)), c.totalDataSeries++ , e.dataSeriesIndexes.push(b), a.plotUnit = e } for (b = 0; b < this.plotInfo.plotTypes.length; b++)for (c = this.plotInfo.plotTypes[b], g = a = 0; g < c.plotUnits.length; g++)c.plotUnits[g].previousDataSeriesCount = a, a += c.plotUnits[g].dataSeriesIndexes.length }, C.prototype.assignIdToDataPoints = function () { for (var a = 0; a < this.data.length; a++) { var b = this.data[a]; if (b.dataPoints) for (var c = b.dataPoints.length, d = 0; d < c; d++)b.dataPointIds[d] = ++this._eventManager.lastObjectId } }, C.prototype._processData = function () { this.assignIdToDataPoints(), this.categoriseDataSeries(); for (var a = 0; a < this.plotInfo.plotTypes.length; a++)for (var b = this.plotInfo.plotTypes[a], c = 0; c < b.plotUnits.length; c++) { var d = b.plotUnits[c]; "line" === d.type || "stepLine" === d.type || "spline" === d.type || "column" === d.type || "area" === d.type || "stepArea" === d.type || "splineArea" === d.type || "bar" === d.type || "bubble" === d.type || "scatter" === d.type ? this._processMultiseriesPlotUnit(d) : "stackedColumn" === d.type || "stackedBar" === d.type || "stackedArea" === d.type ? this._processStackedPlotUnit(d) : "stackedColumn100" === d.type || "stackedBar100" === d.type || "stackedArea100" === d.type ? this._processStacked100PlotUnit(d) : "candlestick" !== d.type && "ohlc" !== d.type && "rangeColumn" !== d.type && "rangeBar" !== d.type && "rangeArea" !== d.type && "rangeSplineArea" !== d.type || this._processMultiYPlotUnit(d) } }, C.prototype._processMultiseriesPlotUnit = function (a) { if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var b, c, d = a.axisY.dataInfo, e = a.axisX.dataInfo, f = !1, g = 0; g < a.dataSeriesIndexes.length; g++) { var h, i = this.data[a.dataSeriesIndexes[g]], j = 0, k = !1, l = !1; if ("normal" === i.axisPlacement || "xySwapped" === i.axisPlacement) var m = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : a.axisX.logarithmic ? 0 : -1 / 0, n = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0; for ((i.dataPoints[j].x && i.dataPoints[j].x.getTime || "dateTime" === i.xValueType) && (f = !0), j = 0; j < i.dataPoints.length; j++) { if (void 0 === i.dataPoints[j].x && (i.dataPoints[j].x = j + (a.axisX.logarithmic ? 1 : 0)), i.dataPoints[j].x.getTime ? (f = !0, b = i.dataPoints[j].x.getTime()) : b = i.dataPoints[j].x, c = i.dataPoints[j].y, b < e.min && (e.min = b), b > e.max && (e.max = b), c < d.min && (d.min = c), c > d.max && (d.max = c), 0 < j) { if (a.axisX.logarithmic) { var o = b / i.dataPoints[j - 1].x; 1 > o && (o = 1 / o), e.minDiff > o && 1 !== o && (e.minDiff = o) } else o = b - i.dataPoints[j - 1].x, 0 > o && (o *= -1), e.minDiff > o && 0 !== o && (e.minDiff = o); null !== c && null !== i.dataPoints[j - 1].y && (a.axisY.logarithmic ? (o = c / i.dataPoints[j - 1].y, 1 > o && (o = 1 / o), d.minDiff > o && 1 !== o && (d.minDiff = o)) : (o = c - i.dataPoints[j - 1].y, 0 > o && (o *= -1), d.minDiff > o && 0 !== o && (d.minDiff = o))) } if (b < m && !k) null !== c && (h = b); else { if (!k && (k = !0, 0 < j)) { j -= 2; continue } if (b > n && !l) l = !0; else if (b > n && l) continue; i.dataPoints[j].label && (a.axisX.labels[b] = i.dataPoints[j].label), b < e.viewPortMin && (e.viewPortMin = b), b > e.viewPortMax && (e.viewPortMax = b), null === c ? e.viewPortMin === b && h < b && (e.viewPortMin = h) : (c < d.viewPortMin && (d.viewPortMin = c), c > d.viewPortMax && (d.viewPortMax = c)) } } this.plotInfo.axisXValueType = i.xValueType = f ? "dateTime" : "number" } }, C.prototype._processStackedPlotUnit = function (a) { if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) { for (var b, c, d = a.axisY.dataInfo, e = a.axisX.dataInfo, f = !1, g = [], h = [], i = 1 / 0, j = 0; j < a.dataSeriesIndexes.length; j++) { var k, l = this.data[a.dataSeriesIndexes[j]], m = 0, n = !1, p = !1; if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement) var q = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -1 / 0, r = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0; for ((l.dataPoints[m].x && l.dataPoints[m].x.getTime || "dateTime" === l.xValueType) && (f = !0), m = 0; m < l.dataPoints.length; m++) { if (void 0 === l.dataPoints[m].x && (l.dataPoints[m].x = m + (a.axisX.logarithmic ? 1 : 0)), l.dataPoints[m].x.getTime ? (f = !0, b = l.dataPoints[m].x.getTime()) : b = l.dataPoints[m].x, o(l.dataPoints[m].y) ? c = 0 : (c = l.dataPoints[m].y, 0 === j && (i = Math.min(c, i))), b < e.min && (e.min = b), b > e.max && (e.max = b), 0 < m) { if (a.axisX.logarithmic) { var s = b / l.dataPoints[m - 1].x; 1 > s && (s = 1 / s), e.minDiff > s && 1 !== s && (e.minDiff = s) } else s = b - l.dataPoints[m - 1].x, 0 > s && (s *= -1), e.minDiff > s && 0 !== s && (e.minDiff = s); null !== c && null !== l.dataPoints[m - 1].y && (a.axisY.logarithmic ? 0 < c && (s = c / l.dataPoints[m - 1].y, 1 > s && (s = 1 / s), d.minDiff > s && 1 !== s && (d.minDiff = s)) : (s = c - l.dataPoints[m - 1].y, 0 > s && (s *= -1), d.minDiff > s && 0 !== s && (d.minDiff = s))) } if (b < q && !n) null !== l.dataPoints[m].y && (k = b); else { if (!n && (n = !0, 0 < m)) { m -= 2; continue } if (b > r && !p) p = !0; else if (b > r && p) continue; l.dataPoints[m].label && (a.axisX.labels[b] = l.dataPoints[m].label), b < e.viewPortMin && (e.viewPortMin = b), b > e.viewPortMax && (e.viewPortMax = b), null === l.dataPoints[m].y ? e.viewPortMin === b && k < b && (e.viewPortMin = k) : (a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + Math.abs(c), 0 <= c ? g[b] = g[b] ? g[b] + c : c : h[b] = h[b] ? h[b] + c : c) } } this.plotInfo.axisXValueType = l.xValueType = f ? "dateTime" : "number" } for (m in g) g.hasOwnProperty(m) && !isNaN(m) && (a = g[m], a < d.min && (d.min = Math.min(a, i)), a > d.max && (d.max = a), m < e.viewPortMin || m > e.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = Math.min(a, i)), a > d.viewPortMax && (d.viewPortMax = a))); for (m in h) h.hasOwnProperty(m) && !isNaN(m) && (a = h[m], a < d.min && (d.min = Math.min(a, i)), a > d.max && (d.max = a), m < e.viewPortMin || m > e.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = Math.min(a, i)), a > d.viewPortMax && (d.viewPortMax = a))) } }, C.prototype._processStacked100PlotUnit = function (a) { if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) { for (var b, c, d = a.axisY.dataInfo, e = a.axisX.dataInfo, f = !1, g = !1, h = !1, i = [], j = 0; j < a.dataSeriesIndexes.length; j++) { var k, l = this.data[a.dataSeriesIndexes[j]], m = 0, n = !1, p = !1; if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement) var q = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -1 / 0, r = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0; for ((l.dataPoints[m].x && l.dataPoints[m].x.getTime || "dateTime" === l.xValueType) && (f = !0), m = 0; m < l.dataPoints.length; m++) { if (void 0 === l.dataPoints[m].x && (l.dataPoints[m].x = m + (a.axisX.logarithmic ? 1 : 0)), l.dataPoints[m].x.getTime ? (f = !0, b = l.dataPoints[m].x.getTime()) : b = l.dataPoints[m].x, c = o(l.dataPoints[m].y) ? null : l.dataPoints[m].y, b < e.min && (e.min = b), b > e.max && (e.max = b), 0 < m) { if (a.axisX.logarithmic) { var s = b / l.dataPoints[m - 1].x; 1 > s && (s = 1 / s), e.minDiff > s && 1 !== s && (e.minDiff = s) } else s = b - l.dataPoints[m - 1].x, 0 > s && (s *= -1), e.minDiff > s && 0 !== s && (e.minDiff = s); o(c) || null === l.dataPoints[m - 1].y || (a.axisY.logarithmic ? 0 < c && (s = c / l.dataPoints[m - 1].y, 1 > s && (s = 1 / s), d.minDiff > s && 1 !== s && (d.minDiff = s)) : (s = c - l.dataPoints[m - 1].y, 0 > s && (s *= -1), d.minDiff > s && 0 !== s && (d.minDiff = s))) } if (b < q && !n) null !== c && (k = b); else { if (!n && (n = !0, 0 < m)) { m -= 2; continue } if (b > r && !p) p = !0; else if (b > r && p) continue; l.dataPoints[m].label && (a.axisX.labels[b] = l.dataPoints[m].label), b < e.viewPortMin && (e.viewPortMin = b), b > e.viewPortMax && (e.viewPortMax = b), null === c ? e.viewPortMin === b && k < b && (e.viewPortMin = k) : (a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + Math.abs(c), 0 <= c ? g = !0 : 0 > c && (h = !0), i[b] = i[b] ? i[b] + Math.abs(c) : Math.abs(c)) } } this.plotInfo.axisXValueType = l.xValueType = f ? "dateTime" : "number" } a.axisY.logarithmic ? (d.max = o(d.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -.05) : Math.max(d.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -.05)), d.min = o(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : g && !h ? (d.max = o(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = o(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : g && h ? (d.max = o(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = o(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99)) : !g && h && (d.max = o(d.viewPortMax) ? -1 : Math.max(d.viewPortMax, -1), d.min = o(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99)), d.viewPortMin = d.min, d.viewPortMax = d.max, a.dataPointYSums = i } }, C.prototype._processMultiYPlotUnit = function (a) { if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var b, c, d, e, f = a.axisY.dataInfo, g = a.axisX.dataInfo, h = !1, i = 0; i < a.dataSeriesIndexes.length; i++) { var j, k, l, m = this.data[a.dataSeriesIndexes[i]], n = 0, o = !1, p = !1; if ("normal" === m.axisPlacement || "xySwapped" === m.axisPlacement) var q = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -1 / 0, r = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0; for ((m.dataPoints[n].x && m.dataPoints[n].x.getTime || "dateTime" === m.xValueType) && (h = !0), n = 0; n < m.dataPoints.length; n++) { if (void 0 === m.dataPoints[n].x && (m.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0)), m.dataPoints[n].x.getTime ? (h = !0, b = m.dataPoints[n].x.getTime()) : b = m.dataPoints[n].x, (c = m.dataPoints[n].y) && c.length) { d = Math.min.apply(null, c), e = Math.max.apply(null, c), k = !0; for (var s = 0; s < c.length; s++)null === c.k && (k = !1); k && (o || (l = j), j = b) } if (b < g.min && (g.min = b), b > g.max && (g.max = b), d < f.min && (f.min = d), e > f.max && (f.max = e), 0 < n && (a.axisX.logarithmic ? (k = b / m.dataPoints[n - 1].x, 1 > k && (k = 1 / k), g.minDiff > k && 1 !== k && (g.minDiff = k)) : (k = b - m.dataPoints[n - 1].x, 0 > k && (k *= -1), g.minDiff > k && 0 !== k && (g.minDiff = k)), c && null !== c[0] && m.dataPoints[n - 1].y && null !== m.dataPoints[n - 1].y[0] && (a.axisY.logarithmic ? (k = c[0] / m.dataPoints[n - 1].y[0], 1 > k && (k = 1 / k), f.minDiff > k && 1 !== k && (f.minDiff = k)) : (k = c[0] - m.dataPoints[n - 1].y[0], 0 > k && (k *= -1), f.minDiff > k && 0 !== k && (f.minDiff = k)))), !(b < q) || o) { if (!o && (o = !0, 0 < n)) { n -= 2, j = l; continue } if (b > r && !p) p = !0; else if (b > r && p) continue; if (m.dataPoints[n].label && (a.axisX.labels[b] = m.dataPoints[n].label), b < g.viewPortMin && (g.viewPortMin = b), b > g.viewPortMax && (g.viewPortMax = b), g.viewPortMin === b && c) for (s = 0; s < c.length; s++)if (null === c[s] && j < b) { g.viewPortMin = j; break } null === c ? g.viewPortMin === b && j < b && (g.viewPortMin = j) : (d < f.viewPortMin && (f.viewPortMin = d), e > f.viewPortMax && (f.viewPortMax = e)) } } this.plotInfo.axisXValueType = m.xValueType = h ? "dateTime" : "number" } }, C.prototype.getDataPointAtXY = function (a, b, c) { c = c || !1; for (var d = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) { var f = null; (f = this._dataInRenderedOrder[e].getDataPointAtXY(a, b, c)) && d.push(f) } for (a = null, b = !1, c = 0; c < d.length; c++)if (("line" === d[c].dataSeries.type || "stepLine" === d[c].dataSeries.type || "area" === d[c].dataSeries.type || "stepArea" === d[c].dataSeries.type) && (e = t("markerSize", d[c].dataPoint, d[c].dataSeries) || 8, d[c].distance <= e / 2)) { b = !0; break } for (c = 0; c < d.length; c++)b && "line" !== d[c].dataSeries.type && "stepLine" !== d[c].dataSeries.type && "area" !== d[c].dataSeries.type && "stepArea" !== d[c].dataSeries.type || (a ? d[c].distance <= a.distance && (a = d[c]) : a = d[c]); return a }, C.prototype.getObjectAtXY = function (a, b, c) { var d = null; if (c = this.getDataPointAtXY(a, b, c || !1)) d = c.dataSeries.dataPointIds[c.dataPointIndex]; else if (S) d = s(a, b, this._eventManager.ghostCtx); else for (c = 0; c < this.legend.items.length; c++) { var e = this.legend.items[c]; a >= e.x1 && a <= e.x2 && b >= e.y1 && b <= e.y2 && (d = e.id) } return d }, C.prototype.getAutoFontSize = function (a, b, c) { return a /= 400, Math.max(10, Math.round(Math.min(this.width, this.height) * a)) }, C.prototype.resetOverlayedCanvas = function () { this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height) }, C.prototype.clearCanvas = function () { this.ctx.clearRect(0, 0, this.width, this.height), this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height)) }, C.prototype.attachEvent = function (a) { this._events.push(a) }, C.prototype._touchEventHandler = function (a) { if (a.changedTouches && this.interactivityEnabled) { var b = [], c = a.changedTouches, d = c ? c[0] : a, e = null; switch (a.type) { case "touchstart": case "MSPointerDown": b = ["mousemove", "mousedown"], this._lastTouchData = aa(d), this._lastTouchData.time = new Date; break; case "touchmove": case "MSPointerMove": b = ["mousemove"]; break; case "touchend": case "MSPointerUp": b = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType ? ["mouseup", "click"] : ["mouseup"]; break; default: return }if (!(c && 1 < c.length)) { e = aa(d), e.time = new Date; try { var f = e.y - this._lastTouchData.y, g = e.time - this._lastTouchData.time; if (15 < Math.abs(f) && (this._lastTouchData.scroll || 200 > g)) { this._lastTouchData.scroll = !0; var h = window.parent || window; h && h.scrollBy && h.scrollBy(0, -f) } } catch (a) { } if (this._lastTouchEventType = a.type, this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1; else for (c = 0; c < b.length; c++)e = b[c], f = document.createEvent("MouseEvent"), f.initMouseEvent(e, !0, !0, window, 1, d.screenX, d.screenY, d.clientX, d.clientY, !1, !1, !1, !1, 0, null), d.target.dispatchEvent(f), a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault() } } }, C.prototype._dispatchRangeEvent = function (a, b) { var c = {}; c.chart = this._publicChartReference, c.type = a, c.trigger = b; var d = []; this.axisX && d.push("axisX"), this.axisY && d.push("axisY"), this.axisY2 && d.push("axisY2"); for (var e = 0; e < d.length; e++)c[d[e]] = { viewportMinimum: this[d[e]].sessionVariables.newViewportMinimum, viewportMaximum: this[d[e]].sessionVariables.newViewportMaximum }; this.dispatchEvent(a, c, this._publicChartReference) }, C.prototype._mouseEventHandler = function (a) { void 0 === a.target && a.srcElement && (a.target = a.srcElement); var b, c, d = aa(a), e = a.type; if (a.which ? c = 3 == a.which : a.button && (c = 2 == a.button), C.capturedEventParam && (b = C.capturedEventParam, "mouseup" === e && (C.capturedEventParam = null, b.chart.overlaidCanvas.releaseCapture ? b.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", b.chart._mouseEventHandler, !1)), b.hasOwnProperty(e) && ("mouseup" !== e || b.chart.overlaidCanvas.releaseCapture ? a.target === b.chart.overlaidCanvas && b[e].call(b.context, d.x, d.y) : a.target !== b.chart.overlaidCanvas && (b.chart.isDrag = !1))), this.interactivityEnabled) if (this._ignoreNextEvent) this._ignoreNextEvent = !1; else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), !c) { if (!C.capturedEventParam && this._events) { for (var f = 0; f < this._events.length; f++)if (this._events[f].hasOwnProperty(e)) { if (b = this._events[f], c = b.bounds, d.x >= c.x1 && d.x <= c.x2 && d.y >= c.y1 && d.y <= c.y2) { b[e].call(b.context, d.x, d.y), "mousedown" === e && !0 === b.capture ? (C.capturedEventParam = b, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === e && (b.chart.overlaidCanvas.releaseCapture ? b.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1)); break } b = null } a.target.style.cursor = b && b.cursor ? b.cursor : this._defaultCursor } e = this.plotArea, (d.x < e.x1 || d.x > e.x2 || d.y < e.y1 || d.y > e.y2) && (this._toolTip && this._toolTip.enabled ? this._toolTip.hide() : this.resetOverlayedCanvas()), this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a) } }, C.prototype._plotAreaMouseDown = function (a, b) { this.isDrag = !0, this.dragStartPoint = { x: a, y: b } }, C.prototype._plotAreaMouseUp = function (a, b) { if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) { var c = b - this.dragStartPoint.y, d = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"), g = !1; if (this.resetOverlayedCanvas(), "xySwapped" === this.plotInfo.axisPlacement) var h = f, f = e, e = h; if (this.panEnabled || this.zoomEnabled) { if (this.panEnabled) for (e = f = 0; e < this._axes.length; e++)c = this._axes[e], c.logarithmic ? c.viewportMinimum < c.minimum ? (f = c.minimum / c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum * f, c.sessionVariables.newViewportMaximum = c.viewportMaximum * f, g = !0) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum / c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum / f, c.sessionVariables.newViewportMaximum = c.viewportMaximum / f, g = !0) : c.viewportMinimum < c.minimum ? (f = c.minimum - c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum + f, c.sessionVariables.newViewportMaximum = c.viewportMaximum + f, g = !0) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum - c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum - f, c.sessionVariables.newViewportMaximum = c.viewportMaximum - f, g = !0); else if ((!e || 2 < Math.abs(d)) && (!f || 2 < Math.abs(c)) && this.zoomEnabled) { if (!this.dragStartPoint) return; c = e ? this.dragStartPoint.x : this.plotArea.x1, d = f ? this.dragStartPoint.y : this.plotArea.y1, e = e ? a : this.plotArea.x2, f = f ? b : this.plotArea.y2, 2 < Math.abs(c - e) && 2 < Math.abs(d - f) && this._zoomPanToSelectedRegion(c, d, e, f) && (g = !0) } g && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), g && this.zoomEnabled && "none" === this._zoomButton.style.display && (z(this._zoomButton, this._resetButton), y(this, this._zoomButton, "pan"), y(this, this._resetButton, "reset"))) } } this.isDrag = !1 }, C.prototype._plotAreaMouseMove = function (a, b) { if (this.isDrag && "none" !== this.plotInfo.axisPlacement) { var c = 0, d = 0, e = c = null, e = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"); if ("xySwapped" === this.plotInfo.axisPlacement && (c = f, f = e, e = c), c = this.dragStartPoint.x - a, d = this.dragStartPoint.y - b, 2 < Math.abs(c) && 8 > Math.abs(c) && (this.panEnabled || this.zoomEnabled) ? this._toolTip.hide() : this.panEnabled || this.zoomEnabled || this._toolTip.mouseMoveHandler(a, b), (!e || 2 < Math.abs(c) || !f || 2 < Math.abs(d)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) e = { x1: e ? this.plotArea.x1 + c : this.plotArea.x1, y1: f ? this.plotArea.y1 + d : this.plotArea.y1, x2: e ? this.plotArea.x2 + c : this.plotArea.x2, y2: f ? this.plotArea.y2 + d : this.plotArea.y2 }, this._zoomPanToSelectedRegion(e.x1, e.y1, e.x2, e.y2, !0) && (this._dispatchRangeEvent("rangeChanging", "pan"), this.render(), this._dispatchRangeEvent("rangeChanged", "pan"), this.dragStartPoint.x = a, this.dragStartPoint.y = b); else if (this.zoomEnabled) { this.resetOverlayedCanvas(), c = this.overlaidCanvasCtx.globalAlpha, this.overlaidCanvasCtx.fillStyle = "#A89896"; var d = e ? this.dragStartPoint.x : this.plotArea.x1, g = f ? this.dragStartPoint.y : this.plotArea.y1, h = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, i = f ? b - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1; this.validateRegion(d, g, e ? a : this.plotArea.x2 - this.plotArea.x1, f ? b : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5"), this.overlaidCanvasCtx.globalAlpha = .7, this.overlaidCanvasCtx.fillRect(d, g, h, i), this.overlaidCanvasCtx.globalAlpha = c } } else this._toolTip.mouseMoveHandler(a, b) }, C.prototype._zoomPanToSelectedRegion = function (a, b, c, d, e) { if (a = this.validateRegion(a, b, c, d, e), b = a.axesWithValidRange, c = a.axesRanges, a.isValid) for (d = 0; d < b.length; d++)e = c[d], b[d].setViewPortRange(e.val1, e.val2); return a.isValid }, C.prototype.validateRegion = function (a, b, c, d, e) { e = e || !1; var f = 0 <= this.zoomType.indexOf("x"), g = 0 <= this.zoomType.indexOf("y"), h = !1, i = [], j = [], k = []; for (this.axisX && f && j.push(this.axisX), this.axisY && g && j.push(this.axisY), this.axisY2 && g && j.push(this.axisY2), f = 0; f < j.length; f++) { var g = j[f], l = g.convertPixelToValue({ x: a, y: b }), m = g.convertPixelToValue({ x: c, y: d }); if (l > m) var n = m, m = l, l = n; if (isFinite(g.dataInfo.minDiff)) if (g.logarithmic && m / l < Math.pow(g.dataInfo.minDiff, 3) || !g.logarithmic && Math.abs(m - l) < 3 * Math.abs(g.dataInfo.minDiff) || l < g.minimum || m > g.maximum) { if (!e) { h = !1; break } } else i.push(g), k.push({ val1: l, val2: m }), h = !0 } return { isValid: h, axesWithValidRange: i, axesRanges: k } }, C.prototype.preparePlotArea = function () { var a = this.plotArea, b = this.axisY ? this.axisY : this.axisY2; !S && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1), this.axisX && b ? (a.x1 = this.axisX.lineCoordinates.x1 < this.axisX.lineCoordinates.x2 ? this.axisX.lineCoordinates.x1 : b.lineCoordinates.x1, a.y1 = this.axisX.lineCoordinates.y1 < b.lineCoordinates.y1 ? this.axisX.lineCoordinates.y1 : b.lineCoordinates.y1, a.x2 = this.axisX.lineCoordinates.x2 > b.lineCoordinates.x2 ? this.axisX.lineCoordinates.x2 : b.lineCoordinates.x2, a.y2 = this.axisX.lineCoordinates.y2 > this.axisX.lineCoordinates.y1 ? this.axisX.lineCoordinates.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1) : (b = this.layoutManager.getFreeSpace(), a.x1 = b.x1, a.x2 = b.x2, a.y1 = b.y1, a.y2 = b.y2, a.width = b.width, a.height = b.height), S || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1)), a.layoutManager = new F(a.x1, a.y1, a.x2, a.y2, 2) }, C.prototype.getPixelCoordinatesOnPlotArea = function (a, b) { return { x: this.axisX.getPixelCoordinatesOnAxis(a).x, y: this.axisY.getPixelCoordinatesOnAxis(b).y } }, C.prototype.renderIndexLabels = function (a) { a = a || this.plotArea.ctx; for (var b = this.plotArea, c = 0, d = 0, e = 0, f = 0, g = c = f = d = e = 0, h = 0, i = 0; i < this._indexLabels.length; i++) { var j, k, l = this._indexLabels[i], m = l.chartType.toLowerCase(), n = t("indexLabelFontColor", l.dataPoint, l.dataSeries), g = t("indexLabelFontSize", l.dataPoint, l.dataSeries), h = t("indexLabelFontFamily", l.dataPoint, l.dataSeries); j = t("indexLabelFontStyle", l.dataPoint, l.dataSeries), k = t("indexLabelFontWeight", l.dataPoint, l.dataSeries); var f = t("indexLabelBackgroundColor", l.dataPoint, l.dataSeries), d = t("indexLabelMaxWidth", l.dataPoint, l.dataSeries), e = t("indexLabelWrap", l.dataPoint, l.dataSeries), p = t("indexLabelLineDashType", l.dataPoint, l.dataSeries), r = t("indexLabelLineColor", l.dataPoint, l.dataSeries), s = o(l.dataPoint.indexLabelLineThickness) ? o(l.dataSeries._options.indexLabelLineThickness) ? 0 : l.dataSeries._options.indexLabelLineThickness : l.dataPoint.indexLabelLineThickness, c = 0 < s ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, u = { percent: null, total: null }, v = null; (0 <= l.dataSeries.type.indexOf("stacked") || "pie" === l.dataSeries.type || "doughnut" === l.dataSeries.type) && (u = this.getPercentAndTotal(l.dataSeries, l.dataPoint)), (l.dataSeries.indexLabelFormatter || l.dataPoint.indexLabelFormatter) && (v = { chart: this._publicChartReference, dataSeries: l.dataSeries, dataPoint: l.dataPoint, index: l.indexKeyword, total: u.total, percent: u.percent }); var w = l.dataPoint.indexLabelFormatter ? l.dataPoint.indexLabelFormatter(v) : l.dataPoint.indexLabel ? this.replaceKeywordsWithValue(l.dataPoint.indexLabel, l.dataPoint, l.dataSeries, null, l.indexKeyword) : l.dataSeries.indexLabelFormatter ? l.dataSeries.indexLabelFormatter(v) : l.dataSeries.indexLabel ? this.replaceKeywordsWithValue(l.dataSeries.indexLabel, l.dataPoint, l.dataSeries, null, l.indexKeyword) : null; if (null !== w && "" !== w) { var u = t("indexLabelPlacement", l.dataPoint, l.dataSeries), v = t("indexLabelOrientation", l.dataPoint, l.dataSeries), x = l.direction, y = l.dataSeries.axisX, z = l.dataSeries.axisY, A = !1, n = new G(a, { x: 0, y: 0, maxWidth: d || .5 * this.width, maxHeight: e ? 5 * g : 1.5 * g, angle: "horizontal" === v ? 0 : -90, text: w, padding: 0, backgroundColor: f, horizontalAlign: "left", fontSize: g, fontFamily: h, fontWeight: k, fontColor: n, fontStyle: j, textBaseline: "top" }); if (n.measureText(), 0 <= m.indexOf("line") || 0 <= m.indexOf("area") || 0 <= m.indexOf("bubble") || 0 <= m.indexOf("scatter")) { if (l.dataPoint.x < y.viewportMinimum || l.dataPoint.x > y.viewportMaximum || l.dataPoint.y < z.viewportMinimum || l.dataPoint.y > z.viewportMaximum) continue } else if (0 <= m.indexOf("column")) { if (l.dataPoint.x < y.viewportMinimum || l.dataPoint.x > y.viewportMaximum || l.bounds.y1 > b.y2 || l.bounds.y2 < b.y1) continue } else if (0 <= m.indexOf("bar")) { if (l.dataPoint.x < y.viewportMinimum || l.dataPoint.x > y.viewportMaximum || l.bounds.x1 > b.x2 || l.bounds.x2 < b.x1) continue } else if (l.dataPoint.x < y.viewportMinimum || l.dataPoint.x > y.viewportMaximum) continue; d = f = 2, "horizontal" === v ? (g = n.width, h = n.height) : (h = n.width, g = n.height), "normal" === this.plotInfo.axisPlacement ? (0 <= m.indexOf("line") || 0 <= m.indexOf("area") ? (u = "auto", f = 4) : 0 <= m.indexOf("stacked") ? "auto" === u && (u = "inside") : "bubble" !== m && "scatter" !== m || (u = "inside"), j = l.point.x - g / 2, "inside" !== u ? (d = b.y1, e = b.y2, 0 < x ? (k = l.point.y - h - f - c) < d && (k = "auto" === u ? Math.max(l.point.y, d) + f + c : d + f + c, A = k + h > l.point.y) : (k = l.point.y + f + c) > e - h - f - c && (k = "auto" === u ? Math.min(l.point.y, e) - h - f - c : e - h - f - c, A = k < l.point.y)) : (d = Math.max(l.bounds.y1, b.y1), e = Math.min(l.bounds.y2, b.y2), c = 0 <= m.indexOf("range") ? 0 < x ? Math.max(l.bounds.y1, b.y1) + h / 2 + f : Math.min(l.bounds.y2, b.y2) - h / 2 - f : (Math.max(l.bounds.y1, b.y1) + Math.min(l.bounds.y2, b.y2)) / 2, 0 < x ? (k = Math.max(l.point.y, c) - h / 2) < d && ("bubble" === m || "scatter" === m) && (k = Math.max(l.point.y - h - f, b.y1 + f)) : (k = Math.min(l.point.y, c) - h / 2) > e - h - f && ("bubble" === m || "scatter" === m) && (k = Math.min(l.point.y + f, b.y2 - h - f)), k = Math.min(k, e - h))) : (0 <= m.indexOf("line") || 0 <= m.indexOf("area") || 0 <= m.indexOf("scatter") ? (u = "auto", d = 4) : 0 <= m.indexOf("stacked") ? "auto" === u && (u = "inside") : "bubble" === m && (u = "inside"), k = l.point.y - h / 2, "inside" !== u ? (f = b.x1, e = b.x2, 0 > x ? (j = l.point.x - g - d - c) < f && (j = "auto" === u ? Math.max(l.point.x, f) + d + c : f + d + c, A = j + g > l.point.x) : (j = l.point.x + d + c) > e - g - d - c && (j = "auto" === u ? Math.min(l.point.x, e) - g - d - c : e - g - d - c, A = j < l.point.x)) : (f = Math.max(l.bounds.x1, b.x1), Math.min(l.bounds.x2, b.x2), c = 0 <= m.indexOf("range") ? 0 > x ? Math.max(l.bounds.x1, b.x1) + g / 2 + d : Math.min(l.bounds.x2, b.x2) - g / 2 - d : (Math.max(l.bounds.x1, b.x1) + Math.min(l.bounds.x2, b.x2)) / 2, j = 0 > x ? Math.max(l.point.x, c) - g / 2 : Math.min(l.point.x, c) - g / 2, j = Math.max(j, f))), "vertical" === v && (k += h), n.x = j, n.y = k, n.render(!0), s && "inside" !== u && (0 > m.indexOf("bar") && l.point.x > b.x1 && l.point.x < b.x2 || !A) && (0 > m.indexOf("column") && l.point.y > b.y1 && l.point.y < b.y2 || !A) && (a.lineWidth = s, a.strokeStyle = r || "gray", a.setLineDash && a.setLineDash(q(p, s)), a.beginPath(), a.moveTo(l.point.x, l.point.y), 0 <= m.indexOf("bar") ? a.lineTo(j + (0 < l.direction ? 0 : g), k + ("horizontal" === v ? h : -h) / 2) : 0 <= m.indexOf("column") ? a.lineTo(j + g / 2, k + ((0 < l.direction ? h : -h) + ("horizontal" === v ? h : -h)) / 2) : a.lineTo(j + g / 2, k + ((k < l.point.y ? h : -h) + ("horizontal" === v ? h : -h)) / 2), a.stroke()) } } return { source: a, dest: this.plotArea.ctx, animationCallback: ia.fadeInAnimation, easingFunction: ia.easing.easeInQuad, animationBase: 0, startTimePercent: .7 } }, C.prototype.renderLine = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c = this._eventManager.ghostCtx; b.save(); var d = this.plotArea; b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(); for (var d = [], e = 0; e < a.dataSeriesIndexes.length; e++) { var f = a.dataSeriesIndexes[e], g = this.data[f]; b.lineWidth = g.lineThickness; var h = g.dataPoints, i = "solid"; if (b.setLineDash) { var j = q(g.nullDataLineDashType, g.lineThickness), i = g.lineDashType, k = q(i, g.lineThickness); b.setLineDash(k) } var l = g.id; this._eventManager.objectMap[l] = { objectType: "dataSeries", dataSeriesIndex: f }, l = m(l), c.strokeStyle = l, c.lineWidth = 0 < g.lineThickness ? Math.max(g.lineThickness, 4) : 0; var l = g._colorSet, n = l = g._options.lineColor ? g._options.lineColor : l[0]; b.strokeStyle = l; var o, p, r = !0, s = 0; if (b.beginPath(), 0 < h.length) { for (var t = !1, s = 0; s < h.length; s++)if (!((o = h[s].x.getTime ? h[s].x.getTime() : h[s].x) < a.axisX.dataInfo.viewPortMin || o > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !t))) if ("number" != typeof h[s].y) 0 < s && !(g.connectNullData || t || r) && (b.stroke(), S && c.stroke()), t = !0; else { o = a.axisX.convertValueToPixel(o), p = a.axisY.convertValueToPixel(h[s].y); var u = g.dataPointIds[s]; if (this._eventManager.objectMap[u] = { id: u, objectType: "dataPoint", dataSeriesIndex: f, dataPointIndex: s, x1: o, y1: p }, r || t ? (!r && g.connectNullData ? (b.setLineDash && (g._options.nullDataLineDashType || i === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (b.stroke(), i = g.nullDataLineDashType, b.setLineDash(j)), b.lineTo(o, p), S && c.lineTo(o, p)) : (b.beginPath(), b.moveTo(o, p), S && (c.beginPath(), c.moveTo(o, p))), t = r = !1) : (b.lineTo(o, p), S && c.lineTo(o, p), 0 == s % 500 && (b.stroke(), b.beginPath(), b.moveTo(o, p), S && (c.stroke(), c.beginPath(), c.moveTo(o, p)))), s < h.length - 1 && (n !== (h[s].lineColor || l) || i !== (h[s].lineDashType || g.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(o, p), n = h[s].lineColor || l, b.strokeStyle = n, b.setLineDash && (h[s].lineDashType ? (i = h[s].lineDashType, b.setLineDash(q(i, g.lineThickness))) : (i = g.lineDashType, b.setLineDash(k)))), 0 < h[s].markerSize || 0 < g.markerSize) { var v = g.getMarkerProperties(s, o, p, b); d.push(v), u = m(u), S && d.push({ x: o, y: p, ctx: c, type: v.type, size: v.size, color: u, borderColor: u, borderThickness: v.borderThickness }) } (h[s].indexLabel || g.indexLabel || h[s].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: h[s], dataSeries: g, point: { x: o, y: p }, direction: 0 > h[s].y === a.axisY.reversed ? 1 : -1, color: l }) } b.stroke(), S && c.stroke() } } return ja.drawMarkers(d), b.restore(), b.beginPath(), S && c.beginPath(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderStepLine = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c = this._eventManager.ghostCtx; b.save(); var d = this.plotArea; b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(); for (var d = [], e = 0; e < a.dataSeriesIndexes.length; e++) { var f = a.dataSeriesIndexes[e], g = this.data[f]; b.lineWidth = g.lineThickness; var h = g.dataPoints, i = "solid"; if (b.setLineDash) { var j = q(g.nullDataLineDashType, g.lineThickness), i = g.lineDashType, k = q(i, g.lineThickness); b.setLineDash(k) } var l = g.id; this._eventManager.objectMap[l] = { objectType: "dataSeries", dataSeriesIndex: f }, l = m(l), c.strokeStyle = l, c.lineWidth = 0 < g.lineThickness ? Math.max(g.lineThickness, 4) : 0; var l = g._colorSet, n = l = g._options.lineColor ? g._options.lineColor : l[0]; b.strokeStyle = l; var o, p, r = !0, s = 0; if (b.beginPath(), 0 < h.length) { for (var t = !1, s = 0; s < h.length; s++)if (!((o = h[s].getTime ? h[s].x.getTime() : h[s].x) < a.axisX.dataInfo.viewPortMin || o > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !t))) if ("number" != typeof h[s].y) 0 < s && !(g.connectNullData || t || r) && (b.stroke(), S && c.stroke()), t = !0; else { var u = p; o = a.axisX.convertValueToPixel(o), p = a.axisY.convertValueToPixel(h[s].y); var v = g.dataPointIds[s]; this._eventManager.objectMap[v] = { id: v, objectType: "dataPoint", dataSeriesIndex: f, dataPointIndex: s, x1: o, y1: p }, r || t ? (!r && g.connectNullData ? (b.setLineDash && (g._options.nullDataLineDashType || i === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (b.stroke(), i = g.nullDataLineDashType, b.setLineDash(j)), b.lineTo(o, u), b.lineTo(o, p), S && (c.lineTo(o, u), c.lineTo(o, p))) : (b.beginPath(), b.moveTo(o, p), S && (c.beginPath(), c.moveTo(o, p))), t = r = !1) : (b.lineTo(o, u), S && c.lineTo(o, u), b.lineTo(o, p), S && c.lineTo(o, p), 0 == s % 500 && (b.stroke(), b.beginPath(), b.moveTo(o, p), S && (c.stroke(), c.beginPath(), c.moveTo(o, p)))), s < h.length - 1 && (n !== (h[s].lineColor || l) || i !== (h[s].lineDashType || g.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(o, p), n = h[s].lineColor || l, b.strokeStyle = n, b.setLineDash && (h[s].lineDashType ? (i = h[s].lineDashType, b.setLineDash(q(i, g.lineThickness))) : (i = g.lineDashType, b.setLineDash(k)))), (0 < h[s].markerSize || 0 < g.markerSize) && (u = g.getMarkerProperties(s, o, p, b), d.push(u), v = m(v), S && d.push({ x: o, y: p, ctx: c, type: u.type, size: u.size, color: v, borderColor: v, borderThickness: u.borderThickness })), (h[s].indexLabel || g.indexLabel || h[s].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: h[s], dataSeries: g, point: { x: o, y: p }, direction: 0 > h[s].y === a.axisY.reversed ? 1 : -1, color: l }) } b.stroke(), S && c.stroke() } } return ja.drawMarkers(d), b.restore(), b.beginPath(), S && c.beginPath(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderSpline = function (a) { function b(a) { if (a = D(a, 2), 0 < a.length) { c.beginPath(), S && d.beginPath(), c.moveTo(a[0].x, a[0].y), a[0].newStrokeStyle && (c.strokeStyle = a[0].newStrokeStyle), a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray), S && d.moveTo(a[0].x, a[0].y); for (var b = 0; b < a.length - 3; b += 3)c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), S && d.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), (0 < b && 0 == b % 3e3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray && c.setLineDash(a[b + 3].newLineDashArray), S && (d.stroke(), d.beginPath(), d.moveTo(a[b + 3].x, a[b + 3].y))); c.stroke(), S && d.stroke() } } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d = this._eventManager.ghostCtx; c.save(); var e = this.plotArea; c.beginPath(), c.rect(e.x1, e.y1, e.width, e.height), c.clip(); for (var e = [], f = 0; f < a.dataSeriesIndexes.length; f++) { var g = a.dataSeriesIndexes[f], h = this.data[g]; c.lineWidth = h.lineThickness; var i = h.dataPoints, j = "solid"; if (c.setLineDash) { var k = q(h.nullDataLineDashType, h.lineThickness), j = h.lineDashType, l = q(j, h.lineThickness); c.setLineDash(l) } var n = h.id; this._eventManager.objectMap[n] = { objectType: "dataSeries", dataSeriesIndex: g }, n = m(n), d.strokeStyle = n, d.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0; var n = h._colorSet, o = n = h._options.lineColor ? h._options.lineColor : n[0]; c.strokeStyle = n; var p, r, s = 0, t = []; if (c.beginPath(), 0 < i.length) for (r = !1, s = 0; s < i.length; s++)if (!((p = i[s].getTime ? i[s].x.getTime() : i[s].x) < a.axisX.dataInfo.viewPortMin || p > a.axisX.dataInfo.viewPortMax && (!h.connectNullData || !r))) if ("number" != typeof i[s].y) 0 < s && !r && (h.connectNullData ? c.setLineDash && 0 < t.length && (h._options.nullDataLineDashType || !i[s - 1].lineDashType) && (t[t.length - 1].newLineDashArray = k, j = h.nullDataLineDashType) : (b(t), t = [])), r = !0; else { p = a.axisX.convertValueToPixel(p), r = a.axisY.convertValueToPixel(i[s].y); var u = h.dataPointIds[s]; if (this._eventManager.objectMap[u] = { id: u, objectType: "dataPoint", dataSeriesIndex: g, dataPointIndex: s, x1: p, y1: r }, t[t.length] = { x: p, y: r }, s < i.length - 1 && (o !== (i[s].lineColor || n) || j !== (i[s].lineDashType || h.lineDashType)) && (o = i[s].lineColor || n, t[t.length - 1].newStrokeStyle = o, c.setLineDash && (i[s].lineDashType ? (j = i[s].lineDashType, t[t.length - 1].newLineDashArray = q(j, h.lineThickness)) : (j = h.lineDashType, t[t.length - 1].newLineDashArray = l))), 0 < i[s].markerSize || 0 < h.markerSize) { var v = h.getMarkerProperties(s, p, r, c); e.push(v), u = m(u), S && e.push({ x: p, y: r, ctx: d, type: v.type, size: v.size, color: u, borderColor: u, borderThickness: v.borderThickness }) } (i[s].indexLabel || h.indexLabel || i[s].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({ chartType: "spline", dataPoint: i[s], dataSeries: h, point: { x: p, y: r }, direction: 0 > i[s].y === a.axisY.reversed ? 1 : -1, color: n }), r = !1 } b(t) } return ja.drawMarkers(e), c.restore(), c.beginPath(), S && d.beginPath(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }; var ga = function (a, b, c, d, e, f, g, h, i, j, k, l, m) { void 0 === m && (m = 1), g = g || 0, h = h || "black"; var n = 15 < d - b && 15 < e - c ? 8 : .35 * Math.min(d - b, e - c); a.beginPath(), a.moveTo(b, c), a.save(), a.fillStyle = f, a.globalAlpha = m, a.fillRect(b, c, d - b, e - c), a.globalAlpha = 1, 0 < g && (m = 0 == g % 2 ? 0 : .5, a.beginPath(), a.lineWidth = g, a.strokeStyle = h, a.moveTo(b, c), a.rect(b - m, c - m, d - b + 2 * m, e - c + 2 * m), a.stroke()), a.restore(), !0 === i && (a.save(), a.beginPath(), a.moveTo(b, c), a.lineTo(b + n, c + n), a.lineTo(d - n, c + n), a.lineTo(d, c), a.closePath(), g = a.createLinearGradient((d + b) / 2, c + n, (d + b) / 2, c), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, .4)"), a.fillStyle = g, a.fill(), a.restore()), !0 === j && (a.save(), a.beginPath(), a.moveTo(b, e), a.lineTo(b + n, e - n), a.lineTo(d - n, e - n), a.lineTo(d, e), a.closePath(), g = a.createLinearGradient((d + b) / 2, e - n, (d + b) / 2, e), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, .4)"), a.fillStyle = g, a.fill(), a.restore()), !0 === k && (a.save(), a.beginPath(), a.moveTo(b, c), a.lineTo(b + n, c + n), a.lineTo(b + n, e - n), a.lineTo(b, e), a.closePath(), g = a.createLinearGradient(b + n, (e + c) / 2, b, (e + c) / 2), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = g, a.fill(), a.restore()), !0 === l && (a.save(), a.beginPath(), a.moveTo(d, c), a.lineTo(d - n, c + n), a.lineTo(d - n, e - n), a.lineTo(d, e), g = a.createLinearGradient(d - n, (e + c) / 2, d, (e + c) / 2), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = g, g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = g, a.fill(), a.closePath(), a.restore()) }; C.prototype.renderColumn = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d, e, f = null, g = this.plotArea, h = 0, i = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, j = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, this.plotArea.width / a.plotType.totalDataSeries * .9) << 0, k = a.axisX.dataInfo.minDiff; for (isFinite(k) || (k = .3 * Math.abs(a.axisX.range)), k = this.dataPointWidth ? this.dataPointWidth : g.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && h > j && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, j)), !this.dataPointMaxWidth && this.dataPointMinWidth && j < h && (j = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, h)), k < h && (k = h), k > j && (k = j), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(g.x1, g.y1, g.width, g.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip()), g = 0; g < a.dataSeriesIndexes.length; g++) { var j = a.dataSeriesIndexes[g], l = this.data[j], n = l.dataPoints; if (0 < n.length) for (var o = !!(5 < k && l.bevelEnabled), h = 0; h < n.length; h++)if (!((e = n[h].getTime ? n[h].x.getTime() : n[h].x) < a.axisX.dataInfo.viewPortMin || e > a.axisX.dataInfo.viewPortMax) && "number" == typeof n[h].y) { c = a.axisX.convertValueToPixel(e), d = a.axisY.convertValueToPixel(n[h].y), c = a.axisX.reversed ? c + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + g) * k << 0 : c - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + g) * k << 0; var p, q = a.axisX.reversed ? c - k << 0 : c + k << 0; 0 <= n[h].y ? p = i : (p = d, d = i), d > p && (f = d, d = p, p = f), f = n[h].color ? n[h].color : l._colorSet[h % l._colorSet.length], ga(b, c, d, q, p, f, 0, null, o && 0 <= n[h].y, 0 > n[h].y && o, !1, !1, l.fillOpacity), f = l.dataPointIds[h], this._eventManager.objectMap[f] = { id: f, objectType: "dataPoint", dataSeriesIndex: j, dataPointIndex: h, x1: c, y1: d, x2: q, y2: p }, f = m(f), S && ga(this._eventManager.ghostCtx, c, d, q, p, f, 0, null, !1, !1, !1, !1), (n[h].indexLabel || l.indexLabel || n[h].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: n[h], dataSeries: l, point: { x: c + (q - c) / 2, y: 0 > n[h].y === a.axisY.reversed ? d : p }, direction: 0 > n[h].y === a.axisY.reversed ? 1 : -1, bounds: { x1: c, y1: Math.min(d, p), x2: q, y2: Math.max(d, p) }, color: f }) } } return b.restore(), S && this._eventManager.ghostCtx.restore(), a = Math.min(i, a.axisY.boundingRect.y2), { source: b, dest: this.plotArea.ctx, animationCallback: ia.yScaleAnimation, easingFunction: ia.easing.easeOutQuart, animationBase: a } } }, C.prototype.renderStackedColumn = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d = null, e = this.plotArea, f = [], g = [], h = [], i = 0, j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), i = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, k = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0, l = a.axisX.dataInfo.minDiff; for (isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : e.width * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && i > k && (i = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, k)), !this.dataPointMaxWidth && this.dataPointMinWidth && k < i && (k = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, i)), l < i && (l = i), l > k && (l = k), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(e.x1, e.y1, e.width, e.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()), k = 0; k < a.dataSeriesIndexes.length; k++) { var n = a.dataSeriesIndexes[k], o = this.data[n], p = o.dataPoints; if (0 < p.length) { var q = !!(5 < l && o.bevelEnabled); for (b.strokeStyle = "#4572A7 ", i = 0; i < p.length; i++)if (!((d = p[i].x.getTime ? p[i].x.getTime() : p[i].x) < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[i].y) { var r, e = a.axisX.convertValueToPixel(d), s = e - a.plotType.plotUnits.length * l / 2 + a.index * l << 0, t = s + l << 0; if (a.axisY.logarithmic) h[d] = p[i].y + (h[d] ? h[d] : 0), 0 < h[d] && (c = a.axisY.convertValueToPixel(h[d]), r = f[d] ? f[d] : j, f[d] = c); else if (c = a.axisY.convertValueToPixel(p[i].y), 0 <= p[i].y) { var u = f[d] ? f[d] : 0; c -= u, r = j - u, f[d] = u + (r - c) } else u = g[d] ? g[d] : 0, r = c + u, c = j + u, g[d] = u + (r - c); d = p[i].color ? p[i].color : o._colorSet[i % o._colorSet.length], ga(b, s, c, t, r, d, 0, null, q && 0 <= p[i].y, 0 > p[i].y && q, !1, !1, o.fillOpacity), d = o.dataPointIds[i], this._eventManager.objectMap[d] = { id: d, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: i, x1: s, y1: c, x2: t, y2: r }, d = m(d), S && ga(this._eventManager.ghostCtx, s, c, t, r, d, 0, null, !1, !1, !1, !1), (p[i].indexLabel || o.indexLabel || p[i].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: p[i], dataSeries: o, point: { x: e, y: 0 <= p[i].y ? c : r }, direction: 0 > p[i].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(c, r), x2: t, y2: Math.max(c, r) }, color: d }) } } } return b.restore(), S && this._eventManager.ghostCtx.restore(), a = Math.min(j, a.axisY.boundingRect.y2), { source: b, dest: this.plotArea.ctx, animationCallback: ia.yScaleAnimation, easingFunction: ia.easing.easeOutQuart, animationBase: a } } }, C.prototype.renderStackedColumn100 = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d = null, e = this.plotArea, f = [], g = [], h = [], i = 0, j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), i = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, k = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0, l = a.axisX.dataInfo.minDiff; for (isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : e.width * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && i > k && (i = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, k)), !this.dataPointMaxWidth && this.dataPointMinWidth && k < i && (k = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, i)), l < i && (l = i), l > k && (l = k), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(e.x1, e.y1, e.width, e.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()), k = 0; k < a.dataSeriesIndexes.length; k++) { var n = a.dataSeriesIndexes[k], o = this.data[n], p = o.dataPoints; if (0 < p.length) for (var q = !!(5 < l && o.bevelEnabled), i = 0; i < p.length; i++)if (!((d = p[i].x.getTime ? p[i].x.getTime() : p[i].x) < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[i].y) { e = a.axisX.convertValueToPixel(d), c = 0 !== a.dataPointYSums[d] ? p[i].y / a.dataPointYSums[d] * 100 : 0; var r, s = e - a.plotType.plotUnits.length * l / 2 + a.index * l << 0, t = s + l << 0; if (a.axisY.logarithmic) { if (h[d] = c + (h[d] ? h[d] : 0), 0 >= h[d]) continue; c = a.axisY.convertValueToPixel(h[d]), r = f[d] ? f[d] : j, f[d] = c } else if (c = a.axisY.convertValueToPixel(c), 0 <= p[i].y) { var u = f[d] ? f[d] : 0; c -= u, r = j - u, f[d] = u + (r - c) } else u = g[d] ? g[d] : 0, r = c + u, c = j + u, g[d] = u + (r - c); d = p[i].color ? p[i].color : o._colorSet[i % o._colorSet.length], ga(b, s, c, t, r, d, 0, null, q && 0 <= p[i].y, 0 > p[i].y && q, !1, !1, o.fillOpacity), d = o.dataPointIds[i], this._eventManager.objectMap[d] = { id: d, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: i, x1: s, y1: c, x2: t, y2: r }, d = m(d), S && ga(this._eventManager.ghostCtx, s, c, t, r, d, 0, null, !1, !1, !1, !1), (p[i].indexLabel || o.indexLabel || p[i].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn100", dataPoint: p[i], dataSeries: o, point: { x: e, y: 0 <= p[i].y ? c : r }, direction: 0 > p[i].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(c, r), x2: t, y2: Math.max(c, r) }, color: d }) } } return b.restore(), S && this._eventManager.ghostCtx.restore(), a = Math.min(j, a.axisY.boundingRect.y2), { source: b, dest: this.plotArea.ctx, animationCallback: ia.yScaleAnimation, easingFunction: ia.easing.easeOutQuart, animationBase: a } } }, C.prototype.renderBar = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d, e, f = null, g = this.plotArea, h = 0, i = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, j = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, this.plotArea.height / a.plotType.totalDataSeries * .9) << 0, k = a.axisX.dataInfo.minDiff; for (isFinite(k) || (k = .3 * Math.abs(a.axisX.range)), k = this.dataPointWidth ? this.dataPointWidth : g.height * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && h > j && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, j)), !this.dataPointMaxWidth && this.dataPointMinWidth && j < h && (j = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, h)), k < h && (k = h), k > j && (k = j), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(g.x1, g.y1, g.width, g.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip()), g = 0; g < a.dataSeriesIndexes.length; g++) { var j = a.dataSeriesIndexes[g], l = this.data[j], n = l.dataPoints; if (0 < n.length) { var o = !!(5 < k && l.bevelEnabled); for (b.strokeStyle = "#4572A7 ", h = 0; h < n.length; h++)if (!((e = n[h].getTime ? n[h].x.getTime() : n[h].x) < a.axisX.dataInfo.viewPortMin || e > a.axisX.dataInfo.viewPortMax) && "number" == typeof n[h].y) { d = a.axisX.convertValueToPixel(e), c = a.axisY.convertValueToPixel(n[h].y), d = a.axisX.reversed ? d + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + g) * k << 0 : d - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + g) * k << 0; var p, q = a.axisX.reversed ? d - k << 0 : d + k << 0; 0 <= n[h].y ? p = i : (p = c, c = i), f = n[h].color ? n[h].color : l._colorSet[h % l._colorSet.length], ga(b, p, d, c, q, f, 0, null, o, !1, !1, !1, l.fillOpacity), f = l.dataPointIds[h], this._eventManager.objectMap[f] = { id: f, objectType: "dataPoint", dataSeriesIndex: j, dataPointIndex: h, x1: p, y1: d, x2: c, y2: q }, f = m(f), S && ga(this._eventManager.ghostCtx, p, d, c, q, f, 0, null, !1, !1, !1, !1), (n[h].indexLabel || l.indexLabel || n[h].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: n[h], dataSeries: l, point: { x: 0 <= n[h].y ? c : p, y: d + (q - d) / 2 }, direction: 0 > n[h].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(p, c), y1: d, x2: Math.max(p, c), y2: q }, color: f }) } } } return b.restore(), S && this._eventManager.ghostCtx.restore(), a = Math.max(i, a.axisX.boundingRect.x2), { source: b, dest: this.plotArea.ctx, animationCallback: ia.xScaleAnimation, easingFunction: ia.easing.easeOutQuart, animationBase: a } } }, C.prototype.renderStackedBar = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d = null, e = this.plotArea, f = [], g = [], h = [], i = 0, j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), i = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, k = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0, l = a.axisX.dataInfo.minDiff; for (isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : e.height * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && i > k && (i = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, k)), !this.dataPointMaxWidth && this.dataPointMinWidth && k < i && (k = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, i)), l < i && (l = i), l > k && (l = k), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(e.x1, e.y1, e.width, e.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()), k = 0; k < a.dataSeriesIndexes.length; k++) { var n = a.dataSeriesIndexes[k], o = this.data[n], p = o.dataPoints; if (0 < p.length) { var q = !!(5 < l && o.bevelEnabled); for (b.strokeStyle = "#4572A7 ", i = 0; i < p.length; i++)if (!((d = p[i].x.getTime ? p[i].x.getTime() : p[i].x) < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[i].y) { var r, e = a.axisX.convertValueToPixel(d), s = e - a.plotType.plotUnits.length * l / 2 + a.index * l << 0, t = s + l << 0; if (a.axisY.logarithmic) h[d] = p[i].y + (h[d] ? h[d] : 0), 0 < h[d] && (r = f[d] ? f[d] : j, f[d] = c = a.axisY.convertValueToPixel(h[d])); else if (c = a.axisY.convertValueToPixel(p[i].y), 0 <= p[i].y) { var u = f[d] ? f[d] : 0; r = j + u, c += u, f[d] = u + (c - r) } else u = g[d] ? g[d] : 0, r = c - u, c = j - u, g[d] = u + (c - r); d = p[i].color ? p[i].color : o._colorSet[i % o._colorSet.length], ga(b, r, s, c, t, d, 0, null, q, !1, !1, !1, o.fillOpacity), d = o.dataPointIds[i], this._eventManager.objectMap[d] = { id: d, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: i, x1: r, y1: s, x2: c, y2: t }, d = m(d), S && ga(this._eventManager.ghostCtx, r, s, c, t, d, 0, null, !1, !1, !1, !1), (p[i].indexLabel || o.indexLabel || p[i].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar", dataPoint: p[i], dataSeries: o, point: { x: 0 <= p[i].y ? c : r, y: e }, direction: 0 > p[i].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(r, c), y1: s, x2: Math.max(r, c), y2: t }, color: d }) } } } return b.restore(), S && this._eventManager.ghostCtx.restore(), a = Math.max(j, a.axisX.boundingRect.x2), { source: b, dest: this.plotArea.ctx, animationCallback: ia.xScaleAnimation, easingFunction: ia.easing.easeOutQuart, animationBase: a } } }, C.prototype.renderStackedBar100 = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d = null, e = this.plotArea, f = [], g = [], h = [], i = 0, j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), i = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1, k = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0, l = a.axisX.dataInfo.minDiff; for (isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : e.height * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && i > k && (i = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, k)), !this.dataPointMaxWidth && this.dataPointMinWidth && k < i && (k = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, i)), l < i && (l = i), l > k && (l = k), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(e.x1, e.y1, e.width, e.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()), k = 0; k < a.dataSeriesIndexes.length; k++) { var n = a.dataSeriesIndexes[k], o = this.data[n], p = o.dataPoints; if (0 < p.length) { var q = !!(5 < l && o.bevelEnabled); for (b.strokeStyle = "#4572A7 ", i = 0; i < p.length; i++)if (!((d = p[i].x.getTime ? p[i].x.getTime() : p[i].x) < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[i].y) { var r, e = a.axisX.convertValueToPixel(d); r = 0 !== a.dataPointYSums[d] ? p[i].y / a.dataPointYSums[d] * 100 : 0; var s = e - a.plotType.plotUnits.length * l / 2 + a.index * l << 0, t = s + l << 0; if (a.axisY.logarithmic) { if (h[d] = r + (h[d] ? h[d] : 0), 0 >= h[d]) continue; r = f[d] ? f[d] : j, f[d] = c = a.axisY.convertValueToPixel(h[d]) } else if (c = a.axisY.convertValueToPixel(r), 0 <= p[i].y) { var u = f[d] ? f[d] : 0; r = j + u, c += u, f[d] = u + (c - r) } else u = g[d] ? g[d] : 0, r = c - u, c = j - u, g[d] = u + (c - r); d = p[i].color ? p[i].color : o._colorSet[i % o._colorSet.length], ga(b, r, s, c, t, d, 0, null, q, !1, !1, !1, o.fillOpacity), d = o.dataPointIds[i], this._eventManager.objectMap[d] = { id: d, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: i, x1: r, y1: s, x2: c, y2: t }, d = m(d), S && ga(this._eventManager.ghostCtx, r, s, c, t, d, 0, null, !1, !1, !1, !1), (p[i].indexLabel || o.indexLabel || p[i].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: p[i], dataSeries: o, point: { x: 0 <= p[i].y ? c : r, y: e }, direction: 0 > p[i].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(r, c), y1: s, x2: Math.max(r, c), y2: t }, color: d }) } } } return b.restore(), S && this._eventManager.ghostCtx.restore(), a = Math.max(j, a.axisX.boundingRect.x2), { source: b, dest: this.plotArea.ctx, animationCallback: ia.xScaleAnimation, easingFunction: ia.easing.easeOutQuart, animationBase: a } } }, C.prototype.renderArea = function (a) { function b() { u && (0 < j.lineThickness && c.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? p = t : 0 > a.axisY.viewportMaximum ? p = f.y1 : 0 < a.axisY.viewportMinimum && (p = e.y2), c.lineTo(l, p), c.lineTo(u.x, p), c.closePath(), c.globalAlpha = j.fillOpacity, c.fill(), c.globalAlpha = 1, S && (d.lineTo(l, p), d.lineTo(u.x, p), d.closePath(), d.fill()), c.beginPath(), c.moveTo(l, n), d.beginPath(), d.moveTo(l, n), u = { x: l, y: n }) } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d = this._eventManager.ghostCtx, e = a.axisX.lineCoordinates, f = a.axisY.lineCoordinates, g = [], h = this.plotArea; for (c.save(), S && d.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), S && (d.beginPath(), d.rect(h.x1, h.y1, h.width, h.height), d.clip()), h = 0; h < a.dataSeriesIndexes.length; h++) { var i = a.dataSeriesIndexes[h], j = this.data[i], k = j.dataPoints, g = j.id; this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: i }, g = m(g), d.fillStyle = g; var l, n, o, p, g = [], r = !0, s = 0, t = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), u = null; if (0 < k.length) { var v = j._colorSet[s % j._colorSet.length], w = j._options.lineColor || v, x = w; c.fillStyle = v, c.strokeStyle = w, c.lineWidth = j.lineThickness; var y = "solid"; if (c.setLineDash) { var z = q(j.nullDataLineDashType, j.lineThickness), y = j.lineDashType, A = q(y, j.lineThickness); c.setLineDash(A) } for (var B = !0; s < k.length; s++)if (!((o = k[s].x.getTime ? k[s].x.getTime() : k[s].x) < a.axisX.dataInfo.viewPortMin || o > a.axisX.dataInfo.viewPortMax && (!j.connectNullData || !B))) if ("number" != typeof k[s].y) j.connectNullData || B || r || b(), B = !0; else { l = a.axisX.convertValueToPixel(o), n = a.axisY.convertValueToPixel(k[s].y), r || B ? (!r && j.connectNullData ? (c.setLineDash && (j._options.nullDataLineDashType || y === j.lineDashType && j.lineDashType !== j.nullDataLineDashType) && (c.stroke(), y = j.nullDataLineDashType, c.setLineDash(z)), c.lineTo(l, n), S && d.lineTo(l, n)) : (c.beginPath(), c.moveTo(l, n), S && (d.beginPath(), d.moveTo(l, n)), u = { x: l, y: n }), B = r = !1) : (c.lineTo(l, n), S && d.lineTo(l, n), 0 == s % 250 && b()), s < k.length - 1 && (x !== (k[s].lineColor || w) || y !== (k[s].lineDashType || j.lineDashType)) && (b(), x = k[s].lineColor || w, c.strokeStyle = x, c.setLineDash && (k[s].lineDashType ? (y = k[s].lineDashType, c.setLineDash(q(y, j.lineThickness))) : (y = j.lineDashType, c.setLineDash(A)))); var C = j.dataPointIds[s]; this._eventManager.objectMap[C] = { id: C, objectType: "dataPoint", dataSeriesIndex: i, dataPointIndex: s, x1: l, y1: n }, 0 !== k[s].markerSize && (0 < k[s].markerSize || 0 < j.markerSize) && (o = j.getMarkerProperties(s, l, n, c), g.push(o), C = m(C), S && g.push({ x: l, y: n, ctx: d, type: o.type, size: o.size, color: C, borderColor: C, borderThickness: o.borderThickness })), (k[s].indexLabel || j.indexLabel || k[s].indexLabelFormatter || j.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: k[s], dataSeries: j, point: { x: l, y: n }, direction: 0 > k[s].y === a.axisY.reversed ? 1 : -1, color: v }) } b(), ja.drawMarkers(g) } } return c.restore(), S && this._eventManager.ghostCtx.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderSplineArea = function (a) { function b() { var b = D(t, 2); if (0 < b.length) { if (0 < j.lineThickness) { c.beginPath(), c.moveTo(b[0].x, b[0].y), b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle), b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray); for (var g = 0; g < b.length - 3; g += 3)c.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y), S && d.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y), (b[g + 3].newStrokeStyle || b[g + 3].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(b[g + 3].x, b[g + 3].y), b[g + 3].newStrokeStyle && (c.strokeStyle = b[g + 3].newStrokeStyle), b[g + 3].newLineDashArray && c.setLineDash(b[g + 3].newLineDashArray)); c.stroke() } for (c.beginPath(), c.moveTo(b[0].x, b[0].y), S && (d.beginPath(), d.moveTo(b[0].x, b[0].y)), g = 0; g < b.length - 3; g += 3)c.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y), S && d.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y); a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? o = r : 0 > a.axisY.viewportMaximum ? o = f.y1 : 0 < a.axisY.viewportMinimum && (o = e.y2), s = { x: b[0].x, y: b[0].y }, c.lineTo(b[b.length - 1].x, o), c.lineTo(s.x, o), c.closePath(), c.globalAlpha = j.fillOpacity, c.fill(), c.globalAlpha = 1, S && (d.lineTo(b[b.length - 1].x, o), d.lineTo(s.x, o), d.closePath(), d.fill()) } } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d = this._eventManager.ghostCtx, e = a.axisX.lineCoordinates, f = a.axisY.lineCoordinates, g = [], h = this.plotArea; for (c.save(), S && d.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), S && (d.beginPath(), d.rect(h.x1, h.y1, h.width, h.height), d.clip()), h = 0; h < a.dataSeriesIndexes.length; h++) { var i = a.dataSeriesIndexes[h], j = this.data[i], k = j.dataPoints, g = j.id; this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: i }, g = m(g), d.fillStyle = g; var l, n, o, g = [], p = 0, r = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), s = null, t = []; if (0 < k.length) { var u = j._colorSet[p % j._colorSet.length], v = j._options.lineColor || u, w = v; c.fillStyle = u, c.strokeStyle = v, c.lineWidth = j.lineThickness; var x = "solid"; if (c.setLineDash) { var y = q(j.nullDataLineDashType, j.lineThickness), x = j.lineDashType, z = q(x, j.lineThickness); c.setLineDash(z) } for (n = !1; p < k.length; p++)if (!((l = k[p].x.getTime ? k[p].x.getTime() : k[p].x) < a.axisX.dataInfo.viewPortMin || l > a.axisX.dataInfo.viewPortMax && (!j.connectNullData || !n))) if ("number" != typeof k[p].y) 0 < p && !n && (j.connectNullData ? c.setLineDash && 0 < t.length && (j._options.nullDataLineDashType || !k[p - 1].lineDashType) && (t[t.length - 1].newLineDashArray = y, x = j.nullDataLineDashType) : (b(), t = [])), n = !0; else { l = a.axisX.convertValueToPixel(l), n = a.axisY.convertValueToPixel(k[p].y); var A = j.dataPointIds[p]; if (this._eventManager.objectMap[A] = { id: A, objectType: "dataPoint", dataSeriesIndex: i, dataPointIndex: p, x1: l, y1: n }, t[t.length] = { x: l, y: n }, p < k.length - 1 && (w !== (k[p].lineColor || v) || x !== (k[p].lineDashType || j.lineDashType)) && (w = k[p].lineColor || v, t[t.length - 1].newStrokeStyle = w, c.setLineDash && (k[p].lineDashType ? (x = k[p].lineDashType, t[t.length - 1].newLineDashArray = q(x, j.lineThickness)) : (x = j.lineDashType, t[t.length - 1].newLineDashArray = z))), 0 !== k[p].markerSize && (0 < k[p].markerSize || 0 < j.markerSize)) { var B = j.getMarkerProperties(p, l, n, c); g.push(B), A = m(A), S && g.push({ x: l, y: n, ctx: d, type: B.type, size: B.size, color: A, borderColor: A, borderThickness: B.borderThickness }) } (k[p].indexLabel || j.indexLabel || k[p].indexLabelFormatter || j.indexLabelFormatter) && this._indexLabels.push({ chartType: "splineArea", dataPoint: k[p], dataSeries: j, point: { x: l, y: n }, direction: 0 > k[p].y === a.axisY.reversed ? 1 : -1, color: u }), n = !1 } b(), ja.drawMarkers(g) } } return c.restore(), S && this._eventManager.ghostCtx.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderStepArea = function (a) { function b() { u && (0 < j.lineThickness && c.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? p = t : 0 > a.axisY.viewportMaximum ? p = f.y1 : 0 < a.axisY.viewportMinimum && (p = e.y2), c.lineTo(l, p), c.lineTo(u.x, p), c.closePath(), c.globalAlpha = j.fillOpacity, c.fill(), c.globalAlpha = 1, S && (d.lineTo(l, p), d.lineTo(u.x, p), d.closePath(), d.fill()), c.beginPath(), c.moveTo(l, n), d.beginPath(), d.moveTo(l, n), u = { x: l, y: n }) } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d = this._eventManager.ghostCtx, e = a.axisX.lineCoordinates, f = a.axisY.lineCoordinates, g = [], h = this.plotArea; for (c.save(), S && d.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), S && (d.beginPath(), d.rect(h.x1, h.y1, h.width, h.height), d.clip()), h = 0; h < a.dataSeriesIndexes.length; h++) { var i = a.dataSeriesIndexes[h], j = this.data[i], k = j.dataPoints, g = j.id; this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: i }, g = m(g), d.fillStyle = g; var l, n, o, p, g = [], r = !0, s = 0, t = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), u = null, v = !1; if (0 < k.length) { var w = j._colorSet[s % j._colorSet.length], x = j._options.lineColor || w, y = x; c.fillStyle = w, c.strokeStyle = x, c.lineWidth = j.lineThickness; var z = "solid"; if (c.setLineDash) { var A = q(j.nullDataLineDashType, j.lineThickness), z = j.lineDashType, B = q(z, j.lineThickness); c.setLineDash(B) } for (; s < k.length; s++)if (!((o = k[s].x.getTime ? k[s].x.getTime() : k[s].x) < a.axisX.dataInfo.viewPortMin || o > a.axisX.dataInfo.viewPortMax && (!j.connectNullData || !v))) { var C = n; "number" != typeof k[s].y ? (j.connectNullData || v || r || b(), v = !0) : (l = a.axisX.convertValueToPixel(o), n = a.axisY.convertValueToPixel(k[s].y), r || v ? (!r && j.connectNullData ? (c.setLineDash && (j._options.nullDataLineDashType || z === j.lineDashType && j.lineDashType !== j.nullDataLineDashType) && (c.stroke(), z = j.nullDataLineDashType, c.setLineDash(A)), c.lineTo(l, C), c.lineTo(l, n), S && (d.lineTo(l, C), d.lineTo(l, n))) : (c.beginPath(), c.moveTo(l, n), S && (d.beginPath(), d.moveTo(l, n)), u = { x: l, y: n }), v = r = !1) : (c.lineTo(l, C), S && d.lineTo(l, C), c.lineTo(l, n), S && d.lineTo(l, n), 0 == s % 250 && b()), s < k.length - 1 && (y !== (k[s].lineColor || x) || z !== (k[s].lineDashType || j.lineDashType)) && (b(), y = k[s].lineColor || x, c.strokeStyle = y, c.setLineDash && (k[s].lineDashType ? (z = k[s].lineDashType, c.setLineDash(q(z, j.lineThickness))) : (z = j.lineDashType, c.setLineDash(B)))), C = j.dataPointIds[s], this._eventManager.objectMap[C] = { id: C, objectType: "dataPoint", dataSeriesIndex: i, dataPointIndex: s, x1: l, y1: n }, 0 !== k[s].markerSize && (0 < k[s].markerSize || 0 < j.markerSize) && (o = j.getMarkerProperties(s, l, n, c), g.push(o), C = m(C), S && g.push({ x: l, y: n, ctx: d, type: o.type, size: o.size, color: C, borderColor: C, borderThickness: o.borderThickness })), (k[s].indexLabel || j.indexLabel || k[s].indexLabelFormatter || j.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: k[s], dataSeries: j, point: { x: l, y: n }, direction: 0 > k[s].y === a.axisY.reversed ? 1 : -1, color: w })) } b(), ja.drawMarkers(g) } } return c.restore(), S && this._eventManager.ghostCtx.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderStackedArea = function (a) { function b() { if (!(1 > l.length)) { for (0 < v.lineThickness && c.stroke(); 0 < l.length;) { var a = l.pop(); c.lineTo(a.x, a.y), S && s.lineTo(a.x, a.y) } c.closePath(), c.globalAlpha = v.fillOpacity, c.fill(), c.globalAlpha = 1, c.beginPath(), S && (s.closePath(), s.fill(), s.beginPath()), l = [] } } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d, e, f, g = null, h = [], i = this.plotArea, j = [], l = [], n = [], o = [], p = 0, r = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), s = this._eventManager.ghostCtx; S && s.beginPath(), c.save(), S && s.save(), c.beginPath(), c.rect(i.x1, i.y1, i.width, i.height), c.clip(), S && (s.beginPath(), s.rect(i.x1, i.y1, i.width, i.height), s.clip()); for (var t = [], i = 0; i < a.dataSeriesIndexes.length; i++) { var u = a.dataSeriesIndexes[i], v = this.data[u], w = v.dataPoints; for (v.dataPointIndexes = [], p = 0; p < w.length; p++)u = w[p].x.getTime ? w[p].x.getTime() : w[p].x, v.dataPointIndexes[u] = p, t[u] || (n.push(u), t[u] = !0); n.sort(k) } for (i = 0; i < a.dataSeriesIndexes.length; i++) { if (u = a.dataSeriesIndexes[i], v = this.data[u], w = v.dataPoints, t = !0, l = [], p = v.id, this._eventManager.objectMap[p] = { objectType: "dataSeries", dataSeriesIndex: u }, p = m(p), s.fillStyle = p, 0 < n.length) { var g = v._colorSet[0], x = v._options.lineColor || g, y = x; c.fillStyle = g, c.strokeStyle = x, c.lineWidth = v.lineThickness; var z = "solid"; if (c.setLineDash) { var A = q(v.nullDataLineDashType, v.lineThickness), z = v.lineDashType, B = q(z, v.lineThickness); c.setLineDash(B) } for (var C = !0, p = 0; p < n.length; p++) { f = n[p]; var D = null, D = 0 <= v.dataPointIndexes[f] ? w[v.dataPointIndexes[f]] : { x: f, y: null }; if (!(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax && (!v.connectNullData || !C))) if ("number" != typeof D.y) v.connectNullData || C || t || b(), C = !0; else { d = a.axisX.convertValueToPixel(f); var E = j[f] ? j[f] : 0; if (a.axisY.logarithmic) { if (o[f] = D.y + (o[f] ? o[f] : 0), 0 >= o[f]) continue; e = a.axisY.convertValueToPixel(o[f]) } else e = a.axisY.convertValueToPixel(D.y), e -= E; if (l.push({ x: d, y: r - E }), j[f] = r - e, t || C ? (!t && v.connectNullData ? (c.setLineDash && (v._options.nullDataLineDashType || z === v.lineDashType && v.lineDashType !== v.nullDataLineDashType) && (c.stroke(), z = v.nullDataLineDashType, c.setLineDash(A)), c.lineTo(d, e), S && s.lineTo(d, e)) : (c.beginPath(), c.moveTo(d, e), S && (s.beginPath(), s.moveTo(d, e))), C = t = !1) : (c.lineTo(d, e), S && s.lineTo(d, e), 0 == p % 250 && (b(), c.moveTo(d, e), S && s.moveTo(d, e), l.push({ x: d, y: r - E }))), p < w.length - 1 && (y !== (w[p].lineColor || x) || z !== (w[p].lineDashType || v.lineDashType)) && (b(), c.beginPath(), c.moveTo(d, e), l.push({ x: d, y: r - E }), y = w[p].lineColor || x, c.strokeStyle = y, c.setLineDash && (w[p].lineDashType ? (z = w[p].lineDashType, c.setLineDash(q(z, v.lineThickness))) : (z = v.lineDashType, c.setLineDash(B)))), 0 <= v.dataPointIndexes[f]) { var F = v.dataPointIds[v.dataPointIndexes[f]]; this._eventManager.objectMap[F] = { id: F, objectType: "dataPoint", dataSeriesIndex: u, dataPointIndex: v.dataPointIndexes[f], x1: d, y1: e } } 0 <= v.dataPointIndexes[f] && 0 !== D.markerSize && (0 < D.markerSize || 0 < v.markerSize) && (f = v.getMarkerProperties(p, d, e, c), h.push(f), markerColor = m(F), S && h.push({ x: d, y: e, ctx: s, type: f.type, size: f.size, color: markerColor, borderColor: markerColor, borderThickness: f.borderThickness })), (D.indexLabel || v.indexLabel || D.indexLabelFormatter || v.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: D, dataSeries: v, point: { x: d, y: e }, direction: 0 > w[p].y === a.axisY.reversed ? 1 : -1, color: g }) } } b(), c.moveTo(d, e), S && s.moveTo(d, e) } delete v.dataPointIndexes } return ja.drawMarkers(h), c.restore(), S && s.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderStackedArea100 = function (a) { function b() { for (0 < v.lineThickness && c.stroke(); 0 < l.length;) { var a = l.pop(); c.lineTo(a.x, a.y), S && s.lineTo(a.x, a.y) } c.closePath(), c.globalAlpha = v.fillOpacity, c.fill(), c.globalAlpha = 1, c.beginPath(), S && (s.closePath(), s.fill(), s.beginPath()), l = [] } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d, e, f, g = null, h = this.plotArea, i = [], j = [], l = [], n = [], o = [], p = 0, r = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), s = this._eventManager.ghostCtx; c.save(), S && s.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), S && (s.beginPath(), s.rect(h.x1, h.y1, h.width, h.height), s.clip()); for (var t = [], h = 0; h < a.dataSeriesIndexes.length; h++) { var u = a.dataSeriesIndexes[h], v = this.data[u], w = v.dataPoints; for (v.dataPointIndexes = [], p = 0; p < w.length; p++)u = w[p].x.getTime ? w[p].x.getTime() : w[p].x, v.dataPointIndexes[u] = p, t[u] || (n.push(u), t[u] = !0); n.sort(k) } for (h = 0; h < a.dataSeriesIndexes.length; h++) { if (u = a.dataSeriesIndexes[h], v = this.data[u], w = v.dataPoints, t = !0, g = v.id, this._eventManager.objectMap[g] = { objectType: "dataSeries", dataSeriesIndex: u }, g = m(g), s.fillStyle = g, l = [], 0 < n.length) { var g = v._colorSet[p % v._colorSet.length], x = v._options.lineColor || g, y = x; c.fillStyle = g, c.strokeStyle = x, c.lineWidth = v.lineThickness; var z = "solid"; if (c.setLineDash) { var A = q(v.nullDataLineDashType, v.lineThickness), z = v.lineDashType, B = q(z, v.lineThickness); c.setLineDash(B) } for (var C = !0, p = 0; p < n.length; p++) { f = n[p]; var D = null, D = 0 <= v.dataPointIndexes[f] ? w[v.dataPointIndexes[f]] : { x: f, y: null }; if (!(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax && (!v.connectNullData || !C))) if ("number" != typeof D.y) v.connectNullData || C || t || b(), C = !0; else { var E; E = 0 !== a.dataPointYSums[f] ? D.y / a.dataPointYSums[f] * 100 : 0, d = a.axisX.convertValueToPixel(f); var F = j[f] ? j[f] : 0; if (a.axisY.logarithmic) { if (o[f] = E + (o[f] ? o[f] : 0), 0 >= o[f]) continue; e = a.axisY.convertValueToPixel(o[f]) } else e = a.axisY.convertValueToPixel(E), e -= F; if (l.push({ x: d, y: r - F }), j[f] = r - e, t || C ? (!t && v.connectNullData ? (c.setLineDash && (v._options.nullDataLineDashType || z === v.lineDashType && v.lineDashType !== v.nullDataLineDashType) && (c.stroke(), z = v.nullDataLineDashType, c.setLineDash(A)), c.lineTo(d, e), S && s.lineTo(d, e)) : (c.beginPath(), c.moveTo(d, e), S && (s.beginPath(), s.moveTo(d, e))), C = t = !1) : (c.lineTo(d, e), S && s.lineTo(d, e), 0 == p % 250 && (b(), c.moveTo(d, e), S && s.moveTo(d, e), l.push({ x: d, y: r - F }))), p < w.length - 1 && (y !== (w[p].lineColor || x) || z !== (w[p].lineDashType || v.lineDashType)) && (b(), c.beginPath(), c.moveTo(d, e), l.push({ x: d, y: r - F }), y = w[p].lineColor || x, c.strokeStyle = y, c.setLineDash && (w[p].lineDashType ? (z = w[p].lineDashType, c.setLineDash(q(z, v.lineThickness))) : (z = v.lineDashType, c.setLineDash(B)))), 0 <= v.dataPointIndexes[f]) { var G = v.dataPointIds[v.dataPointIndexes[f]]; this._eventManager.objectMap[G] = { id: G, objectType: "dataPoint", dataSeriesIndex: u, dataPointIndex: v.dataPointIndexes[f], x1: d, y1: e } } 0 <= v.dataPointIndexes[f] && 0 !== D.markerSize && (0 < D.markerSize || 0 < v.markerSize) && (f = v.getMarkerProperties(p, d, e, c), i.push(f), markerColor = m(G), S && i.push({ x: d, y: e, ctx: s, type: f.type, size: f.size, color: markerColor, borderColor: markerColor, borderThickness: f.borderThickness })), (D.indexLabel || v.indexLabel || D.indexLabelFormatter || v.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea100", dataPoint: D, dataSeries: v, point: { x: d, y: e }, direction: 0 > w[p].y === a.axisY.reversed ? 1 : -1, color: g }) } } b(), c.moveTo(d, e), S && s.moveTo(d, e) } delete v.dataPointIndexes } return ja.drawMarkers(i), c.restore(), S && s.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderBubble = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d, e = this.plotArea, f = 0; b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(e.x1, e.y1, e.width, e.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var g = -1 / 0, h = 1 / 0, i = 0; i < a.dataSeriesIndexes.length; i++)for (var j = a.dataSeriesIndexes[i], k = this.data[j], l = k.dataPoints, n = 0, f = 0; f < l.length; f++)(c = c = l[f].getTime ? l[f].x.getTime() : l[f].x) < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax || void 0 === l[f].z || (n = l[f].z, n > g && (g = n), n < h && (h = n)); for (var o = 25 * Math.PI, e = Math.max(Math.pow(.25 * Math.min(e.height, e.width) / 2, 2) * Math.PI, o), i = 0; i < a.dataSeriesIndexes.length; i++)if (j = a.dataSeriesIndexes[i], k = this.data[j], l = k.dataPoints, 0 < l.length) for (b.strokeStyle = "#4572A7 ", f = 0; f < l.length; f++)if (!((c = c = l[f].getTime ? l[f].x.getTime() : l[f].x) < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" == typeof l[f].y) { c = a.axisX.convertValueToPixel(c), d = a.axisY.convertValueToPixel(l[f].y); var n = l[f].z, p = 2 * Math.max(Math.sqrt((g === h ? e / 2 : o + (e - o) / (g - h) * (n - h)) / Math.PI) << 0, 1), n = k.getMarkerProperties(f, b); n.size = p, b.globalAlpha = k.fillOpacity, ja.drawMarker(c, d, b, n.type, n.size, n.color, n.borderColor, n.borderThickness), b.globalAlpha = 1; var q = k.dataPointIds[f]; this._eventManager.objectMap[q] = { id: q, objectType: "dataPoint", dataSeriesIndex: j, dataPointIndex: f, x1: c, y1: d, size: p }, p = m(q), S && ja.drawMarker(c, d, this._eventManager.ghostCtx, n.type, n.size, p, p, n.borderThickness), (l[f].indexLabel || k.indexLabel || l[f].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "bubble", dataPoint: l[f], dataSeries: k, point: { x: c, y: d }, direction: 1, bounds: { x1: c - n.size / 2, y1: d - n.size / 2, x2: c + n.size / 2, y2: d + n.size / 2 }, color: null }) } return b.restore(), S && this._eventManager.ghostCtx.restore(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.fadeInAnimation, easingFunction: ia.easing.easeInQuad, animationBase: 0 } } }, C.prototype.renderScatter = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d, e = this.plotArea, f = 0; b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(e.x1, e.y1, e.width, e.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var g = 0; g < a.dataSeriesIndexes.length; g++) { var h = a.dataSeriesIndexes[g], i = this.data[h], j = i.dataPoints; if (0 < j.length) { b.strokeStyle = "#4572A7 ", Math.pow(.3 * Math.min(e.height, e.width) / 2, 2); for (var k = 0, l = 0, f = 0; f < j.length; f++)if (!((c = c = j[f].getTime ? j[f].x.getTime() : j[f].x) < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" == typeof j[f].y) { c = a.axisX.convertValueToPixel(c), d = a.axisY.convertValueToPixel(j[f].y); var n = i.getMarkerProperties(f, c, d, b); b.globalAlpha = i.fillOpacity, ja.drawMarker(n.x, n.y, n.ctx, n.type, n.size, n.color, n.borderColor, n.borderThickness), b.globalAlpha = 1, Math.sqrt((k - c) * (k - c) + (l - d) * (l - d)) < Math.min(n.size, 5) && j.length > Math.min(this.plotArea.width, this.plotArea.height) || (k = i.dataPointIds[f], this._eventManager.objectMap[k] = { id: k, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: f, x1: c, y1: d }, k = m(k), S && ja.drawMarker(n.x, n.y, this._eventManager.ghostCtx, n.type, n.size, k, k, n.borderThickness), (j[f].indexLabel || i.indexLabel || j[f].indexLabelFormatter || i.indexLabelFormatter) && this._indexLabels.push({ chartType: "scatter", dataPoint: j[f], dataSeries: i, point: { x: c, y: d }, direction: 1, bounds: { x1: c - n.size / 2, y1: d - n.size / 2, x2: c + n.size / 2, y2: d + n.size / 2 }, color: null }), k = c, l = d) } } } return b.restore(), S && this._eventManager.ghostCtx.restore(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.fadeInAnimation, easingFunction: ia.easing.easeInQuad, animationBase: 0 } } }, C.prototype.renderCandlestick = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx, c = this._eventManager.ghostCtx; if (!(0 >= a.dataSeriesIndexes.length)) { var d, e, f, g, h, i, j = null, j = this.plotArea, k = 0, k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1; d = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .015 * this.width; var l = a.axisX.dataInfo.minDiff; isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : .7 * j.width * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) << 0, this.dataPointMaxWidth && k > d && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, d)), !this.dataPointMaxWidth && this.dataPointMinWidth && d < k && (d = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, k)), l < k && (l = k), l > d && (l = d), b.save(), S && c.save(), b.beginPath(), b.rect(j.x1, j.y1, j.width, j.height), b.clip(), S && (c.beginPath(), c.rect(j.x1, j.y1, j.width, j.height), c.clip()); for (var n = 0; n < a.dataSeriesIndexes.length; n++) { var o = a.dataSeriesIndexes[n], p = this.data[o], q = p.dataPoints; if (0 < q.length) for (var r = !!(5 < l && p.bevelEnabled), k = 0; k < q.length; k++)if (!((i = q[k].getTime ? q[k].x.getTime() : q[k].x) < a.axisX.dataInfo.viewPortMin || i > a.axisX.dataInfo.viewPortMax) && null !== q[k].y && q[k].y.length && "number" == typeof q[k].y[0] && "number" == typeof q[k].y[1] && "number" == typeof q[k].y[2] && "number" == typeof q[k].y[3]) { d = a.axisX.convertValueToPixel(i), e = a.axisY.convertValueToPixel(q[k].y[0]), f = a.axisY.convertValueToPixel(q[k].y[1]), g = a.axisY.convertValueToPixel(q[k].y[2]), h = a.axisY.convertValueToPixel(q[k].y[3]); var s = d - l / 2 << 0, t = s + l << 0, j = q[k].color ? q[k].color : p._colorSet[0], u = Math.round(Math.max(1, .15 * l)), v = 0 == u % 2 ? 0 : .5, w = p.dataPointIds[k]; this._eventManager.objectMap[w] = { id: w, objectType: "dataPoint", dataSeriesIndex: o, dataPointIndex: k, x1: s, y1: e, x2: t, y2: f, x3: d, y3: g, x4: d, y4: h, borderThickness: u, color: j }, b.strokeStyle = j, b.beginPath(), b.lineWidth = u, c.lineWidth = Math.max(u, 4), "candlestick" === p.type ? (b.moveTo(d - v, f), b.lineTo(d - v, Math.min(e, h)), b.stroke(), b.moveTo(d - v, Math.max(e, h)), b.lineTo(d - v, g), b.stroke(), ga(b, s, Math.min(e, h), t, Math.max(e, h), q[k].y[0] <= q[k].y[3] ? p.risingColor : j, u, j, r, r, !1, !1, p.fillOpacity), S && (j = m(w), c.strokeStyle = j, c.moveTo(d - v, f), c.lineTo(d - v, Math.min(e, h)), c.stroke(), c.moveTo(d - v, Math.max(e, h)), c.lineTo(d - v, g), c.stroke(), ga(c, s, Math.min(e, h), t, Math.max(e, h), j, 0, null, !1, !1, !1, !1))) : "ohlc" === p.type && (b.moveTo(d - v, f), b.lineTo(d - v, g), b.stroke(), b.beginPath(), b.moveTo(d, e), b.lineTo(s, e), b.stroke(), b.beginPath(), b.moveTo(d, h), b.lineTo(t, h), b.stroke(), S && (j = m(w), c.strokeStyle = j, c.moveTo(d - v, f), c.lineTo(d - v, g), c.stroke(), c.beginPath(), c.moveTo(d, e), c.lineTo(s, e), c.stroke(), c.beginPath(), c.moveTo(d, h), c.lineTo(t, h), c.stroke())), (q[k].indexLabel || p.indexLabel || q[k].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({ chartType: p.type, dataPoint: q[k], dataSeries: p, point: { x: s + (t - s) / 2, y: a.axisY.reversed ? g : f }, direction: 1, bounds: { x1: s, y1: Math.min(f, g), x2: t, y2: Math.max(f, g) }, color: j }) } } return b.restore(), S && c.restore(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.fadeInAnimation, easingFunction: ia.easing.easeInQuad, animationBase: 0 } } }, C.prototype.renderRangeColumn = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d, e = null, f = this.plotArea, g = 0, g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1; c = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .03 * this.width; var h = a.axisX.dataInfo.minDiff; isFinite(h) || (h = .3 * Math.abs(a.axisX.range)), h = this.dataPointWidth ? this.dataPointWidth : f.width * (a.axisX.logarithmic ? Math.log(h) / Math.log(a.axisX.range) : Math.abs(h) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && g > c && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, c)), !this.dataPointMaxWidth && this.dataPointMinWidth && c < g && (c = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, g)), h < g && (h = g), h > c && (h = c), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(f.x1, f.y1, f.width, f.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(f.x1, f.y1, f.width, f.height), this._eventManager.ghostCtx.clip()); for (var i = 0; i < a.dataSeriesIndexes.length; i++) { var j = a.dataSeriesIndexes[i], k = this.data[j], l = k.dataPoints; if (0 < l.length) for (var n = !!(5 < h && k.bevelEnabled), g = 0; g < l.length; g++)if (!((d = l[g].getTime ? l[g].x.getTime() : l[g].x) < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && null !== l[g].y && l[g].y.length && "number" == typeof l[g].y[0] && "number" == typeof l[g].y[1]) { e = a.axisX.convertValueToPixel(d), f = a.axisY.convertValueToPixel(l[g].y[0]), c = a.axisY.convertValueToPixel(l[g].y[1]); var o = a.axisX.reversed ? e + a.plotType.totalDataSeries * h / 2 - (a.previousDataSeriesCount + i) * h << 0 : e - a.plotType.totalDataSeries * h / 2 + (a.previousDataSeriesCount + i) * h << 0, p = a.axisX.reversed ? o - h << 0 : o + h << 0, e = l[g].color ? l[g].color : k._colorSet[g % k._colorSet.length]; if (f > c) { var q = f, f = c; c = q } q = k.dataPointIds[g], this._eventManager.objectMap[q] = { id: q, objectType: "dataPoint", dataSeriesIndex: j, dataPointIndex: g, x1: o, y1: f, x2: p, y2: c }, ga(b, o, f, p, c, e, 0, e, n, n, !1, !1, k.fillOpacity), e = m(q), S && ga(this._eventManager.ghostCtx, o, f, p, c, e, 0, null, !1, !1, !1, !1), (l[g].indexLabel || k.indexLabel || l[g].indexLabelFormatter || k.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeColumn", dataPoint: l[g], dataSeries: k, indexKeyword: 0, point: { x: o + (p - o) / 2, y: l[g].y[1] >= l[g].y[0] ? c : f }, direction: l[g].y[1] >= l[g].y[0] ? -1 : 1, bounds: { x1: o, y1: Math.min(f, c), x2: p, y2: Math.max(f, c) }, color: e }), this._indexLabels.push({ chartType: "rangeColumn", dataPoint: l[g], dataSeries: k, indexKeyword: 1, point: { x: o + (p - o) / 2, y: l[g].y[1] >= l[g].y[0] ? f : c }, direction: l[g].y[1] >= l[g].y[0] ? 1 : -1, bounds: { x1: o, y1: Math.min(f, c), x2: p, y2: Math.max(f, c) }, color: e })) } } return b.restore(), S && this._eventManager.ghostCtx.restore(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.fadeInAnimation, easingFunction: ia.easing.easeInQuad, animationBase: 0 } } }, C.prototype.renderRangeBar = function (a) { var b = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var c, d, e, f = null, g = this.plotArea, h = 0, h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1; c = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, this.plotArea.height / a.plotType.totalDataSeries * .9) << 0; var i = a.axisX.dataInfo.minDiff; isFinite(i) || (i = .3 * Math.abs(a.axisX.range)), i = this.dataPointWidth ? this.dataPointWidth : g.height * (a.axisX.logarithmic ? Math.log(i) / Math.log(a.axisX.range) : Math.abs(i) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && h > c && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, c)), !this.dataPointMaxWidth && this.dataPointMinWidth && c < h && (c = Math.max(this.dataPointWidth ? this.dataPointWidth : -1 / 0, h)), i < h && (i = h), i > c && (i = c), b.save(), S && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(g.x1, g.y1, g.width, g.height), b.clip(), S && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip()); for (var j = 0; j < a.dataSeriesIndexes.length; j++) { var k = a.dataSeriesIndexes[j], l = this.data[k], n = l.dataPoints; if (0 < n.length) { var o = !!(5 < i && l.bevelEnabled); for (b.strokeStyle = "#4572A7 ", h = 0; h < n.length; h++)if (!((e = n[h].getTime ? n[h].x.getTime() : n[h].x) < a.axisX.dataInfo.viewPortMin || e > a.axisX.dataInfo.viewPortMax) && null !== n[h].y && n[h].y.length && "number" == typeof n[h].y[0] && "number" == typeof n[h].y[1]) { g = a.axisY.convertValueToPixel(n[h].y[0]), c = a.axisY.convertValueToPixel(n[h].y[1]), d = a.axisX.convertValueToPixel(e), d = a.axisX.reversed ? d + a.plotType.totalDataSeries * i / 2 - (a.previousDataSeriesCount + j) * i << 0 : d - a.plotType.totalDataSeries * i / 2 + (a.previousDataSeriesCount + j) * i << 0; var p = a.axisX.reversed ? d - i << 0 : d + i << 0; g > c && (f = g, g = c, c = f), f = n[h].color ? n[h].color : l._colorSet[h % l._colorSet.length], ga(b, g, d, c, p, f, 0, null, o, !1, !1, !1, l.fillOpacity), f = l.dataPointIds[h], this._eventManager.objectMap[f] = { id: f, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: h, x1: g, y1: d, x2: c, y2: p }, f = m(f), S && ga(this._eventManager.ghostCtx, g, d, c, p, f, 0, null, !1, !1, !1, !1), (n[h].indexLabel || l.indexLabel || n[h].indexLabelFormatter || l.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeBar", dataPoint: n[h], dataSeries: l, indexKeyword: 0, point: { x: n[h].y[1] >= n[h].y[0] ? g : c, y: d + (p - d) / 2 }, direction: n[h].y[1] >= n[h].y[0] ? -1 : 1, bounds: { x1: Math.min(g, c), y1: d, x2: Math.max(g, c), y2: p }, color: f }), this._indexLabels.push({ chartType: "rangeBar", dataPoint: n[h], dataSeries: l, indexKeyword: 1, point: { x: n[h].y[1] >= n[h].y[0] ? c : g, y: d + (p - d) / 2 }, direction: n[h].y[1] >= n[h].y[0] ? 1 : -1, bounds: { x1: Math.min(g, c), y1: d, x2: Math.max(g, c), y2: p }, color: f })) } } } return b.restore(), S && this._eventManager.ghostCtx.restore(), { source: b, dest: this.plotArea.ctx, animationCallback: ia.fadeInAnimation, easingFunction: ia.easing.easeInQuad, animationBase: 0 } } }, C.prototype.renderRangeArea = function (a) { function b() { if (s) { var a = null; 0 < i.lineThickness && c.stroke(); for (var b = g.length - 1; 0 <= b; b--)a = g[b], c.lineTo(a.x, a.y), d.lineTo(a.x, a.y); if (c.closePath(), c.globalAlpha = i.fillOpacity, c.fill(), c.globalAlpha = 1, d.fill(), 0 < i.lineThickness) { for (c.beginPath(), c.moveTo(a.x, a.y), b = 0; b < g.length; b++)a = g[b], c.lineTo(a.x, a.y); c.stroke() } c.beginPath(), c.moveTo(k, l), d.beginPath(), d.moveTo(k, l), s = { x: k, y: l }, g = [], g.push({ x: k, y: n }) } } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d = this._eventManager.ghostCtx, e = [], f = this.plotArea; for (c.save(), S && d.save(), c.beginPath(), c.rect(f.x1, f.y1, f.width, f.height), c.clip(), S && (d.beginPath(), d.rect(f.x1, f.y1, f.width, f.height), d.clip()), f = 0; f < a.dataSeriesIndexes.length; f++) { var g = [], h = a.dataSeriesIndexes[f], i = this.data[h], j = i.dataPoints, e = i.id; this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: h }, e = m(e), d.fillStyle = e; var k, l, n, o, e = [], p = !0, r = 0, s = null; if (0 < j.length) { var t = i._colorSet[r % i._colorSet.length], u = i._options.lineColor || t, v = u; c.fillStyle = t, c.strokeStyle = u, c.lineWidth = i.lineThickness; var w = "solid"; if (c.setLineDash) { var x = q(i.nullDataLineDashType, i.lineThickness), w = i.lineDashType, y = q(w, i.lineThickness); c.setLineDash(y) } for (var z = !0; r < j.length; r++)if (!((o = j[r].x.getTime ? j[r].x.getTime() : j[r].x) < a.axisX.dataInfo.viewPortMin || o > a.axisX.dataInfo.viewPortMax && (!i.connectNullData || !z))) if (null !== j[r].y && j[r].y.length && "number" == typeof j[r].y[0] && "number" == typeof j[r].y[1]) { if (k = a.axisX.convertValueToPixel(o), l = a.axisY.convertValueToPixel(j[r].y[0]), n = a.axisY.convertValueToPixel(j[r].y[1]), p || z ? (i.connectNullData && !p ? (c.setLineDash && (i._options.nullDataLineDashType || w === i.lineDashType && i.lineDashType !== i.nullDataLineDashType) && (g[g.length - 1].newLineDashArray = y, w = i.nullDataLineDashType, c.setLineDash(x)), c.lineTo(k, l), S && d.lineTo(k, l), g.push({ x: k, y: n })) : (c.beginPath(), c.moveTo(k, l), s = { x: k, y: l }, g = [], g.push({ x: k, y: n }), S && (d.beginPath(), d.moveTo(k, l))), z = p = !1) : (c.lineTo(k, l), g.push({ x: k, y: n }), S && d.lineTo(k, l), 0 == r % 250 && b()), o = i.dataPointIds[r], this._eventManager.objectMap[o] = { id: o, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: r, x1: k, y1: l, y2: n }, r < j.length - 1 && (v !== (j[r].lineColor || u) || w !== (j[r].lineDashType || i.lineDashType)) && (b(), v = j[r].lineColor || u, g[g.length - 1].newStrokeStyle = v, c.strokeStyle = v, c.setLineDash && (j[r].lineDashType ? (w = j[r].lineDashType, g[g.length - 1].newLineDashArray = q(w, i.lineThickness), c.setLineDash(g[g.length - 1].newLineDashArray)) : (w = i.lineDashType, g[g.length - 1].newLineDashArray = y, c.setLineDash(y)))), 0 !== j[r].markerSize && (0 < j[r].markerSize || 0 < i.markerSize)) { var A = i.getMarkerProperties(r, k, n, c); e.push(A); var B = m(o); S && e.push({ x: k, y: n, ctx: d, type: A.type, size: A.size, color: B, borderColor: B, borderThickness: A.borderThickness }), A = i.getMarkerProperties(r, k, l, c), e.push(A), B = m(o), S && e.push({ x: k, y: l, ctx: d, type: A.type, size: A.size, color: B, borderColor: B, borderThickness: A.borderThickness }) } (j[r].indexLabel || i.indexLabel || j[r].indexLabelFormatter || i.indexLabelFormatter) && (this._indexLabels.push({ chartType: "rangeArea", dataPoint: j[r], dataSeries: i, indexKeyword: 0, point: { x: k, y: l }, direction: j[r].y[0] > j[r].y[1] === a.axisY.reversed ? -1 : 1, color: t }), this._indexLabels.push({ chartType: "rangeArea", dataPoint: j[r], dataSeries: i, indexKeyword: 1, point: { x: k, y: n }, direction: j[r].y[0] > j[r].y[1] === a.axisY.reversed ? 1 : -1, color: t })) } else z || p || b(), z = !0; b(), ja.drawMarkers(e) } } return c.restore(), S && this._eventManager.ghostCtx.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }, C.prototype.renderRangeSplineArea = function (a) { function b(a, b) { var e = D(o, 2); if (0 < e.length) { if (0 < h.lineThickness) { c.strokeStyle = b, c.setLineDash && c.setLineDash(a), c.beginPath(), c.moveTo(e[0].x, e[0].y); for (var f = 0; f < e.length - 3; f += 3)(e[f].newStrokeStyle || e[f].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(e[f].x, e[f].y), e[f].newStrokeStyle && (c.strokeStyle = e[f].newStrokeStyle), e[f].newLineDashArray && c.setLineDash(e[f].newLineDashArray)), c.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y); c.stroke() } for (c.beginPath(), c.moveTo(e[0].x, e[0].y), S && (d.beginPath(), d.moveTo(e[0].x, e[0].y)), f = 0; f < e.length - 3; f += 3)c.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y), S && d.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y); for (e = D(p, 2), c.lineTo(p[p.length - 1].x, p[p.length - 1].y), f = e.length - 1; 2 < f; f -= 3)c.bezierCurveTo(e[f - 1].x, e[f - 1].y, e[f - 2].x, e[f - 2].y, e[f - 3].x, e[f - 3].y), S && d.bezierCurveTo(e[f - 1].x, e[f - 1].y, e[f - 2].x, e[f - 2].y, e[f - 3].x, e[f - 3].y); if (c.closePath(), c.globalAlpha = h.fillOpacity, c.fill(), S && (d.closePath(), d.fill()), c.globalAlpha = 1, 0 < h.lineThickness) { c.strokeStyle = b, c.setLineDash && c.setLineDash(a), c.beginPath(), c.moveTo(e[0].x, e[0].y); for (var g = f = 0; f < e.length - 3; f += 3, g++)(o[g].newStrokeStyle || o[g].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(e[f].x, e[f].y), o[g].newStrokeStyle && (c.strokeStyle = o[g].newStrokeStyle), o[g].newLineDashArray && c.setLineDash(o[g].newLineDashArray)), c.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y); c.stroke() } c.beginPath() } } var c = a.targetCanvasCtx || this.plotArea.ctx; if (!(0 >= a.dataSeriesIndexes.length)) { var d = this._eventManager.ghostCtx, e = [], f = this.plotArea; for (c.save(), S && d.save(), c.beginPath(), c.rect(f.x1, f.y1, f.width, f.height), c.clip(), S && (d.beginPath(), d.rect(f.x1, f.y1, f.width, f.height), d.clip()), f = 0; f < a.dataSeriesIndexes.length; f++) { var g = a.dataSeriesIndexes[f], h = this.data[g], i = h.dataPoints, e = h.id; this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: g }, e = m(e), d.fillStyle = e; var j, k, l, e = [], n = 0, o = [], p = []; if (0 < i.length) { var r = h._colorSet[n % h._colorSet.length], s = h._options.lineColor || r, t = s; c.fillStyle = r, c.lineWidth = h.lineThickness; var u, v = "solid"; if (c.setLineDash) { var w = q(h.nullDataLineDashType, h.lineThickness), v = h.lineDashType; u = q(v, h.lineThickness) } for (k = !1; n < i.length; n++)if (!((j = i[n].x.getTime ? i[n].x.getTime() : i[n].x) < a.axisX.dataInfo.viewPortMin || j > a.axisX.dataInfo.viewPortMax && (!h.connectNullData || !k))) if (null !== i[n].y && i[n].y.length && "number" == typeof i[n].y[0] && "number" == typeof i[n].y[1]) { j = a.axisX.convertValueToPixel(j), k = a.axisY.convertValueToPixel(i[n].y[0]), l = a.axisY.convertValueToPixel(i[n].y[1]); var x = h.dataPointIds[n]; if (this._eventManager.objectMap[x] = { id: x, objectType: "dataPoint", dataSeriesIndex: g, dataPointIndex: n, x1: j, y1: k, y2: l }, o[o.length] = { x: j, y: k }, p[p.length] = { x: j, y: l }, n < i.length - 1 && (t !== (i[n].lineColor || s) || v !== (i[n].lineDashType || h.lineDashType)) && (t = i[n].lineColor || s, o[o.length - 1].newStrokeStyle = t, c.setLineDash && (i[n].lineDashType ? (v = i[n].lineDashType, o[o.length - 1].newLineDashArray = q(v, h.lineThickness)) : (v = h.lineDashType, o[o.length - 1].newLineDashArray = u))), 0 !== i[n].markerSize && (0 < i[n].markerSize || 0 < h.markerSize)) { var y = h.getMarkerProperties(n, j, k, c); e.push(y); var z = m(x); S && e.push({ x: j, y: k, ctx: d, type: y.type, size: y.size, color: z, borderColor: z, borderThickness: y.borderThickness }), y = h.getMarkerProperties(n, j, l, c), e.push(y), z = m(x), S && e.push({ x: j, y: l, ctx: d, type: y.type, size: y.size, color: z, borderColor: z, borderThickness: y.borderThickness }) } (i[n].indexLabel || h.indexLabel || i[n].indexLabelFormatter || h.indexLabelFormatter) && (this._indexLabels.push({ chartType: "splineArea", dataPoint: i[n], dataSeries: h, indexKeyword: 0, point: { x: j, y: k }, direction: i[n].y[0] <= i[n].y[1] ? -1 : 1, color: r }), this._indexLabels.push({ chartType: "splineArea", dataPoint: i[n], dataSeries: h, indexKeyword: 1, point: { x: j, y: l }, direction: i[n].y[0] <= i[n].y[1] ? 1 : -1, color: r })), k = !1 } else 0 < n && !k && (h.connectNullData ? c.setLineDash && 0 < o.length && (h._options.nullDataLineDashType || !i[n - 1].lineDashType) && (o[o.length - 1].newLineDashArray = w, v = h.nullDataLineDashType) : (b(u, s), o = [], p = [])), k = !0; b(u, s), ja.drawMarkers(e) } } return c.restore(), S && this._eventManager.ghostCtx.restore(), { source: c, dest: this.plotArea.ctx, animationCallback: ia.xClipAnimation, easingFunction: ia.easing.linear, animationBase: 0 } } }; var ha = function (a, b, c, d, e, f, g, h, i) { if (!(0 > c)) { if (void 0 === h && (h = 1), !S) { var j = Number((g % (2 * Math.PI)).toFixed(8)); Number((f % (2 * Math.PI)).toFixed(8)) === j && (g -= 1e-4) } a.save(), a.globalAlpha = h, "pie" === e ? (a.beginPath(), a.moveTo(b.x, b.y), a.arc(b.x, b.y, c, f, g, !1), a.fillStyle = d, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === e && (a.beginPath(), a.arc(b.x, b.y, c, f, g, !1), 0 <= i && a.arc(b.x, b.y, i * c, g, f, !0), a.closePath(), a.fillStyle = d, a.strokeStyle = "white", a.lineWidth = 2, a.fill()), a.globalAlpha = 1, a.restore() } }; C.prototype.renderPie = function (a) { function b() { if (k && l) { for (var a = 0, b = 0, c = 0, d = 0, e = 0; e < l.length; e++) { var f = l[e], g = k.dataPointIds[e], h = { id: g, objectType: "dataPoint", dataPointIndex: e, dataSeriesIndex: 0 }; p.push(h); var j = { percent: null, total: null }, m = null, j = i.getPercentAndTotal(k, f); (k.indexLabelFormatter || f.indexLabelFormatter) && (m = { chart: i._options, dataSeries: k, dataPoint: f, total: j.total, percent: j.percent }), j = f.indexLabelFormatter ? f.indexLabelFormatter(m) : f.indexLabel ? i.replaceKeywordsWithValue(f.indexLabel, f, k, e) : k.indexLabelFormatter ? k.indexLabelFormatter(m) : k.indexLabel ? i.replaceKeywordsWithValue(k.indexLabel, f, k, e) : f.label ? f.label : "", i._eventManager.objectMap[g] = h, h.center = { x: v.x, y: v.y }, h.y = f.y, h.radius = y, h.percentInnerRadius = A, h.indexLabelText = j, h.indexLabelPlacement = k.indexLabelPlacement, h.indexLabelLineColor = f.indexLabelLineColor ? f.indexLabelLineColor : k.indexLabelLineColor ? k.indexLabelLineColor : f.color ? f.color : k._colorSet[e % k._colorSet.length], h.indexLabelLineThickness = o(f.indexLabelLineThickness) ? k.indexLabelLineThickness : f.indexLabelLineThickness, h.indexLabelLineDashType = f.indexLabelLineDashType ? f.indexLabelLineDashType : k.indexLabelLineDashType, h.indexLabelFontColor = f.indexLabelFontColor ? f.indexLabelFontColor : k.indexLabelFontColor, h.indexLabelFontStyle = f.indexLabelFontStyle ? f.indexLabelFontStyle : k.indexLabelFontStyle, h.indexLabelFontWeight = f.indexLabelFontWeight ? f.indexLabelFontWeight : k.indexLabelFontWeight, h.indexLabelFontSize = f.indexLabelFontSize ? f.indexLabelFontSize : k.indexLabelFontSize, h.indexLabelFontFamily = f.indexLabelFontFamily ? f.indexLabelFontFamily : k.indexLabelFontFamily, h.indexLabelBackgroundColor = f.indexLabelBackgroundColor ? f.indexLabelBackgroundColor : k.indexLabelBackgroundColor ? k.indexLabelBackgroundColor : null, h.indexLabelMaxWidth = f.indexLabelMaxWidth ? f.indexLabelMaxWidth : k.indexLabelMaxWidth ? k.indexLabelMaxWidth : .33 * n.width, h.indexLabelWrap = void 0 !== f.indexLabelWrap ? f.indexLabelWrap : k.indexLabelWrap, h.startAngle = 0 === e ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : p[e - 1].endAngle, h.startAngle = (h.startAngle + 2 * Math.PI) % (2 * Math.PI), h.endAngle = h.startAngle + 2 * Math.PI / w * Math.abs(f.y), f = (h.endAngle + h.startAngle) / 2, f = (f + 2 * Math.PI) % (2 * Math.PI), h.midAngle = f, h.midAngle > Math.PI / 2 - t && h.midAngle < Math.PI / 2 + t ? ((0 === a || p[c].midAngle > h.midAngle) && (c = e), a++) : h.midAngle > 3 * Math.PI / 2 - t && h.midAngle < 3 * Math.PI / 2 + t && ((0 === b || p[d].midAngle > h.midAngle) && (d = e), b++), h.hemisphere = f > Math.PI / 2 && f <= 3 * Math.PI / 2 ? "left" : "right", h.indexLabelTextBlock = new G(i.plotArea.ctx, { fontSize: h.indexLabelFontSize, fontFamily: h.indexLabelFontFamily, fontColor: h.indexLabelFontColor, fontStyle: h.indexLabelFontStyle, fontWeight: h.indexLabelFontWeight, horizontalAlign: "left", backgroundColor: h.indexLabelBackgroundColor, maxWidth: h.indexLabelMaxWidth, maxHeight: h.indexLabelWrap ? 5 * h.indexLabelFontSize : 1.5 * h.indexLabelFontSize, text: h.indexLabelText, padding: 0, textBaseline: "top" }), h.indexLabelTextBlock.measureText() } for (g = f = 0, j = !1, e = 0; e < l.length; e++)h = p[(c + e) % l.length], 1 < a && h.midAngle > Math.PI / 2 - t && h.midAngle < Math.PI / 2 + t && (f <= a / 2 && !j ? (h.hemisphere = "right", f++) : (h.hemisphere = "left", j = !0)); for (j = !1, e = 0; e < l.length; e++)h = p[(d + e) % l.length], 1 < b && h.midAngle > 3 * Math.PI / 2 - t && h.midAngle < 3 * Math.PI / 2 + t && (g <= b / 2 && !j ? (h.hemisphere = "left", g++) : (h.hemisphere = "right", j = !0)) } } function c(a) { var b = i.plotArea.ctx; for (b.clearRect(n.x1, n.y1, n.width, n.height), b.fillStyle = i.backgroundColor, b.fillRect(n.x1, n.y1, n.width, n.height), b = 0; b < l.length; b++) { var c = p[b].startAngle, d = p[b].endAngle; if (d > c) { var e = .07 * y * Math.cos(p[b].midAngle), f = .07 * y * Math.sin(p[b].midAngle), g = !1; l[b].exploded ? (1e-9 < Math.abs(p[b].center.x - (v.x + e)) || 1e-9 < Math.abs(p[b].center.y - (v.y + f))) && (p[b].center.x = v.x + e * a, p[b].center.y = v.y + f * a, g = !0) : (0 < Math.abs(p[b].center.x - v.x) || 0 < Math.abs(p[b].center.y - v.y)) && (p[b].center.x = v.x + e * (1 - a), p[b].center.y = v.y + f * (1 - a), g = !0), g && (e = {}, e.dataSeries = k, e.dataPoint = k.dataPoints[b], e.index = b, i._toolTip.highlightObjects([e])), ha(i.plotArea.ctx, p[b].center, p[b].radius, l[b].color ? l[b].color : k._colorSet[b % k._colorSet.length], k.type, c, d, k.fillOpacity, p[b].percentInnerRadius) } } for (a = i.plotArea.ctx, a.save(), a.fillStyle = "black", a.strokeStyle = "grey", a.textBaseline = "middle", a.lineJoin = "round", b = b = 0; b < l.length; b++)c = p[b], c.indexLabelText && (c.indexLabelTextBlock.y -= c.indexLabelTextBlock.height / 2, d = 0, d = "left" === c.hemisphere ? "inside" !== k.indexLabelPlacement ? -(c.indexLabelTextBlock.width + m) : -c.indexLabelTextBlock.width / 2 : "inside" !== k.indexLabelPlacement ? m : -c.indexLabelTextBlock.width / 2, c.indexLabelTextBlock.x += d, c.indexLabelTextBlock.render(!0), c.indexLabelTextBlock.x -= d, c.indexLabelTextBlock.y += c.indexLabelTextBlock.height / 2, "inside" !== c.indexLabelPlacement && 0 < c.indexLabelLineThickness && (d = c.center.x + y * Math.cos(c.midAngle), e = c.center.y + y * Math.sin(c.midAngle), a.strokeStyle = c.indexLabelLineColor, a.lineWidth = c.indexLabelLineThickness, a.setLineDash && a.setLineDash(q(c.indexLabelLineDashType, c.indexLabelLineThickness)), a.beginPath(), a.moveTo(d, e), a.lineTo(c.indexLabelTextBlock.x, c.indexLabelTextBlock.y), a.lineTo(c.indexLabelTextBlock.x + ("left" === c.hemisphere ? -m : m), c.indexLabelTextBlock.y), a.stroke()), a.lineJoin = "miter"); a.save() } function d(a, b) { var c = 0, c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2, d = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2, e = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2, f = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2; return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? e - d : c - f } function e(a) { for (var b = null, c = 1; c < l.length; c++) { if (b = (a + c + p.length) % p.length, p[b].hemisphere !== p[a].hemisphere) { b = null; break } if (p[b].indexLabelText && b !== a && (0 > d(p[b], p[a]) || ("right" === p[a].hemisphere ? p[b].indexLabelTextBlock.y >= p[a].indexLabelTextBlock.y : p[b].indexLabelTextBlock.y <= p[a].indexLabelTextBlock.y))) break; b = null } return b } function f(a, b, c) { if (1e3 < (c = (c || 0) + 1)) return 0; b = b || 0; var g = 0, h = v.y - 1 * j, i = v.y + 1 * j; if (0 <= a && a < l.length) { var k = p[a]; if (0 > b && k.indexLabelTextBlock.y < h || 0 < b && k.indexLabelTextBlock.y > i) return 0; var m = 0, n = 0, n = m = m = 0; for (0 > b ? k.indexLabelTextBlock.y - k.indexLabelTextBlock.height / 2 > h && k.indexLabelTextBlock.y - k.indexLabelTextBlock.height / 2 + b < h && (b = -(h - (k.indexLabelTextBlock.y - k.indexLabelTextBlock.height / 2 + b))) : k.indexLabelTextBlock.y + k.indexLabelTextBlock.height / 2 < h && k.indexLabelTextBlock.y + k.indexLabelTextBlock.height / 2 + b > i && (b = k.indexLabelTextBlock.y + k.indexLabelTextBlock.height / 2 + b - i), b = k.indexLabelTextBlock.y + b, h = 0, h = "right" === k.hemisphere ? v.x + Math.sqrt(Math.pow(j, 2) - Math.pow(b - v.y, 2)) : v.x - Math.sqrt(Math.pow(j, 2) - Math.pow(b - v.y, 2)), n = v.x + y * Math.cos(k.midAngle), m = v.y + y * Math.sin(k.midAngle), m = Math.sqrt(Math.pow(h - n, 2) + Math.pow(b - m, 2)), n = Math.acos(y / j), m = Math.acos((j * j + y * y - m * m) / (2 * y * j)), b = m < n ? b - k.indexLabelTextBlock.y : 0, h = null, i = 1; i < l.length; i++) { if (h = (a - i + p.length) % p.length, p[h].hemisphere !== p[a].hemisphere) { h = null; break } if (p[h].indexLabelText && p[h].hemisphere === p[a].hemisphere && h !== a && (0 > d(p[h], p[a]) || ("right" === p[a].hemisphere ? p[h].indexLabelTextBlock.y <= p[a].indexLabelTextBlock.y : p[h].indexLabelTextBlock.y >= p[a].indexLabelTextBlock.y))) break; h = null } n = h, m = e(a), i = h = 0, 0 > b ? (i = "right" === k.hemisphere ? n : m, g = b, null !== i && (n = -b, (b = k.indexLabelTextBlock.y - k.indexLabelTextBlock.height / 2 - (p[i].indexLabelTextBlock.y + p[i].indexLabelTextBlock.height / 2)) - n < r && (h = -n, i = f(i, h, c + 1), +i.toFixed(u) > +h.toFixed(u) && (g = b > r ? -(b - r) : -(n - (i - h)))))) : 0 < b && (i = "right" === k.hemisphere ? m : n, g = b, null !== i && (n = b, (b = p[i].indexLabelTextBlock.y - p[i].indexLabelTextBlock.height / 2 - (k.indexLabelTextBlock.y + k.indexLabelTextBlock.height / 2)) - n < r && (h = n, i = f(i, h, c + 1), +i.toFixed(u) < +h.toFixed(u) && (g = b > r ? b - r : n - (h - i))))), g && (c = k.indexLabelTextBlock.y + g, b = 0, b = "right" === k.hemisphere ? v.x + Math.sqrt(Math.pow(j, 2) - Math.pow(c - v.y, 2)) : v.x - Math.sqrt(Math.pow(j, 2) - Math.pow(c - v.y, 2)), k.midAngle > Math.PI / 2 - t && k.midAngle < Math.PI / 2 + t ? (h = (a - 1 + p.length) % p.length, h = p[h], a = p[(a + 1 + p.length) % p.length], "left" === k.hemisphere && "right" === h.hemisphere && b > h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x - 15 : "right" === k.hemisphere && "left" === a.hemisphere && b < a.indexLabelTextBlock.x && (b = a.indexLabelTextBlock.x + 15)) : k.midAngle > 3 * Math.PI / 2 - t && k.midAngle < 3 * Math.PI / 2 + t && (h = (a - 1 + p.length) % p.length, h = p[h], a = p[(a + 1 + p.length) % p.length], "right" === k.hemisphere && "left" === h.hemisphere && b < h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x + 15 : "left" === k.hemisphere && "right" === a.hemisphere && b > a.indexLabelTextBlock.x && (b = a.indexLabelTextBlock.x - 15)), k.indexLabelTextBlock.y = c, k.indexLabelTextBlock.x = b, k.indexLabelAngle = Math.atan2(k.indexLabelTextBlock.y - v.y, k.indexLabelTextBlock.x - v.x)) } return g } function g() { var a = i.plotArea.ctx; a.fillStyle = "grey", a.strokeStyle = "grey", a.font = "16px Arial", a.textBaseline = "middle"; for (var b = a = 0, c = 0, g = !0, b = 0; 10 > b && (1 > b || 0 < c); b++) { if ((k.radius || !k.radius && void 0 !== k.innerRadius && null !== k.innerRadius && y - c <= z) && (g = !1), g && (y -= c), c = 0, "inside" !== k.indexLabelPlacement) { for (j = y * s, a = 0; a < l.length; a++) { var h = p[a]; h.indexLabelTextBlock.x = v.x + j * Math.cos(h.midAngle), h.indexLabelTextBlock.y = v.y + j * Math.sin(h.midAngle), h.indexLabelAngle = h.midAngle, h.radius = y, h.percentInnerRadius = A } for (var o, q, a = 0; a < l.length; a++) { var h = p[a], t = e(a); if (null !== t) { o = p[a], q = p[t]; var w = 0, w = d(o, q) - r; if (0 > w) { for (var x = q = 0, B = 0; B < l.length; B++)B !== a && p[B].hemisphere === h.hemisphere && (p[B].indexLabelTextBlock.y < h.indexLabelTextBlock.y ? q++ : x++); q = w / (q + x || 1) * x; var x = -1 * (w - q), C = B = 0; "right" === h.hemisphere ? (B = f(a, q), x = -1 * (w - B), C = f(t, x), +C.toFixed(u) < +x.toFixed(u) && +B.toFixed(u) <= +q.toFixed(u) && f(a, -(x - C))) : (B = f(t, q), x = -1 * (w - B), C = f(a, x), +C.toFixed(u) < +x.toFixed(u) && +B.toFixed(u) <= +q.toFixed(u) && f(t, -(x - C))) } } } } else for (a = 0; a < l.length; a++)h = p[a], j = "pie" === k.type ? .7 * y : .8 * y, t = v.x + j * Math.cos(h.midAngle), q = v.y + j * Math.sin(h.midAngle), h.indexLabelTextBlock.x = t, h.indexLabelTextBlock.y = q; for (a = 0; a < l.length; a++)h = p[a], t = h.indexLabelTextBlock.measureText(), 0 !== t.height && 0 !== t.width && (t = t = 0, "right" === h.hemisphere ? (t = n.x2 - (h.indexLabelTextBlock.x + h.indexLabelTextBlock.width + m), t *= -1) : t = n.x1 - (h.indexLabelTextBlock.x - h.indexLabelTextBlock.width - m), 0 < t && (!g && h.indexLabelText && (q = "right" === h.hemisphere ? n.x2 - h.indexLabelTextBlock.x : h.indexLabelTextBlock.x - n.x1, .3 * h.indexLabelTextBlock.maxWidth > q ? h.indexLabelText = "" : h.indexLabelTextBlock.maxWidth = .85 * q, .3 * h.indexLabelTextBlock.maxWidth < q && (h.indexLabelTextBlock.x -= "right" === h.hemisphere ? 2 : -2)), Math.abs(h.indexLabelTextBlock.y - h.indexLabelTextBlock.height / 2 - v.y) < y || Math.abs(h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2 - v.y) < y) && (t /= Math.abs(Math.cos(h.indexLabelAngle)), 9 < t && (t *= .3), t > c && (c = t)), t = t = 0, 0 < h.indexLabelAngle && h.indexLabelAngle < Math.PI ? (t = n.y2 - (h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2 + 5), t *= -1) : t = n.y1 - (h.indexLabelTextBlock.y - h.indexLabelTextBlock.height / 2 - 5), 0 < t && (!g && h.indexLabelText && (q = 0 < h.indexLabelAngle && h.indexLabelAngle < Math.PI ? -1 : 1, 0 === f(a, t * q) && f(a, 2 * q)), Math.abs(h.indexLabelTextBlock.x - v.x) < y && (t /= Math.abs(Math.sin(h.indexLabelAngle)), 9 < t && (t *= .3), t > c && (c = t)))); var D = function (a, b, c) { for (var d = [], e = 0; d.push(p[b]), b !== c; b = (b + 1 + l.length) % l.length); for (d.sort(function (a, b) { return a.y - b.y }), b = 0; b < d.length && (c = d[b], e < .7 * a); b++)e += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = "", c.indexLabelText = "", c.indexLabelTextBlock.measureText() }; !function () { for (var a = -1, b = -1, c = 0, f = !1, g = 0; g < l.length; g++)if (f = !1, o = p[g], o.indexLabelText) { var h = e(g); if (null !== h) { var i = p[h]; w = 0, w = d(o, i); var j; if (j = 0 > w) { j = o.indexLabelTextBlock.x; var k = o.indexLabelTextBlock.y - o.indexLabelTextBlock.height / 2, n = o.indexLabelTextBlock.y + o.indexLabelTextBlock.height / 2, q = i.indexLabelTextBlock.y - i.indexLabelTextBlock.height / 2, r = i.indexLabelTextBlock.x + i.indexLabelTextBlock.width, s = i.indexLabelTextBlock.y + i.indexLabelTextBlock.height / 2; j = !(o.indexLabelTextBlock.x + o.indexLabelTextBlock.width < i.indexLabelTextBlock.x - m || j > r + m || k > s + m || n < q - m) } j ? (0 > a && (a = g), h !== a && (b = h, c += -w), 0 == g % Math.max(l.length / 10, 3) && (f = !0)) : f = !0, f && 0 < c && 0 <= a && 0 <= b && (D(c, a, b), b = a = -1, c = 0) } } 0 < c && D(c, a, b) }() } } function h() { if (i.plotArea.layoutManager.reset(), i._title && (i._title.dockInsidePlotArea || "center" === i._title.horizontalAlign && "center" === i._title.verticalAlign) && i._title.render(), i.subtitles) for (var a = 0; a < i.subtitles.length; a++) { var b = i.subtitles[a]; (b.dockInsidePlotArea || "center" === b.horizontalAlign && "center" === b.verticalAlign) && b.render() } i.legend && (i.legend.dockInsidePlotArea || "center" === i.legend.horizontalAlign && "center" === i.legend.verticalAlign) && i.legend.render() } var i = this; if (!(0 >= a.dataSeriesIndexes.length)) { var j, k = this.data[a.dataSeriesIndexes[0]], l = k.dataPoints, m = 10, n = this.plotArea, p = [], r = 2, s = 1.3, t = 20 / 180 * Math.PI, u = 6, v = { x: (n.x2 + n.x1) / 2, y: (n.y2 + n.y1) / 2 }, w = 0; a = !1; for (var x = 0; x < l.length; x++)w += Math.abs(l[x].y), !a && void 0 !== l[x].indexLabel && null !== l[x].indexLabel && 0 < l[x].indexLabel.toString().length && (a = !0), !a && void 0 !== l[x].label && null !== l[x].label && 0 < l[x].label.toString().length && (a = !0); if (0 !== w) { a = a || void 0 !== k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length; var y = "inside" !== k.indexLabelPlacement && a ? .75 * Math.min(n.width, n.height) / 2 : .92 * Math.min(n.width, n.height) / 2; k.radius && (y = E(k.radius, y)); var z = void 0 !== k.innerRadius && null !== k.innerRadius ? E(k.innerRadius, y) : .7 * y, A = Math.min(z / y, (y - 1) / y); this.pieDoughnutClickHandler = function (a) { i.isAnimating || !o(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = !a.exploded, 1 < this.dataPoints.length && i._animator.animate(0, 500, function (a) { c(a), h() })) }, b(), g(), g(), g(), g(), this.disableToolTip = !0, this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) { var b = i.plotArea.ctx; for (b.clearRect(n.x1, n.y1, n.width, n.height), b.fillStyle = i.backgroundColor, b.fillRect(n.x1, n.y1, n.width, n.height), a = p[0].startAngle + 2 * Math.PI * a, b = 0; b < l.length; b++) { var c = 0 === b ? p[b].startAngle : d, d = c + (p[b].endAngle - p[b].startAngle), e = !1; d > a && (d = a, e = !0); var f = l[b].color ? l[b].color : k._colorSet[b % k._colorSet.length]; if (d > c && ha(i.plotArea.ctx, p[b].center, p[b].radius, f, k.type, c, d, k.fillOpacity, p[b].percentInnerRadius), e) break } h() }, function () { i.disableToolTip = !1, i._animator.animate(0, i.animatedRender ? 500 : 0, function (a) { c(a), h() }) }) } } }, C.prototype.animationRequestId = null, C.prototype.requestAnimFrame = function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) { window.setTimeout(a, 1e3 / 60) } }(), C.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout, F.prototype.registerSpace = function (a, b) { "top" === a ? this._topOccupied += b.height : "bottom" === a ? this._bottomOccupied += b.height : "left" === a ? this._leftOccupied += b.width : "right" === a && (this._rightOccupied += b.width) }, F.prototype.unRegisterSpace = function (a, b) { "top" === a ? this._topOccupied -= b.height : "bottom" === a ? this._bottomOccupied -= b.height : "left" === a ? this._leftOccupied -= b.width : "right" === a && (this._rightOccupied -= b.width) }, F.prototype.getFreeSpace = function () { return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied } }, F.prototype.reset = function () { this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding }, a(G, B), G.prototype.render = function (a) { a && this.ctx.save(); var b = this.ctx.font; this.ctx.textBaseline = this.textBaseline; var c = 0; this._isDirty && this.measureText(this.ctx), this.ctx.translate(this.x, this.y + c), "middle" === this.textBaseline && (c = -this._lineHeight / 2), this.ctx.font = this._getFontString(), this.ctx.rotate(Math.PI / 180 * this.angle); var d = 0, e = this.padding, f = null; for ((0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, c, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor), this.ctx.fillStyle = this.fontColor, c = 0; c < this._wrappedText.lines.length; c++)f = this._wrappedText.lines[c], "right" === this.horizontalAlign ? d = this.width - f.width - this.padding : "left" === this.horizontalAlign ? d = this.padding : "center" === this.horizontalAlign && (d = (this.width - 2 * this.padding) / 2 - f.width / 2 + this.padding), this.ctx.fillText(f.text, d, e), e += f.height; this.ctx.font = b, a && this.ctx.restore() }, G.prototype.setText = function (a) { this.text = a, this._isDirty = !0, this._wrappedText = null }, G.prototype.measureText = function () { if (this._lineHeight = p(this.fontFamily, this.fontSize, this.fontWeight), null === this.maxWidth) throw "Please set maxWidth and height for TextBlock"; return this._wrapText(this.ctx), this._isDirty = !1, { width: this.width, height: this.height } }, G.prototype._getLineWithWidth = function (a, b, c) { if (!(a = String(a))) return { text: "", width: 0 }; var d = c = 0, e = a.length - 1, f = 1 / 0; for (this.ctx.font = this._getFontString(); d <= e;) { var f = Math.floor((d + e) / 2), g = a.substr(0, f + 1); if ((c = this.ctx.measureText(g).width) < b) d = f + 1; else { if (!(c > b)) break; e = f - 1 } } return c > b && 1 < g.length && (g = g.substr(0, g.length - 1), c = this.ctx.measureText(g).width), b = !0, g.length !== a.length && " " !== a[g.length] || (b = !1), b && (a = g.split(" "), 1 < a.length && a.pop(), g = a.join(" "), c = this.ctx.measureText(g).width), { text: g, width: c } }, G.prototype._wrapText = function () { var a = new String(g(String(this.text))), b = [], c = this.ctx.font, d = 0, e = 0; for (this.ctx.font = this._getFontString(); 0 < a.length;) { var f = this.maxHeight - 2 * this.padding, h = this._getLineWithWidth(a, this.maxWidth - 2 * this.padding, !1); h.height = this._lineHeight, b.push(h); var i = e, e = Math.max(e, h.width), d = d + h.height, a = g(a.slice(h.text.length, a.length)); f && d > f && (h = b.pop(), d -= h.height, e = i) } this._wrappedText = { lines: b, width: e, height: d }, this.width = e + 2 * this.padding, this.height = d + 2 * this.padding, this.ctx.font = c }, G.prototype._getFontString = function () { var a; a = this.fontStyle ? this.fontStyle + " " : "", a += this.fontWeight ? this.fontWeight + " " : "", a += this.fontSize ? this.fontSize + "px " : ""; var b = this.fontFamily ? this.fontFamily + "" : ""; return !S && b && (b = b.split(",")[0], "'" !== b[0] && '"' !== b[0] && (b = "'" + b + "'")), a += b }, a(H, B), H.prototype.render = function () { if (this.text) { var a, b, c = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, d = c.layoutManager.getFreeSpace(), e = d.x1, f = d.y1, g = 0, h = 0, i = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0; "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = d.width - 4 - i * ("center" === this.horizontalAlign ? 2 : 1)), h = .5 * d.height - this.margin - 2, g = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = d.height - 4), h = .5 * d.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = d.width - 4), h = .5 * d.height - 4)), this.wrap || (h = Math.min(h, Math.max(1.5 * this.fontSize, this.fontSize + 2.5 * this.padding))); var h = new G(this.ctx, { fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor, fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness, backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: h, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: "top" }), j = h.measureText(); "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (f = d.y1 + 2, b = "top") : "bottom" === this.verticalAlign && (f = d.y2 - 2 - j.height, b = "bottom"), "left" === this.horizontalAlign ? e = d.x1 + 2 : "center" === this.horizontalAlign ? e = d.x1 + d.width / 2 - j.width / 2 : "right" === this.horizontalAlign && (e = d.x2 - 2 - j.width - i), a = this.horizontalAlign, this.width = j.width, this.height = j.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (e = d.x1 + 2, f = d.y2 - 2 - (this.maxWidth / 2 - j.width / 2), g = -90, b = "left", this.width = j.height, this.height = j.width) : "right" === this.horizontalAlign ? (e = d.x2 - 2, f = d.y1 + 2 + (this.maxWidth / 2 - j.width / 2), g = 90, b = "right", this.width = j.height, this.height = j.width) : "center" === this.horizontalAlign && (f = c.y1 + (c.height / 2 - j.height / 2), e = c.x1 + (c.width / 2 - j.width / 2), b = "center", this.width = j.width, this.height = j.height), a = "center"), h.x = e, h.y = f, h.angle = g, h.horizontalAlign = a, h.render(!0), c.layoutManager.registerSpace(b, { width: this.width + ("left" === b || "right" === b ? this.margin + 2 : 0), height: this.height + ("top" === b || "bottom" === b ? this.margin + 2 : 0) }), this.bounds = { x1: e, y1: f, x2: e + this.width, y2: f + this.height }, this.ctx.textBaseline = "top" } }, a(I, B), I.prototype.render = H.prototype.render, a(J, B), J.prototype.render = function () { var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, b = a.layoutManager.getFreeSpace(), c = null, d = 0, e = 0, f = 0, g = 0, h = this.chart._options.legend && !o(this.chart._options.legend.markerMargin) ? this.chart._options.legend.markerMargin : .3 * this.fontSize; this.height = 0; var i = [], j = []; "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", c = this.verticalAlign, f = null !== this.maxWidth ? this.maxWidth : b.width, g = null !== this.maxHeight ? this.maxHeight : .5 * b.height) : "center" === this.verticalAlign && (this.orientation = "vertical", c = this.horizontalAlign, f = null !== this.maxWidth ? this.maxWidth : .5 * b.width, g = null !== this.maxHeight ? this.maxHeight : b.height); for (var k = 0; k < this.dataSeries.length; k++) { var l = this.dataSeries[k]; if ("pie" !== l.type && "doughnut" !== l.type && "funnel" !== l.type) { var n = l.legendMarkerType ? l.legendMarkerType : "line" !== l.type && "stepLine" !== l.type && "spline" !== l.type && "scatter" !== l.type && "bubble" !== l.type || !l.markerType ? L.getDefaultLegendMarker(l.type) : l.markerType, p = l.legendText ? l.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart._publicChartReference, legend: this._options, dataSeries: l, dataPoint: null }) : l.name, q = l.legendMarkerColor ? l.legendMarkerColor : l.markerColor ? l.markerColor : l._colorSet[0], r = l.markerSize || "line" !== l.type && "stepLine" !== l.type && "spline" !== l.type ? .75 * this.lineHeight : 0, s = l.legendMarkerBorderColor ? l.legendMarkerBorderColor : l.markerBorderColor, t = l.legendMarkerBorderThickness ? l.legendMarkerBorderThickness : l.markerBorderThickness ? Math.max(1, Math.round(.2 * r)) : 0, p = this.chart.replaceKeywordsWithValue(p, l.dataPoints[0], l, k), n = { markerType: n, markerColor: q, text: p, textBlock: null, chartType: l.type, markerSize: r, lineColor: l._colorSet[0], dataSeriesIndex: l.index, dataPointIndex: null, markerBorderColor: s, markerBorderThickness: t }; i.push(n) } else for (var u = 0; u < l.dataPoints.length; u++) { var v = l.dataPoints[u], n = v.legendMarkerType ? v.legendMarkerType : l.legendMarkerType ? l.legendMarkerType : L.getDefaultLegendMarker(l.type), p = v.legendText ? v.legendText : l.legendText ? l.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart._publicChartReference, legend: this._options, dataSeries: l, dataPoint: v }) : v.name ? v.name : "DataPoint: " + (u + 1), q = v.legendMarkerColor ? v.legendMarkerColor : l.legendMarkerColor ? l.legendMarkerColor : v.color ? v.color : l.color ? l.color : l._colorSet[u % l._colorSet.length], r = .75 * this.lineHeight, s = v.legendMarkerBorderColor ? v.legendMarkerBorderColor : l.legendMarkerBorderColor ? l.legendMarkerBorderColor : v.markerBorderColor ? v.markerBorderColor : l.markerBorderColor, t = v.legendMarkerBorderThickness ? v.legendMarkerBorderThickness : l.legendMarkerBorderThickness ? l.legendMarkerBorderThickness : v.markerBorderThickness || l.markerBorderThickness ? Math.max(1, Math.round(.2 * r)) : 0, p = this.chart.replaceKeywordsWithValue(p, v, l, u), n = { markerType: n, markerColor: q, text: p, textBlock: null, chartType: l.type, markerSize: r, dataSeriesIndex: k, dataPointIndex: u, markerBorderColor: s, markerBorderThickness: t }; (v.showInLegend || l.showInLegend && !1 !== v.showInLegend) && i.push(n) } } if (!0 === this.reversed && i.reverse(), 0 < i.length) { for (l = null, u = p = v = 0, p = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, f) : Math.min(this.itemWidth, f) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, f) : f, r = 0 === r ? .75 * this.lineHeight : r, p -= r + h, k = 0; k < i.length; k++)n = i[k], "line" !== n.chartType && "spline" !== n.chartType && "stepLine" !== n.chartType || (p -= .2 * this.lineHeight), 0 >= g || void 0 === g || 0 >= p || void 0 === p || ("horizontal" === this.orientation ? (n.textBlock = new G(this.ctx, { x: 0, y: 0, maxWidth: p, maxHeight: this.itemWrap ? g : this.lineHeight, angle: 0, text: n.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }), n.textBlock.measureText(), null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (r + h + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? .2 * this.lineHeight : 0))), (!l || l.width + Math.round(n.textBlock.width + r + h + (0 === l.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? .2 * this.lineHeight : 0)) > f) && (l = { items: [], width: 0 }, j.push(l), this.height += u, u = 0), u = Math.max(u, n.textBlock.height)) : (n.textBlock = new G(this.ctx, { x: 0, y: 0, maxWidth: p, maxHeight: !0 === this.itemWrap ? g : 1.5 * this.fontSize, angle: 0, text: n.text, horizontalAlign: "left", fontSize: this.fontSize, fontFamily: this.fontFamily, fontWeight: this.fontWeight, fontColor: this.fontColor, fontStyle: this.fontStyle, textBaseline: "middle" }), n.textBlock.measureText(), null !== this.itemWidth && (n.textBlock.width = this.itemWidth - (r + h + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? .2 * this.lineHeight : 0))), this.height < g - this.lineHeight ? (l = { items: [], width: 0 }, j.push(l)) : (l = j[v], v = (v + 1) % j.length), this.height += n.textBlock.height), n.textBlock.x = l.width, n.textBlock.y = 0, l.width += Math.round(n.textBlock.width + r + h + (0 === l.width ? 0 : this.horizontalSpacing) + ("line" === n.chartType || "spline" === n.chartType || "stepLine" === n.chartType ? .2 * this.lineHeight : 0)), l.items.push(n), this.width = Math.max(l.width, this.width)); this.height = !1 === this.itemWrap ? j.length * this.lineHeight : this.height + u, this.height = Math.min(g, this.height), this.width = Math.min(f, this.width) } for ("top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? b.x1 : "right" === this.horizontalAlign ? b.x2 - this.width : b.x1 + b.width / 2 - this.width / 2, d = b.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? b.x1 : "right" === this.horizontalAlign ? b.x2 - this.width : b.x1 + b.width / 2 - this.width / 2, d = b.y1 + b.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ? b.x1 : "right" === this.horizontalAlign ? b.x2 - this.width : b.x1 + b.width / 2 - this.width / 2, d = b.y2 - this.height), this.items = i, k = 0; k < this.items.length; k++)n = i[k], n.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[n.id] = { id: n.id, objectType: "legendItem", legendItemIndex: k, dataSeriesIndex: n.dataSeriesIndex, dataPointIndex: n.dataPointIndex }; for (k = b = 0; k < j.length; k++) { for (l = j[k], v = u = 0; v < l.items.length; v++)n = l.items[v], q = n.textBlock.x + e + (0 === v ? .2 * r : this.horizontalSpacing), s = d + b, p = q, this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = .5), this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(e, d, f, Math.max(g - g % this.lineHeight, 0)), this.ctx.clip(), "line" !== n.chartType && "stepLine" !== n.chartType && "spline" !== n.chartType || (this.ctx.strokeStyle = n.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(q - .1 * this.lineHeight, s + this.lineHeight / 2), this.ctx.lineTo(q + .85 * this.lineHeight, s + this.lineHeight / 2), this.ctx.stroke(), p -= .1 * this.lineHeight), ja.drawMarker(q + r / 2, s + this.lineHeight / 2, this.ctx, n.markerType, n.markerSize, n.markerColor, n.markerBorderColor, n.markerBorderThickness), n.textBlock.x = q + h + r, "line" !== n.chartType && "stepLine" !== n.chartType && "spline" !== n.chartType || (n.textBlock.x += .1 * this.lineHeight), n.textBlock.y = Math.round(s + this.lineHeight / 2), n.textBlock.render(!0), this.ctx.restore(), u = 0 < v ? Math.max(u, n.textBlock.height) : n.textBlock.height, this.chart.data[n.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1), q = m(n.id), this.ghostCtx.fillStyle = q, this.ghostCtx.beginPath(), this.ghostCtx.fillRect(p, n.textBlock.y - this.lineHeight / 2, n.textBlock.x + n.textBlock.width - p, n.textBlock.height), n.x1 = this.chart._eventManager.objectMap[n.id].x1 = p, n.y1 = this.chart._eventManager.objectMap[n.id].y1 = n.textBlock.y - this.lineHeight / 2, n.x2 = this.chart._eventManager.objectMap[n.id].x2 = n.textBlock.x + n.textBlock.width, n.y2 = this.chart._eventManager.objectMap[n.id].y2 = n.textBlock.y + n.textBlock.height - this.lineHeight / 2; b += u } 0 < i.length && a.layoutManager.registerSpace(c, { width: this.width + 2 + 2, height: this.height + 5 + 5 }), this.bounds = { x1: e, y1: d, x2: e + this.width, y2: d + this.height } }, a(K, B), K.prototype.render = function () { var a = this.chart.layoutManager.getFreeSpace(); this.ctx.fillStyle = "red", this.ctx.fillRect(a.x1, a.y1, a.x2, a.y2) }, a(L, B), L.prototype.getDefaultAxisPlacement = function () { var a = this.type; return "column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a ? "normal" : "bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a ? "xySwapped" : "pie" === a || "doughnut" === a || "funnel" === a ? "none" : (window.console.log("Unknown Chart Type: " + a), null) }, L.getDefaultLegendMarker = function (a) { return "column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a ? "square" : "line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a || "funnel" === a ? "circle" : "area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a ? "triangle" : (window.console.log("Unknown Chart Type: " + a), null) }, L.prototype.getDataPointAtX = function (a, b) { if (!this.dataPoints || 0 === this.dataPoints.length) return null; var c = { dataPoint: null, distance: 1 / 0, index: NaN }, d = null, e = 0, f = 0, g = 1, h = 1 / 0, i = 0, j = 0, k = 0; for ("none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (k = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), k = 1 < k ? Math.min(Math.max((this.dataPoints.length - 1) / k * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (k = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, k = 0 < k ? Math.min(Math.max((this.dataPoints.length - 1) / k * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0)); ;) { if (0 <= (f = 0 < g ? k + e : k - e) && f < this.dataPoints.length) { var d = this.dataPoints[f], l = this.axisX.logarithmic ? d.x > a ? d.x / a : a / d.x : Math.abs(d.x - a); if (l < c.distance && (c.dataPoint = d, c.distance = l, c.index = f), d = l, d <= h ? h = d : 0 < g ? i++ : j++ , 1e3 < i && 1e3 < j) break } else if (0 > k - e && k + e >= this.dataPoints.length) break; -1 === g ? (e++ , g = 1) : g = -1 } return b || c.dataPoint.x !== a ? b && null !== c.dataPoint ? c : null : c }, L.prototype.getDataPointAtXY = function (a, b, c) { if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || b < this.chart.plotArea.y1 || b > this.chart.plotArea.y2) return null; c = c || !1; var d = [], e = 0, f = 0, g = 1, h = !1, i = 1 / 0, j = 0, k = 0, l = 0; for ("none" !== this.chart.plotInfo.axisPlacement && (l = this.chart.axisX.getXValueAt({ x: a, y: b }), this.axisX.logarithmic ? (f = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), l = 1 < f ? Math.min(Math.max((this.dataPoints.length - 1) / f * Math.log(l / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (f = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, l = 0 < f ? Math.min(Math.max((this.dataPoints.length - 1) / f * (l - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0)); ;) { if (0 <= (f = 0 < g ? l + e : l - e) && f < this.dataPoints.length) { var m = this.chart._eventManager.objectMap[this.dataPointIds[f]], n = this.dataPoints[f], o = null; if (m) { switch (this.type) { case "column": case "stackedColumn": case "stackedColumn100": case "bar": case "stackedBar": case "stackedBar100": case "rangeColumn": case "rangeBar": a >= m.x1 && a <= m.x2 && b >= m.y1 && b <= m.y2 && (d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(m.x1 - a), Math.abs(m.x2 - a), Math.abs(m.y1 - b), Math.abs(m.y2 - b)) }), h = !0); break; case "line": case "stepLine": case "spline": case "area": case "stepArea": case "stackedArea": case "stackedArea100": case "splineArea": case "scatter": var p = t("markerSize", n, this) || 4, q = c ? 20 : p, o = Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y1 - b, 2)); o <= q && d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: o }), f = Math.abs(m.x1 - a), f <= i ? i = f : 0 < g ? j++ : k++ , o <= p / 2 && (h = !0); break; case "rangeArea": case "rangeSplineArea": p = t("markerSize", n, this) || 4, q = c ? 20 : p, o = Math.min(Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y1 - b, 2)), Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y2 - b, 2))), o <= q && d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: o }), f = Math.abs(m.x1 - a), f <= i ? i = f : 0 < g ? j++ : k++ , o <= p / 2 && (h = !0); break; case "bubble": p = m.size, (o = Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y1 - b, 2))) <= p / 2 && (d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: o }), h = !0); break; case "pie": case "doughnut": p = m.center, q = "doughnut" === this.type ? m.percentInnerRadius * m.radius : 0, (o = Math.sqrt(Math.pow(p.x - a, 2) + Math.pow(p.y - b, 2))) < m.radius && o > q && (o = Math.atan2(b - p.y, a - p.x), 0 > o && (o += 2 * Math.PI), o = Number(((o / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), p = Number(((m.startAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), q = Number(((m.endAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), 0 === q && 1 < m.endAngle && (q = 360), p >= q && 0 !== n.y && (q += 360, o < p && (o += 360)), o > p && o < q && (d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: 0 }), h = !0)); break; case "candlestick": (a >= m.x1 - m.borderThickness / 2 && a <= m.x2 + m.borderThickness / 2 && b >= m.y2 - m.borderThickness / 2 && b <= m.y3 + m.borderThickness / 2 || Math.abs(m.x2 - a + m.x1 - a) < m.borderThickness && b >= m.y1 && b <= m.y4) && (d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(m.x1 - a), Math.abs(m.x2 - a), Math.abs(m.y2 - b), Math.abs(m.y3 - b)) }), h = !0); break; case "ohlc": (Math.abs(m.x2 - a + m.x1 - a) < m.borderThickness && b >= m.y2 && b <= m.y3 || a >= m.x1 && a <= (m.x2 + m.x1) / 2 && b >= m.y1 - m.borderThickness / 2 && b <= m.y1 + m.borderThickness / 2 || a >= (m.x1 + m.x2) / 2 && a <= m.x2 && b >= m.y4 - m.borderThickness / 2 && b <= m.y4 + m.borderThickness / 2) && (d.push({ dataPoint: n, dataPointIndex: f, dataSeries: this, distance: Math.min(Math.abs(m.x1 - a), Math.abs(m.x2 - a), Math.abs(m.y2 - b), Math.abs(m.y3 - b)) }), h = !0) }if (h || 1e3 < j && 1e3 < k) break } } else if (0 > l - e && l + e >= this.dataPoints.length) break; -1 === g ? (e++ , g = 1) : g = -1 } for (a = null, b = 0; b < d.length; b++)a ? d[b].distance <= a.distance && (a = d[b]) : a = d[b]; return a }, L.prototype.getMarkerProperties = function (a, b, c, d) { var e = this.dataPoints; return { x: b, y: c, ctx: d, type: e[a].markerType ? e[a].markerType : this.markerType, size: e[a].markerSize ? e[a].markerSize : this.markerSize, color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length], borderColor: e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null, borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null } }, a(M, B), M.prototype.createExtraLabelsForLog = function (a) { if (!(5 < (a = (a || 0) + 1))) { var b = this.logLabelValues[0] || this.intervalStartPosition; if (Math.log(this.range) / Math.log(b / this.viewportMinimum) < this.noTicks - 1) { for (var c = M.getNiceNumber((b - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), d = Math.ceil(this.viewportMinimum / c) * c; d < b; d += c)d < this.viewportMinimum || this.logLabelValues.push(d); this.logLabelValues.sort(k), this.createExtraLabelsForLog(a) } } }, M.prototype.createLabels = function () { var a, b, c, d, f = 0, g = 0, h = 0, i = 0, g = 0, j = this.interval, k = 0, l = .6 * this.chart.height; if ("axisX" !== this.type || "dateTime" !== this.chart.plotInfo.axisXValueType || this.logarithmic) { if (c = this.viewportMaximum, this.labels) { a = Math.ceil(j); for (var j = Math.ceil(this.intervalStartPosition), m = !1, f = j; f < this.viewportMaximum; f += a) { if (!this.labels[f]) { m = !1; break } m = !0 } m && (this.interval = a, this.intervalStartPosition = j) } if (this.logarithmic && !this.equidistantInterval) { this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()); for (var n = 0; n < this.logLabelValues.length; n++)(f = this.logLabelValues[n]) < this.viewportMinimum || (a = this.labelFormatter ? this.labelFormatter({ chart: this.chart._publicChartReference, axis: this._options, value: f, label: this.labels[f] ? this.labels[f] : null }) : "axisX" === this.type && this.labels[f] ? this.labels[f] : _(f, this.valueFormatString, this.chart._cultureInfo), a = new G(this.ctx, { x: 0, y: 0, maxWidth: h, maxHeight: i, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle", borderThickness: 0 }), this._labels.push({ position: f, textBlock: a, effectiveHeight: null })) } for (f = this.intervalStartPosition; f <= c; f = parseFloat((this.logarithmic && this.equidistantInterval ? f * Math.pow(this.logarithmBase, this.interval) : f + this.interval).toFixed(14)))a = this.labelFormatter ? this.labelFormatter({ chart: this.chart._publicChartReference, axis: this._options, value: f, label: this.labels[f] ? this.labels[f] : null }) : "axisX" === this.type && this.labels[f] ? this.labels[f] : _(f, this.valueFormatString, this.chart._cultureInfo), a = new G(this.ctx, { x: 0, y: 0, maxWidth: h, maxHeight: i, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle", borderThickness: 0 }), this._labels.push({ position: f, textBlock: a, effectiveHeight: null }) } else for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), c = e(new Date(this.viewportMaximum), this.interval, this.intervalType), f = this.intervalStartPosition; f < c; e(f, j, this.intervalType))a = f.getTime(), a = this.labelFormatter ? this.labelFormatter({ chart: this.chart._publicChartReference, axis: this._options, value: f, label: this.labels[f] ? this.labels[f] : null }) : "axisX" === this.type && this.labels[a] ? this.labels[a] : $(f, this.valueFormatString, this.chart._cultureInfo), a = new G(this.ctx, { x: 0, y: 0, maxWidth: h, maxHeight: i, angle: this.labelAngle, text: this.prefix + a + this.suffix, horizontalAlign: "left", fontSize: this.labelFontSize, fontFamily: this.labelFontFamily, fontWeight: this.labelFontWeight, fontColor: this.labelFontColor, fontStyle: this.labelFontStyle, textBaseline: "middle" }), this._labels.push({ position: f.getTime(), textBlock: a, effectiveHeight: null }); for ("bottom" === this._position || "top" === this._position ? (k = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * X[this.intervalType + "Duration"] * this.interval, h = void 0 === this._options.labelMaxWidth ? .5 * this.chart.width >> 0 : this._options.labelMaxWidth, this.chart.panEnabled || (i = void 0 === this._options.labelWrap || this.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize)) : "left" !== this._position && "right" !== this._position || (k = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * X[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (h = void 0 === this._options.labelMaxWidth ? .3 * this.chart.width >> 0 : this._options.labelMaxWidth), i = void 0 === this._options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize), g = 0; g < this._labels.length; g++) { a = this._labels[g].textBlock, a.maxWidth = h, a.maxHeight = i; var p = a.measureText(); d = p.height } if (c = [], m = j = 0, this.labelAutoFit || this._options.labelAutoFit) if (o(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position) if (h = .9 * k >> 0, m = 0, !this.chart.panEnabled && 1 <= this._labels.length) { for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, f = 0; f < this._labels.length; f++) { a = this._labels[f].textBlock; for (var q, r = a.text.split(" "), g = 0; g < r.length; g++)n = r[g], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, n = this.ctx.measureText(n), n.width > m && (q = f, m = n.width) } for (f = 0, f = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; f < this._labels.length; f++)if (a = this._labels[f].textBlock, p = a.measureText(), f < this._labels.length - 1 && (n = f + 1, b = this._labels[n].textBlock, b = b.measureText()), c.push(a.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, c), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), g = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (i - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), o(this._options.labelAngle) && isNaN(this._options.labelAngle) && 0 !== this._options.labelAngle) if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? i : Math.min((g - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), g), r = (l - (d + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), o(this._options.labelWrap)) { if (o(this._options.labelWrap)) if (o(this._options.labelMaxWidth)) { if (!o(b)) if (g = p.width + b.width >> 0, n = this.labelFontSize, m < h) g - 2 * h > j && (j = g - 2 * h, g >= 2 * h && g < 2.2 * h ? (this.sessionVariables.labelMaxWidth = h, o(this._options.labelFontSize) && 12 < n && (n = Math.floor(12 / 13 * n), a.measureText()), this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? n : this._options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : g >= 2.2 * h && g < 2.8 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelFontSize = n) : g >= 2.8 * h && g < 3.2 * h ? (this.sessionVariables.labelMaxWidth = Math.max(h, m), this.sessionVariables.labelWrap = !0, o(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? n : this._options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : g >= 3.2 * h && g < 3.6 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelFontSize = this.labelFontSize) : g > 3.6 * h && g < 5 * h ? (o(this._options.labelFontSize) && 12 < n && (n = Math.floor(12 / 13 * n), a.measureText()), this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? n : this._options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r) : g > 5 * h && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelFontSize = n, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelAngle = this.labelAngle)); else if (q === f && (0 === q && m + this._labels[q + 1].textBlock.measureText().width - 2 * h > j || q === this._labels.length - 1 && m + this._labels[q - 1].textBlock.measureText().width - 2 * h > j || 0 < q && q < this._labels.length - 1 && m + this._labels[q + 1].textBlock.measureText().width - 2 * h > j && m + this._labels[q - 1].textBlock.measureText().width - 2 * h > j)) j = 0 === q ? m + this._labels[q + 1].textBlock.measureText().width - 2 * h : m + this._labels[q - 1].textBlock.measureText().width - 2 * h, this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? n : this._options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r; else if (0 === j) for (this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? n : this._options.labelFontSize, this.sessionVariables.labelWrap = !0, g = 0; g < this._labels.length; g++)a = this._labels[g].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, m), r), p = a.measureText(), g < this._labels.length - 1 && (n = g + 1, b = this._labels[n].textBlock, b.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, m), r), b = b.measureText(), p.width + b.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) } else this._options.labelMaxWidth < h ? (this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelMaxHeight = g) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelMaxHeight = i) } else this.labelWrap ? o(this._options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, m), r), this.sessionVariables.labelWrap = this.labelWrap, p.width + b.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle) : o(this._options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelMaxWidth = h, p.width + b.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelWrap = this.labelWrap); else this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? i : Math.min((g - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), g), r = 0 != this.labelAngle ? (l - (d + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : h, this.sessionVariables.labelMaxHeight = i = this.labelWrap ? (l - r * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, o(this._options.labelWrap) ? o(this._options.labelWrap) && (this.labelWrap && !o(this._options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : r, this.sessionVariables.labelMaxHeight = i) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelMaxHeight = g < .9 * k ? .9 * k : g < this.labelFontSize ? 2.5 * this.labelFontSize : g - this.labelFontSize, this.sessionVariables.labelWrap = this.labelWrap)) : (this._options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : r) : (o(this._options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : r, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = i); for (g = 0; g < this._labels.length; g++)a = this._labels[g].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText() } else for (f = 0; f < this._labels.length; f++)a = this._labels[f].textBlock, a.maxWidth = this.labelMaxWidth = o(this._options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this._options.labelMaxWidth, a.fontSize = this.labelFontSize = o(this._options.labelFontSize) ? this.sessionVariables.labelFontSize : this._options.labelFontSize, a.angle = this.labelAngle = o(this._options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = o(this._options.labelWrap) ? this.sessionVariables.labelWrap : this._options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText(); else if ("left" === this._position || "right" === this._position) if (h = o(this._options.labelMaxWidth) ? .3 * this.chart.width >> 0 : this._options.labelMaxWidth, i = void 0 === this._options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) { for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelAngle = o(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, f = 0; f < this._labels.length; f++)a = this._labels[f].textBlock, p = a.measureText(), f < this._labels.length - 1 && (n = f + 1, b = this._labels[n].textBlock, b = b.measureText()), c.push(a.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, c), g = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (i - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), o(this._options.labelAngle) && isNaN(this._options.labelAngle) && 0 !== this._options.labelAngle ? o(this._options.labelWrap) ? o(this._options.labelWrap) && (o(this._options.labelMaxWidth) ? o(b) || (k = p.height + b.height >> 0) - 2 * i > m && (m = k - 2 * i, k >= 2 * i && k < 2.4 * i ? (o(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize) : k >= 2.4 * i && k < 2.8 * i ? (this.sessionVariables.labelMaxHeight = g, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : k >= 2.8 * i && k < 3.2 * i ? (this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelWrap = !0, o(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize, this.sessionVariables.labelAngle = o(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : k >= 3.2 * i && k < 3.6 * i ? (this.sessionVariables.labelMaxHeight = g, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : k > 3.6 * i && k < 10 * i ? (o(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelAngle = o(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : k > 10 * i && k < 50 * i && (o(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = o(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize, this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelAngle = o(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle)) : (this.sessionVariables.labelMaxHeight = i, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = i) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? h : Math.min((g - i * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), i), o(this._options.labelWrap) ? o(this._options.labelWrap) && (this.labelWrap && !o(this._options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth > this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = g) : (this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? i : g, o(this._options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this._options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? i : g, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = h) : (this.sessionVariables.labelMaxHeight = i, o(this._options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap)); for (g = 0; g < this._labels.length; g++)a = this._labels[g].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText() } else for (f = 0; f < this._labels.length; f++)a = this._labels[f].textBlock, a.maxWidth = this.labelMaxWidth = o(this._options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this._options.labelMaxWidth, a.fontSize = this.labelFontSize = o(this._options.labelFontSize) ? this.sessionVariables.labelFontSize : this._options.labelFontSize, a.angle = this.labelAngle = o(this._options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = o(this._options.labelWrap) ? this.sessionVariables.labelWrap : this._options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText(); for (f = 0; f < this.stripLines.length; f++) { var s, h = this.stripLines[f]; "outside" === h.labelPlacement ? (i = this.sessionVariables.labelMaxWidth, "bottom" !== this._position && "top" !== this._position || (s = void 0 === h._options.labelWrap ? this.sessionVariables.labelMaxHeight : h.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize), "left" !== this._position && "right" !== this._position || (s = void 0 === h._options.labelWrap ? this.sessionVariables.labelMaxHeight : h.labelWrap ? .8 * this.chart.width >> 0 : 1.5 * this.labelFontSize), b = o(h._options.labelBackgroundColor) ? "#EEEEEE" : h._options.labelBackgroundColor) : (i = "bottom" === this._position || "top" === this._position ? .9 * this.chart.width >> 0 : .9 * this.chart.height >> 0, s = void 0 === h._options.labelWrap || h.labelWrap ? "bottom" === this._position || "top" === this._position ? .8 * this.chart.width >> 0 : .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, b = o(h._options.labelBackgroundColor) ? o(h.startValue) && 0 !== h.startValue ? "transparent" : "#EEEEEE" : h._options.labelBackgroundColor), a = new G(this.ctx, { x: 0, y: 0, backgroundColor: b, maxWidth: h._options.labelMaxWidth ? h._options.labelMaxWidth : i, maxHeight: s, angle: this.labelAngle, text: h.labelFormatter ? h.labelFormatter({ chart: this.chart._publicChartReference, axis: this, stripLine: h }) : h.label, horizontalAlign: "left", fontSize: "outside" === h.labelPlacement ? h._options.labelFontSize ? h._options.labelFontSize : this.labelFontSize : h.labelFontSize, fontFamily: "outside" === h.labelPlacement ? h._options.labelFontFamily ? h._options.labelFontFamily : this.labelFontFamily : h.labelFontFamily, fontWeight: "outside" === h.labelPlacement ? h._options.fontWeight ? h._options.fontWeight : this.fontWeight : h.fontWeight, fontColor: h._options.labelFontColor || h.color, fontStyle: "outside" === h.labelPlacement ? h._options.fontStyle ? h._options.fontStyle : this.fontWeight : h.fontStyle, textBaseline: "middle", borderThickness: 0 }), this._stripLineLabels.push({ position: h.value, textBlock: a, effectiveHeight: null, stripLine: h }) } }, M.prototype.createLabelsAndCalculateWidth = function () { var a = 0, b = 0; if (this._labels = [], this._stripLineLabels = [], "left" === this._position || "right" === this._position) { for (this.createLabels(), b = 0; b < this._labels.length; b++) { var c = this._labels[b].textBlock, d = c.measureText(), e = 0, e = 0 === this.labelAngle ? d.width : d.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)); a < e && (a = e), this._labels[b].effectiveWidth = e } for (b = 0; b < this._stripLineLabels.length; b++)"outside" === this._stripLineLabels[b].stripLine.labelPlacement && this._stripLineLabels[b].stripLine.value > this.viewportMinimum && this._stripLineLabels[b].stripLine.value < this.viewportMaximum && (c = this._stripLineLabels[b].textBlock, d = c.measureText(), e = 0 === this.labelAngle ? d.width : d.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[b].effectiveWidth = e) } return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + this.tickLength + 5 }, M.prototype.createLabelsAndCalculateHeight = function () { var a = 0; this._labels = [], this._stripLineLabels = []; var b, c = 0; if (this.createLabels(), "bottom" === this._position || "top" === this._position) { for (c = 0; c < this._labels.length; c++) { b = this._labels[c].textBlock; var d = b.measureText(), e = 0, e = 0 === this.labelAngle ? d.height : d.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - b.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)); a < e && (a = e), this._labels[c].effectiveHeight = e } for (c = 0; c < this._stripLineLabels.length; c++)"outside" === this._stripLineLabels[c].stripLine.labelPlacement && (b = this._stripLineLabels[c].textBlock, d = b.measureText(), e = 0 === this.labelAngle ? d.height : d.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - b.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[c].effectiveHeight = e) } return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + this.tickLength + 5 }, M.setLayoutAndRender = function (a, b, c, d, e) { var f, g, h, i = a.chart, k = i.ctx; a.calculateAxisParameters(), b && b.calculateAxisParameters(), c && c.calculateAxisParameters(); var l, m, n, p, q, r, s, t, u, v = b ? b.margin : 0, w = c ? c.margin : 0, x = 0, y = 0, z = 0, A = 0, B = 0; if (s = t = u = !1, a && a.title && (a._titleTextBlock = new G(a.ctx, { text: a.title, horizontalAlign: "center", fontSize: a.titleFontSize, fontFamily: a.titleFontFamily, fontWeight: a.titleFontWeight, fontColor: a.titleFontColor, fontStyle: a.titleFontStyle, textBaseline: "top" })), b && b.title && (b._titleTextBlock = new G(b.ctx, { text: b.title, horizontalAlign: "center", fontSize: b.titleFontSize, fontFamily: b.titleFontFamily, fontWeight: b.titleFontWeight, fontColor: b.titleFontColor, fontStyle: b.titleFontStyle, textBaseline: "top" })), c && c.title && (c._titleTextBlock = new G(c.ctx, { text: c.title, horizontalAlign: "center", fontSize: c.titleFontSize, fontFamily: c.titleFontFamily, fontWeight: c.titleFontWeight, fontColor: c.titleFontColor, fontStyle: c.titleFontStyle, textBaseline: "top" })), "normal" === d) { var C = [], D = [], E = []; for (a && a.title && (a._titleTextBlock.maxWidth = a.titleMaxWidth || e.width, a._titleTextBlock.maxHeight = a.titleWrap ? .8 * e.height : 1.5 * a.titleFontSize, a._titleTextBlock.angle = 0), b && b.title && (b._titleTextBlock.maxWidth = b.titleMaxWidth || e.height, b._titleTextBlock.maxHeight = b.titleWrap ? .8 * e.width : 1.5 * b.titleFontSize, b._titleTextBlock.angle = -90), c && c.title && (c._titleTextBlock.maxWidth = c.titleMaxWidth || e.height, c._titleTextBlock.maxHeight = c.titleWrap ? .8 * e.width : 1.5 * c.titleFontSize, c._titleTextBlock.angle = 90); 4 > x++;) { if (a.lineCoordinates = {}, m = Math.ceil(b ? b.createLabelsAndCalculateWidth() : 0), D.push(m), f = Math.round(e.x1 + m + v), l = Math.ceil(c ? c.createLabelsAndCalculateWidth() : 0), E.push(l), g = Math.round(e.x2 - l - w > a.chart.width - 10 ? a.chart.width - 10 : e.x2 - l - w), !a.labelAutoFit || o(q) || o(r) || (0 < a.labelAngle ? r + z > g && (A += 0 < a.labelAngle ? r + z - g - l : 0) : 0 > a.labelAngle ? q - y < f && q - y < a.viewportMinimum && (B = f - (v + a.tickLength + m + q - y + a.labelFontSize / 2)) : 0 === a.labelAngle && (r + z > g && (A = r + z / 2 - g - l), q - y < f && q - y < a.viewportMinimum && (B = f - v - a.tickLength - m - q + y / 2)), a.viewportMaximum === a.maximum && a.viewportMinimum === a.minimum && 0 < a.labelAngle && 0 < A ? g -= A : a.viewportMaximum === a.maximum && a.viewportMinimum === a.minimum && 0 > a.labelAngle && 0 < B ? f += B : a.viewportMaximum === a.maximum && a.viewportMinimum === a.minimum && 0 === a.labelAngle && (0 < B && (f += B), 0 < A && (g -= A))), a.lineCoordinates.x1 = f, a.lineCoordinates.x2 = g, a.lineCoordinates.width = Math.abs(g - f), a.title && (a._titleTextBlock.maxWidth = 0 < a.titleMaxWidth && a.titleMaxWidth < a.lineCoordinates.width ? a.titleMaxWidth : a.lineCoordinates.width), m = Math.ceil(a.createLabelsAndCalculateHeight()), C.push(m), a._labels && 1 < a._labels.length && (d = h = 0, h = a._labels[1], d = "dateTime" === a.chart.plotInfo.axisXValueType ? a._labels[a._labels.length - 2] : a._labels[a._labels.length - 1], y = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), z = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle))), i.panEnabled ? m = i.sessionVariables.axisX.height : i.sessionVariables.axisX.height = m, d = Math.round(e.y2 - m - a.margin), h = Math.round(e.y2 - a.margin), a.lineCoordinates.y1 = d, a.lineCoordinates.y2 = d, a.boundingRect = { x1: f, y1: d, x2: g, y2: h, width: g - f, height: h - d }, b && (f = Math.round(e.x1 + b.margin), d = Math.round(10 > e.y1 ? 10 : e.y1), g = Math.round(a.lineCoordinates.x1), h = Math.round(e.y2 - m - a.margin), b.lineCoordinates = { x1: g, y1: d, x2: g, y2: h, height: Math.abs(h - d) }, b.boundingRect = { x1: f, y1: d, x2: g, y2: h, width: g - f, height: h - d }, b.title && (b._titleTextBlock.maxWidth = 0 < b.titleMaxWidth && b.titleMaxWidth < b.lineCoordinates.height ? b.titleMaxWidth : b.lineCoordinates.height)), c && (f = Math.round(a.lineCoordinates.x2), d = Math.round(10 > e.y1 ? 10 : e.y1), g = Math.round(f + l), h = Math.round(e.y2 - m - a.margin), c.lineCoordinates = { x1: f, y1: d, x2: f, y2: h, height: Math.abs(h - d) }, c.boundingRect = { x1: f, y1: d, x2: g, y2: h, width: g - f, height: h - d }, c.title && (c._titleTextBlock.maxWidth = 0 < c.titleMaxWidth && c.titleMaxWidth < c.lineCoordinates.height ? c.titleMaxWidth : c.lineCoordinates.height)), a.calculateValueToPixelConversionParameters(), a._labels && 1 < a._labels.length && (q = (a.logarithmic ? Math.log(a._labels[1].position / a.viewportMinimum) / a.conversionParameters.lnLogarithmBase : a._labels[1].position - a.viewportMinimum) * Math.abs(a.conversionParameters.pixelPerUnit) + a.lineCoordinates.x1, r = "dateTime" === a.chart.plotInfo.axisXValueType ? (a.logarithmic ? Math.log(a._labels[a._labels.length - 2].position / a.viewportMinimum) / a.conversionParameters.lnLogarithmBase : a._labels[a._labels.length - 2].position - a.viewportMinimum) * Math.abs(a.conversionParameters.pixelPerUnit) + a.lineCoordinates.x1 : (a.logarithmic ? Math.log(a._labels[a._labels.length - 1].position / a.viewportMinimum) / a.conversionParameters.lnLogarithmBase : a._labels[a._labels.length - 1].position - a.viewportMinimum) * Math.abs(a.conversionParameters.pixelPerUnit) + a.lineCoordinates.x1), b && b.calculateValueToPixelConversionParameters(), c && c.calculateValueToPixelConversionParameters(), a || b || c) { if (!o(C)) for (x = 0; x < C.length; x++)for (j = x + 1; j < C.length; j++)C[x] == C[j] && (s = !0); if (!o(D)) for (x = 0; x < D.length; x++)for (j = x + 1; j < D.length; j++)D[x] == D[j] && (t = !0); if (!o(E)) for (x = 0; x < E.length; x++)for (j = x + 1; j < E.length; j++)E[x] == E[j] && (u = !0) } if (s && t && u) break } k.save(), k.beginPath(), k.rect(5, a.boundingRect.y1, a.chart.width - 10, a.boundingRect.height), k.clip(), a.renderLabelsTicksAndTitle(), k.restore(), b && b.renderLabelsTicksAndTitle(), c && c.renderLabelsTicksAndTitle() } else { for (w = [], q = [], r = [], a && a.title && (a._titleTextBlock.maxWidth = a.titleMaxWidth || e.height, a._titleTextBlock.maxHeight = a.titleWrap ? .8 * e.width : 1.5 * a.titleFontSize, a._titleTextBlock.angle = -90), b && b.title && (b._titleTextBlock.maxWidth = b.titleMaxWidth || e.width, b._titleTextBlock.maxHeight = b.titleWrap ? .8 * e.height : 1.5 * b.titleFontSize, b._titleTextBlock.angle = 0), c && c.title && (c._titleTextBlock.maxWidth = b.titleMaxWidth || e.width, c._titleTextBlock.maxHeight = c.titleWrap ? .8 * e.height : 1.5 * c.titleFontSize, c._titleTextBlock.angle = 0); 4 > x++;) { if (A = Math.ceil(a.createLabelsAndCalculateWidth()), w.push(A), b && (b.lineCoordinates = {}, f = Math.round(e.x1 + A + a.margin), g = Math.round(e.x2 > b.chart.width - 10 ? b.chart.width - 10 : e.x2), b.labelAutoFit && !o(l) && (f = 0 > b.labelAngle ? Math.max(f, l) : 0 === b.labelAngle ? Math.max(f, l / 2) : f, g = 0 < b.labelAngle ? g - m : 0 === b.labelAngle ? g - m / 2 : g), b.lineCoordinates.x1 = f, b.lineCoordinates.x2 = g, b.lineCoordinates.width = Math.abs(g - f), b.title && (b._titleTextBlock.maxWidth = 0 < b.titleMaxWidth && b.titleMaxWidth < b.lineCoordinates.width ? b.titleMaxWidth : b.lineCoordinates.width)), c && (c.lineCoordinates = {}, f = Math.round(e.x1 + A + a.margin), g = Math.round(e.x2 > c.chart.width - 10 ? c.chart.width - 10 : e.x2), b && b.labelAutoFit && !o(n) && (f = 0 < c.labelAngle ? Math.max(f, n) : 0 === c.labelAngle ? Math.max(f, n / 2) : f, g -= p / 2), c.lineCoordinates.x1 = f, c.lineCoordinates.x2 = g, c.lineCoordinates.width = Math.abs(g - f), c.title && (c._titleTextBlock.maxWidth = 0 < c.titleMaxWidth && c.titleMaxWidth < c.lineCoordinates.width ? c.titleMaxWidth : c.lineCoordinates.width)), B = Math.ceil(b ? b.createLabelsAndCalculateHeight() : 0), y = Math.ceil(c ? c.createLabelsAndCalculateHeight() : 0), q.push(B), r.push(y), b && 0 < b._labels.length && (h = b._labels[0], d = b._labels[b._labels.length - 1], l = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), m = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle))), c && 0 < c._labels.length && (h = c._labels[0], d = c._labels[c._labels.length - 1], n = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), p = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle))), i.panEnabled ? B = i.sessionVariables.axisY.height : i.sessionVariables.axisY.height = B, b && (d = Math.round(e.y2 - B - b.margin), h = Math.round(e.y2 - v > b.chart.height - 10 ? b.chart.height - 10 : e.y2 - v), b.lineCoordinates.y1 = d, b.lineCoordinates.y2 = d, b.boundingRect = { x1: f, y1: d, x2: g, y2: h, width: g - f, height: B }, b.title && (b._titleTextBlock.maxWidth = 0 < b.titleMaxWidth && b.titleMaxWidth < b.lineCoordinates.width ? b.titleMaxWidth : b.lineCoordinates.width)), c && (d = Math.round(e.y1 + c.margin), h = e.y1 + c.margin + y, c.lineCoordinates.y1 = h, c.lineCoordinates.y2 = h, c.boundingRect = { x1: f, y1: d, x2: g, y2: h, width: g - f, height: y }, c.title && (c._titleTextBlock.maxWidth = 0 < c.titleMaxWidth && c.titleMaxWidth < c.lineCoordinates.width ? c.titleMaxWidth : c.lineCoordinates.width)), f = Math.round(e.x1 + a.margin), d = Math.round(c ? c.lineCoordinates.y2 : 10 > e.y1 ? 10 : e.y1), g = Math.round(e.x1 + A + a.margin), h = Math.round(b ? b.lineCoordinates.y1 : e.y2 - v > a.chart.height - 10 ? a.chart.height - 10 : e.y2 - v), b && b.labelAutoFit && (g = 0 > b.labelAngle ? Math.max(g, l) : 0 === b.labelAngle ? Math.max(g, l / 2) : g, f = 0 > b.labelAngle || 0 === b.labelAngle ? g - A : f), c && c.labelAutoFit && (g = c.lineCoordinates.x1, f = g - A), a.lineCoordinates = { x1: g, y1: d, x2: g, y2: h, height: Math.abs(h - d) }, a.boundingRect = { x1: f, y1: d, x2: g, y2: h, width: g - f, height: h - d }, a.title && (a._titleTextBlock.maxWidth = 0 < a.titleMaxWidth && a.titleMaxWidth < a.lineCoordinates.height ? a.titleMaxWidth : a.lineCoordinates.height), a.calculateValueToPixelConversionParameters(), b && b.calculateValueToPixelConversionParameters(), c && c.calculateValueToPixelConversionParameters(), a || b || c) { if (!o(C)) for (x = 0; x < C.length; x++)for (j = x + 1; j < C.length; j++)C[x] == C[j] && (s = !0); if (!o(D)) for (x = 0; x < D.length; x++)for (j = x + 1; j < D.length; j++)D[x] == D[j] && (t = !0); if (!o(E)) for (x = 0; x < E.length; x++)for (j = x + 1; j < E.length; j++)E[x] == E[j] && (u = !0) } if (s && t && u) break } b && b.renderLabelsTicksAndTitle(), c && c.renderLabelsTicksAndTitle(), a.renderLabelsTicksAndTitle() } i.preparePlotArea(), e = a.chart.plotArea, k.save(), k.beginPath(), k.rect(e.x1, e.y1, Math.abs(e.x2 - e.x1), Math.abs(e.y2 - e.y1)), k.clip(), a.renderStripLinesOfThicknessType("value"), b && b.renderStripLinesOfThicknessType("value"), c && c.renderStripLinesOfThicknessType("value"), a.renderInterlacedColors(), b && b.renderInterlacedColors(), c && c.renderInterlacedColors(), k.restore(), a.renderGrid(), b && b.renderGrid(), c && c.renderGrid(), a.renderAxisLine(), b && b.renderAxisLine(), c && c.renderAxisLine(), a.renderStripLinesOfThicknessType("pixel"), b && b.renderStripLinesOfThicknessType("pixel"), c && c.renderStripLinesOfThicknessType("pixel") }, M.prototype.renderLabelsTicksAndTitle = function () { var a = !1, b = 0, c = 0, d = 1, e = 0; if (0 !== this.labelAngle && 360 !== this.labelAngle && (d = 1.2), void 0 === this._options.interval) { if ("bottom" === this._position || "top" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) { for (var f, b = [], d = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, g = this.viewportMaximum, h = this.lineCoordinates.width / Math.log(this.range), i = this._labels.length - 1; 0 <= i && (k = this._labels[i], !(k.position < this.viewportMinimum)); i--)k.position > this.viewportMaximum || !(i === this._labels.length - 1 || f < Math.log(g / k.position) * h / d) || (b.push(k), g = k.position, f = k.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))); this._labels = b } else { for (i = 0; i < this._labels.length; i++)k = this._labels[i], k.position < this.viewportMinimum || (k = k.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += k); b > this.lineCoordinates.width * d && this.labelAutoFit && (a = !0) } if ("left" === this._position || "right" === this._position) if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) { for (var j, b = [], g = this.viewportMaximum, h = this.lineCoordinates.height / Math.log(this.range), i = this._labels.length - 1; 0 <= i && (k = this._labels[i], !(k.position < this.viewportMinimum)); i--)k.position > this.viewportMaximum || !(i === this._labels.length - 1 || j < Math.log(g / k.position) * h) || (b.push(k), g = k.position, j = k.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle))); this._labels = b } else { for (i = 0; i < this._labels.length; i++)k = this._labels[i], k.position < this.viewportMinimum || (k = k.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += k); c > this.lineCoordinates.height * d && this.labelAutoFit && (a = !0) } } if ("bottom" === this._position) { for (var k, i = 0; i < this._labels.length; i++)k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 != e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 == this.ctx.lineWidth % 2 ? .5 + (c.x << 0) : c.x << 0, this.ctx.beginPath(), this.ctx.moveTo(d, c.y << 0), this.ctx.lineTo(d, c.y + this.tickLength << 0), this.ctx.stroke()), 0 === k.textBlock.angle ? (c.x -= k.textBlock.width / 2, c.y += this.tickLength + k.textBlock.fontSize / 2) : (c.x -= 0 > this.labelAngle ? k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, c.y += this.tickLength + Math.abs(0 > this.labelAngle ? k.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), k.textBlock.x = c.x, k.textBlock.y = c.y, k.textBlock.render(!0))); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.boundingRect.y2 - this._titleTextBlock.height - 3, this._titleTextBlock.render(!0)) } else if ("top" === this._position) { for (i = 0; i < this._labels.length; i++)k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 != e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 == this.ctx.lineWidth % 2 ? .5 + (c.x << 0) : c.x << 0, this.ctx.beginPath(), this.ctx.moveTo(d, c.y << 0), this.ctx.lineTo(d, c.y - this.tickLength << 0), this.ctx.stroke()), 0 === k.textBlock.angle ? (c.x -= k.textBlock.width / 2, c.y -= this.tickLength + k.textBlock.height) : (c.x += (k.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), c.y -= this.tickLength + (k.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? k.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0))), k.textBlock.x = c.x, k.textBlock.y = c.y, k.textBlock.render(!0))); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.boundingRect.y1 + 1, this._titleTextBlock.render(!0)) } else if ("left" === this._position) { for (i = 0; i < this._labels.length; i++)k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 != e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 == this.ctx.lineWidth % 2 ? .5 + (c.y << 0) : c.y << 0, this.ctx.beginPath(), this.ctx.moveTo(c.x << 0, d), this.ctx.lineTo(c.x - this.tickLength << 0, d), this.ctx.stroke()), 0 === this.labelAngle ? (k.textBlock.y = c.y, k.textBlock.x = c.x - k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (k.textBlock.y = c.y - k.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), k.textBlock.x = 0 < this.labelAngle ? c.x - k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : c.x - k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (k.textBlock.height - k.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength), k.textBlock.render(!0))); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.boundingRect.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this._titleTextBlock.render(!0)) } else if ("right" === this._position) { for (i = 0; i < this._labels.length; i++)k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 != e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 == this.ctx.lineWidth % 2 ? .5 + (c.y << 0) : c.y << 0, this.ctx.beginPath(), this.ctx.moveTo(c.x << 0, d), this.ctx.lineTo(c.x + this.tickLength << 0, d), this.ctx.stroke()), 0 === this.labelAngle ? (k.textBlock.y = c.y, k.textBlock.x = c.x + this.tickLength + 5) : (k.textBlock.y = 0 > this.labelAngle ? c.y : c.y - (k.textBlock.height - k.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), k.textBlock.x = 0 < this.labelAngle ? c.x + (k.textBlock.height - k.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : c.x + this.tickLength + 5), k.textBlock.render(!0))); this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.boundingRect.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this._titleTextBlock.render(!0)) } }, M.prototype.renderInterlacedColors = function () { var a, b, c = this.chart.plotArea.ctx, d = this.chart.plotArea, e = 0; if (a = !0, "bottom" !== this._position && "top" !== this._position || !this.interlacedColor) { if (("left" === this._position || "right" === this._position) && this.interlacedColor) for (c.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)a ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), a = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), c.fillRect(d.x1, Math.min(b.y, a.y), Math.abs(d.x1 - d.x2), Math.abs(a.y - b.y)), a = !1) : a = !0 } else for (c.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++)a ? (a = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), c.fillRect(Math.min(b.x, a.x), d.y1, Math.abs(b.x - a.x), Math.abs(d.y1 - d.y2)), a = !1) : a = !0; c.beginPath() }, M.prototype.renderStripLinesOfThicknessType = function (a) { if (this.stripLines && 0 < this.stripLines.length && a) { for (var b, c = this, d = 0, e = 0, f = !1, g = !1, h = [], i = [], g = !1, d = 0; d < this.stripLines.length; d++) { var j = this.stripLines[d]; j._thicknessType === a && ("pixel" === a && (j.value < this.viewportMinimum || j.value > this.viewportMaximum) || h.push(j)) } for (d = 0; d < this._stripLineLabels.length; d++)if (j = this.stripLines[d], b = this._stripLineLabels[d], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum)) { if (a = this.getPixelCoordinatesOnAxis(b.position), "outside" === b.stripLine.labelPlacement) if (j && (this.ctx.strokeStyle = j.color, "pixel" === j._thicknessType && (this.ctx.lineWidth = j.thickness)), "bottom" === this._position) { var k = 1 == this.ctx.lineWidth % 2 ? .5 + (a.x << 0) : a.x << 0; this.ctx.beginPath(), this.ctx.moveTo(k, a.y << 0), this.ctx.lineTo(k, a.y + this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)) } else "top" === this._position ? (k = 1 == this.ctx.lineWidth % 2 ? .5 + (a.x << 0) : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(k, a.y << 0), this.ctx.lineTo(k, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength + b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (b.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (k = 1 == this.ctx.lineWidth % 2 ? .5 + (a.y << 0) : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, k), this.ctx.lineTo(a.x - this.tickLength << 0, k), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (k = 1 == this.ctx.lineWidth % 2 ? .5 + (a.y << 0) : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, k), this.ctx.lineTo(a.x + this.tickLength << 0, k), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5)); else b.textBlock.angle = -90, "bottom" === this._position ? (b.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? o(j.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, o(j.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (b.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? o(j.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, o(j.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 - b.textBlock.width - 3) : "left" === this._position ? (b.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? o(j.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : o(j.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : "right" === this._position && (b.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ? o(j.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : o(j.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 + 3); b.textBlock.x = a.x, b.textBlock.y = a.y, i.push(b) } if (!g) { for (g = !1, this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), d = 0; d < h.length; d++)j = h[d], j.showOnTop ? f || (f = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () { for (this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), e = 0; e < h.length; e++)j = h[e], j.showOnTop && j.render(); this.ctx.restore() }, j)) : j.render(); for (d = 0; d < i.length; d++)b = i[d], b.stripLine.showOnTop ? g || (g = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () { for (e = 0; e < i.length; e++)b = i[e], "inside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && (c.ctx.save(), c.ctx.beginPath(), c.ctx.rect(c.chart.plotArea.x1, c.chart.plotArea.y1, c.chart.plotArea.width, c.chart.plotArea.height), c.ctx.clip(), b.textBlock.render(!0), c.ctx.restore()) }, b.textBlock)) : "inside" === b.stripLine.labelPlacement && b.textBlock.render(!0); this.ctx.restore(), g = !0 } if (g) for (g = !1, d = 0; d < i.length; d++)b = i[d], b.stripLine.showOnTop ? g || (g = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () { for (e = 0; e < i.length; e++)b = i[e], "outside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(!0) }, b.textBlock)) : "outside" === b.stripLine.labelPlacement && b.textBlock.render(!0) } }, M.prototype.renderGrid = function () { if (this.gridThickness && 0 < this.gridThickness) { var a = this.chart.ctx; a.save(); var b, c = this.chart.plotArea; if (a.lineWidth = this.gridThickness, a.strokeStyle = this.gridColor, a.setLineDash && a.setLineDash(q(this.gridDashType, this.gridThickness)), "bottom" === this._position || "top" === this._position) for (d = 0; d < this._labels.length; d++)this._labels[d].position < this.viewportMinimum || this._labels[d].position > this.viewportMaximum || (a.beginPath(), b = this.getPixelCoordinatesOnAxis(this._labels[d].position), b = 1 == a.lineWidth % 2 ? .5 + (b.x << 0) : b.x << 0, a.moveTo(b, c.y1 << 0), a.lineTo(b, c.y2 << 0), a.stroke()); else if ("left" === this._position || "right" === this._position) for (var d = 0; d < this._labels.length; d++)this._labels[d].position < this.viewportMinimum || this._labels[d].position > this.viewportMaximum || (a.beginPath(), b = this.getPixelCoordinatesOnAxis(this._labels[d].position), b = 1 == a.lineWidth % 2 ? .5 + (b.y << 0) : b.y << 0, a.moveTo(c.x1 << 0, b), a.lineTo(c.x2 << 0, b), a.stroke()); a.restore() } }, M.prototype.renderAxisLine = function () { var a = this.chart.ctx; if (a.save(), "bottom" === this._position || "top" === this._position) { if (this.lineThickness) { a.lineWidth = this.lineThickness, a.strokeStyle = this.lineColor ? this.lineColor : "black", a.setLineDash && a.setLineDash(q(this.lineDashType, this.lineThickness)); var b = 1 == this.lineThickness % 2 ? .5 + (this.lineCoordinates.y1 << 0) : this.lineCoordinates.y1 << 0; a.beginPath(), a.moveTo(this.lineCoordinates.x1, b), a.lineTo(this.lineCoordinates.x2, b), a.stroke() } } else "left" !== this._position && "right" !== this._position || !this.lineThickness || (a.lineWidth = this.lineThickness, a.strokeStyle = this.lineColor, a.setLineDash && a.setLineDash(q(this.lineDashType, this.lineThickness)), b = 1 == this.lineThickness % 2 ? .5 + (this.lineCoordinates.x1 << 0) : this.lineCoordinates.x1 << 0, a.beginPath(), a.moveTo(b, this.lineCoordinates.y1), a.lineTo(b, this.lineCoordinates.y2), a.stroke()); a.restore() }, M.prototype.getPixelCoordinatesOnAxis = function (a) { var b = {}; return "bottom" !== this._position && "top" !== this._position || (b.x = this.convertValueToPixel(a), b.y = this.lineCoordinates.y1), "left" !== this._position && "right" !== this._position || (b.y = this.convertValueToPixel(a), b.x = this.lineCoordinates.x2), b }, M.prototype.convertPixelToValue = function (a) { return a ? (a = "left" === this._position || "right" === this._position ? a.y : a.x, this.logarithmic ? Math.pow(this.logarithmBase, (a - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit) * this.viewportMinimum : this.conversionParameters.minimum + (a - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit) : null }, M.prototype.setViewPortRange = function (a, b) { this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, b), this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, b) }, M.prototype.getXValueAt = function (a) { if (!a) return null; var b = null; return "left" === this._position ? b = this.convertPixelToValue(a.y) : "bottom" === this._position && (b = this.convertPixelToValue(a.x)), b }, M.prototype.calculateValueToPixelConversionParameters = function (a) { a = { pixelPerUnit: null, minimum: null, reference: null }; var b = this.lineCoordinates.width, c = this.lineCoordinates.height; a.minimum = this.viewportMinimum, "bottom" !== this._position && "top" !== this._position || (this.logarithmic ? (a.lnLogarithmBase = Math.log(this.logarithmBase), a.pixelPerUnit = (this.reversed ? -1 : 1) * b * a.lnLogarithmBase / Math.log(Math.abs(this.range))) : a.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(this.range), a.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1), "left" !== this._position && "right" !== this._position || (this.logarithmic ? (a.lnLogarithmBase = Math.log(this.logarithmBase), a.pixelPerUnit = (this.reversed ? 1 : -1) * c * a.lnLogarithmBase / Math.log(Math.abs(this.range))) : a.pixelPerUnit = (this.reversed ? 1 : -1) * c / Math.abs(this.range), a.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2), this.conversionParameters = a }, M.prototype.convertValueToPixel = function (a) { return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + .5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + .5 << 0 }, M.prototype.calculateAxisParameters = function () { if (this.logarithmic) this.calculateLogarithamicAxisParameters(); else { var a = this.chart.layoutManager.getFreeSpace(), b = !1; "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width); var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40, c = 4; "axisX" === this.type && (c = 100 > this.maxWidth ? 3 : 300 > this.maxWidth ? 6 : 600 > this.maxWidth ? 8 : 6); var d, e, f, a = Math.max(c, Math.floor(this.maxWidth / a)), c = 0; if ((null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum), "axisX" === this.type ? (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 == e - d && (c = void 0 === this._options.interval ? .4 : this._options.interval, e += c, d -= c), 1 / 0 !== this.dataInfo.minDiff ? f = this.dataInfo.minDiff : 1 < e - d ? f = .5 * Math.abs(e - d) : (f = 1, "dateTime" === this.chart.plotInfo.axisXValueType && (b = !0))) : "axisY" === this.type && (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(d) || isFinite(e) ? isFinite(d) ? isFinite(e) || (e = d) : d = e : (e = void 0 === this._options.interval ? -1 / 0 : this._options.interval, d = 0), 0 === d && 0 === e ? (e += 9, d = 0) : 0 == e - d ? (c = Math.min(Math.abs(.01 * Math.abs(e)), 5), e += c, d -= c) : d > e ? (c = Math.min(Math.abs(.01 * Math.abs(e - d)), 5), 0 <= e ? d = e - c : e = d + c) : (c = Math.min(Math.abs(.01 * Math.abs(e - d)), .05), 0 !== e && (e += c), 0 !== d && (d -= c)), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < e - d ? .5 * Math.abs(e - d) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < d && (d = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > e && (e = 0)), c = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum), "axisX" === this.type && "dateTime" === this.chart.plotInfo.axisXValueType ? (this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : c / 2 <= a ? (this.interval = 2, this.intervalType = "millisecond") : c / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : c / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : c / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : c / 50 <= a ? (this.interval = 50, this.intervalType = "millisecond") : c / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : c / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : c / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : c / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : c / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : c / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : c / (1 * X.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : c / (2 * X.secondDuration) <= a ? (this.interval = 2, this.intervalType = "second") : c / (5 * X.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : c / (10 * X.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : c / (15 * X.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : c / (20 * X.secondDuration) <= a ? (this.interval = 20, this.intervalType = "second") : c / (30 * X.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : c / (1 * X.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : c / (2 * X.minuteDuration) <= a ? (this.interval = 2, this.intervalType = "minute") : c / (5 * X.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : c / (10 * X.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : c / (15 * X.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : c / (20 * X.minuteDuration) <= a ? (this.interval = 20, this.intervalType = "minute") : c / (30 * X.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : c / (1 * X.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : c / (2 * X.hourDuration) <= a ? (this.interval = 2, this.intervalType = "hour") : c / (3 * X.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : c / (6 * X.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : c / (1 * X.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : c / (2 * X.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") : c / (4 * X.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : c / (1 * X.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : c / (2 * X.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : c / (3 * X.weekDuration) <= a ? (this.interval = 3, this.intervalType = "week") : c / (1 * X.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : c / (2 * X.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : c / (3 * X.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : c / (6 * X.monthDuration) <= a ? (this.interval = 6, this.intervalType = "month") : (this.interval = c / (1 * X.yearDuration) <= a ? 1 : c / (2 * X.yearDuration) <= a ? 2 : c / (4 * X.yearDuration) <= a ? 4 : Math.floor(M.getNiceNumber(c / (a - 1), !0) / X.yearDuration), this.intervalType = "year")), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = d - f / 2), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = e + f / 2), b ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'"), this.valueFormatString || (this.valueFormatString = this.autoValueFormatString)) : (this.intervalType = "number", c = M.getNiceNumber(c, !1), this.interval = this._options && 0 < this._options.interval ? this._options.interval : M.getNiceNumber(c / (a - 1), !0), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? d - f / 2 : Math.floor(d / this.interval) * this.interval), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? e + f / 2 : Math.ceil(e / this.interval) * this.interval), 0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this._options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this._options.viewportMaximum && (this.viewportMinimum -= 10), this._options && void 0 === this._options.interval && (this.interval = M.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 == e - d && (c = void 0 === this._options.interval ? .4 : this._options.interval, e += c, d -= c), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < e - d ? .5 * Math.abs(e - d) : 1) : "axisY" === this.type && (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(d) || isFinite(e) ? 0 === d && 0 === e ? (e += 9, d = 0) : 0 == e - d ? (c = Math.min(Math.abs(.01 * Math.abs(e)), 5), e += c, d -= c) : d > e ? (c = Math.min(Math.abs(.01 * Math.abs(e - d)), 5), 0 <= e ? d = e - c : e = d + c) : (c = Math.min(Math.abs(.01 * Math.abs(e - d)), .05), 0 !== e && (e += c), 0 !== d && (d -= c)) : (e = void 0 === this._options.interval ? -1 / 0 : this._options.interval, d = 0), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < e - d ? .5 * Math.abs(e - d) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < d && (d = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > e && (e = 0)), "axisX" === this.type && "dateTime" === this.chart.plotInfo.axisXValueType ? ((null === this.minimum || isNaN(this.minimum)) && (this.minimum = d - f / 2), (null === this.maximum || isNaN(this.maximum)) && (this.maximum = e + f / 2)) : (this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? d - f / 2 : Math.floor(d / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? 1 / 0 : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e + f / 2 : Math.ceil(e / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -1 / 0 : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this._options.minimum ? this.maximum += 10 : 0 === this._options.maximum && (this.minimum -= 10)))), this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum), this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum), this.range = this.viewportMaximum - this.viewportMinimum, this.intervalStartPosition = "axisX" === this.type && "dateTime" === this.chart.plotInfo.axisXValueType ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + .2 * this.interval) / this.interval) * this.interval, !this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.range) && (b = Math.floor(Math.abs(Math.log(this.range) / Math.LN10)) + 2, !isNaN(b) && isFinite(b) || (b = 2), 2 < b)) for (d = 0; d < b - 2; d++)this.valueFormatString += "#" } }, M.prototype.calculateLogarithamicAxisParameters = function () { var a, b = this.chart.layoutManager.getFreeSpace(), c = Math.log(this.logarithmBase); "bottom" === this._position || "top" === this._position ? (this.maxWidth = b.width, this.maxHeight = b.height) : (this.maxWidth = b.height, this.maxHeight = b.width); var d, e, f, g, b = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3); if (g = 1, (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum), "axisX" === this.type ? (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 == e / d && (g = Math.pow(this.logarithmBase, void 0 === this._options.interval ? .4 : this._options.interval), e *= g, d /= g), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= d && !isFinite(e) ? (e = void 0 === this._options.interval ? 0 : this._options.interval, d = 1) : 0 >= d ? d = e : isFinite(e) || (e = d), 1 === d && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, d = 1) : 1 == e / d ? (g = Math.min(e * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), e *= g, d /= g) : d > e ? (g = Math.min(d / e * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), 1 <= e ? d = e / g : e = d * g) : (g = Math.min(e / d * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== e && (e *= g), 1 !== d && (d /= g)), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < d && (d = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1)), g = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum), linearRange = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum), this.intervalType = "number", g = Math.pow(this.logarithmBase, M.getNiceNumber(Math.abs(Math.log(g) / c), !1)), this._options && 0 < this._options.interval ? this.interval = this._options.interval : (this.interval = M.getNiceExponent(Math.log(g) / c / (b - 1), !0), a = M.getNiceNumber(linearRange / (b - 1), !0)), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? d / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(d) / c / this.interval))), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? e * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / c / this.interval))), 1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this._options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this._options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this._options && void 0 === this._options.interval && (this.interval = M.getNiceExponent(Math.ceil(Math.log(g) / c) / (b - 1)), a = M.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (b - 1), !0))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 == e / d && (g = Math.pow(this.logarithmBase, void 0 === this._options.interval ? .4 : this._options.interval), e *= g, d /= g), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(d) || isFinite(e) ? 1 === d && 1 === e ? (e *= this.logarithmBase, d /= this.logarithmBase) : 1 == e / d ? (g = Math.pow(this.logarithmBase, this.interval), e *= g, d /= g) : d > e ? (g = Math.min(d / e * .01, 5), 1 <= e ? d = e / g : e = d * g) : (g = Math.min(e / d * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== e && (e *= g), 1 !== d && (d /= g)) : (e = void 0 === this._options.interval ? 0 : this._options.interval, d = 1), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < d && (d = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? d / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(d) / c / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? void 0 === this.sessionVariables.newViewportMinimum ? 1 / 0 : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / c / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? void 0 === this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this._options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this._options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase))), this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum), this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum), this.viewportMinimum > this.viewportMaximum && (!this._options.viewportMinimum && !this._options.minimum || this._options.viewportMaximum || this._options.maximum ? this._options.viewportMinimum || this._options.minimum || !this._options.viewportMaximum && !this._options.maximum || (this.viewportMinimum = this.minimum = (this._options.viewportMaximum || this._options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this._options.viewportMinimum || this._options.minimum), d = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (c * this.interval) + .2) * this.interval), this.range = this.viewportMaximum / this.viewportMinimum, this.noTicks = b, !this._options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > b ? 2 : 3)) { for (c = Math.floor(this.viewportMinimum / a + .5) * a; c < this.viewportMinimum;)c += a; this.equidistantInterval = !1, this.intervalStartPosition = c, this.interval = a } else this._options.interval || (a = Math.ceil(this.interval), this.range > this.interval && (this.interval = a, d = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (c * this.interval) + .2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = d; if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum) && (c = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2, !isNaN(c) && isFinite(c) || (c = 2), 2 < c)) for (a = 0; a < c - 2; a++)this.valueFormatString += "#" }, M.getNiceExponent = function (a, b) { var c = Math.floor(Math.log(a) / Math.LN10), d = a / Math.pow(10, c), d = 0 > c ? 1 >= d ? 1 : 5 >= d ? 5 : 10 : Math.max(Math.floor(d), 1); return Number((d * Math.pow(10, c)).toFixed(20)) }, M.getNiceNumber = function (a, b) { var c = Math.floor(Math.log(a) / Math.LN10), d = a / Math.pow(10, c); return Number(((b ? 1.5 > d ? 1 : 3 > d ? 2 : 7 > d ? 5 : 10 : 1 >= d ? 1 : 2 >= d ? 2 : 5 >= d ? 5 : 10) * Math.pow(10, c)).toFixed(20)) }, M.prototype.getLabelStartPoint = function () { var a = X[this.intervalType + "Duration"] * this.interval, a = new Date(Math.floor(this.viewportMinimum / a) * a); return "millisecond" !== this.intervalType && ("second" === this.intervalType ? 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0)) : "minute" === this.intervalType ? (0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0)) : "hour" === this.intervalType ? (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "day" === this.intervalType ? (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "week" === this.intervalType ? (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "month" === this.intervalType ? (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0))), a }, a(N, B), N.prototype.render = function () { this.ctx.save(); var a = this.parent.getPixelCoordinatesOnAxis(this.value), b = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness); if (0 < b) { var c = null === this.opacity ? 1 : this.opacity; this.ctx.strokeStyle = this.color, this.ctx.beginPath(); var d = this.ctx.globalAlpha; this.ctx.globalAlpha = c, m(this.id); var e, f, g, h; this.ctx.lineWidth = b, this.ctx.setLineDash && this.ctx.setLineDash(q(this.lineDashType, b)), "bottom" === this.parent._position || "top" === this.parent._position ? (e = f = 1 == this.ctx.lineWidth % 2 ? .5 + (a.x << 0) : a.x << 0, g = this.chart.plotArea.y1, h = this.chart.plotArea.y2) : "left" !== this.parent._position && "right" !== this.parent._position || (g = h = 1 == this.ctx.lineWidth % 2 ? .5 + (a.y << 0) : a.y << 0, e = this.chart.plotArea.x1, f = this.chart.plotArea.x2), this.ctx.moveTo(e, g), this.ctx.lineTo(f, h), this.ctx.stroke(), this.ctx.globalAlpha = d } this.ctx.restore() }, a(O, B), O.prototype._initialize = function () { if (this.enabled) { this.container = document.createElement("div"), this.container.setAttribute("class", "canvasjs-chart-tooltip"), this.container.style.position = "absolute", this.container.style.height = "auto", this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)", this.container.style.zIndex = "1000", this.container.style.display = "none"; var a; a = '<div style=" width: auto;height: auto;min-width: 50px;', a += "line-height: auto;", a += "margin: 0px 0px 0px 0px;", a += "padding: 5px;", a += "font-family: Calibri, Arial, Georgia, serif;", a += "font-weight: normal;", a += "font-style: " + (S ? "italic;" : "normal;"), a += "font-size: 14px;", a += "color: #000000;", a += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);", a += "text-align: left;", a += "border: 2px solid gray;", a += S ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);", a += "text-indent: 0px;", a += "white-space: nowrap;", a += "border-radius: 5px;", a += "-moz-user-select:none;", a += "-khtml-user-select: none;", a += "-webkit-user-select: none;", a += "-ms-user-select: none;", a += "user-select: none;", S || (a += "filter: alpha(opacity = 90);", a += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');"), a += '} "> Sample Tooltip</div>', this.container.innerHTML = a, this.contentDiv = this.container.firstChild, this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.chart._canvasJSContainer.appendChild(this.container) } }, O.prototype.mouseMoveHandler = function (a, b) { this._lastUpdated && 40 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this._updateToolTip(a, b)) }, O.prototype._updateToolTip = function (a, b) { if (!this.chart.disableToolTip) { if (void 0 === a || void 0 === b) { if (isNaN(this._prevX) || isNaN(this._prevY)) return; a = this._prevX, b = this._prevY } else this._prevX = a, this._prevY = b; var c = null, d = null, e = [], f = 0; if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) { for (f = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX.convertPixelToValue({ y: b }) : this.chart.axisX.convertPixelToValue({ x: a }), d = [], c = 0; c < this.chart.data.length; c++) { var g = this.chart.data[c].getDataPointAtX(f, !0); g && 0 <= g.index && (g.dataSeries = this.chart.data[c], null !== g.dataPoint.y && d.push(g)) } if (0 === d.length) return; for (d.sort(function (a, b) { return a.distance - b.distance }), f = d[0], c = 0; c < d.length; c++)d[c].dataPoint.x.valueOf() === f.dataPoint.x.valueOf() && e.push(d[c]); d = null } else { if (g = this.chart.getDataPointAtXY(a, b, !0)) this.currentDataPointIndex = g.dataPointIndex, this.currentSeriesIndex = g.dataSeries.index; else if (S) if (0 < (g = s(a, b, this.chart._eventManager.ghostCtx)) && void 0 !== this.chart._eventManager.objectMap[g]) { if (g = this.chart._eventManager.objectMap[g], "legendItem" === g.objectType) return; this.currentSeriesIndex = g.dataSeriesIndex, this.currentDataPointIndex = 0 <= g.dataPointIndex ? g.dataPointIndex : -1 } else this.currentDataPointIndex = -1; else this.currentDataPointIndex = -1; if (0 <= this.currentSeriesIndex) { if (d = this.chart.data[this.currentSeriesIndex], g = {}, 0 <= this.currentDataPointIndex) c = d.dataPoints[this.currentDataPointIndex], g.dataSeries = d, g.dataPoint = c, g.index = this.currentDataPointIndex, g.distance = Math.abs(c.x - f); else { if (!this.enabled || "line" !== d.type && "stepLine" !== d.type && "spline" !== d.type && "area" !== d.type && "stepArea" !== d.type && "splineArea" !== d.type && "stackedArea" !== d.type && "stackedArea100" !== d.type && "rangeArea" !== d.type && "rangeSplineArea" !== d.type && "candlestick" !== d.type && "ohlc" !== d.type) return; f = d.axisX.convertPixelToValue({ x: a }), g = d.getDataPointAtX(f, !0), g.dataSeries = d, this.currentDataPointIndex = g.index, c = g.dataPoint } if (!o(g.dataPoint.y)) if (g.dataSeries.axisY) if (0 < g.dataPoint.y.length) { for (c = f = 0; c < g.dataPoint.y.length; c++)g.dataPoint.y[c] < g.dataSeries.axisY.viewportMinimum ? f-- : g.dataPoint.y[c] > g.dataSeries.axisY.viewportMaximum && f++; f < g.dataPoint.y.length && f > -g.dataPoint.y.length && e.push(g) } else "column" === d.type || "bar" === d.type ? 0 > g.dataPoint.y ? 0 > g.dataSeries.axisY.viewportMinimum && g.dataSeries.axisY.viewportMaximum >= g.dataPoint.y && e.push(g) : g.dataSeries.axisY.viewportMinimum <= g.dataPoint.y && 0 <= g.dataSeries.axisY.viewportMaximum && e.push(g) : "bubble" === d.type ? (f = this.chart._eventManager.objectMap[d.dataPointIds[g.index]].size / 2, g.dataPoint.y >= g.dataSeries.axisY.viewportMinimum - f && g.dataPoint.y <= g.dataSeries.axisY.viewportMaximum + f && e.push(g)) : (0 <= g.dataSeries.type.indexOf("100") || "stackedColumn" === d.type || "stackedBar" === d.type || g.dataPoint.y >= g.dataSeries.axisY.viewportMinimum && g.dataPoint.y <= g.dataSeries.axisY.viewportMaximum) && e.push(g); else e.push(g) } } if (0 < e.length && (this.highlightObjects(e), this.enabled)) if (f = "", null !== (f = this.getToolTipInnerHTML({ entries: e }))) { this.contentDiv.innerHTML = f, this.contentDiv.innerHTML = f, f = !1, "none" === this.container.style.display && (f = !0, this.container.style.display = "block"); try { this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : S ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.borderColor ? this.borderColor : e[0].dataPoint.color ? e[0].dataPoint.color : e[0].dataSeries.color ? e[0].dataSeries.color : e[0].dataSeries._colorSet[e[0].index % e[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : S ? "italic" : "normal" } catch (a) { } "pie" === e[0].dataSeries.type || "doughnut" === e[0].dataSeries.type || "funnel" === e[0].dataSeries.type || "bar" === e[0].dataSeries.type || "rangeBar" === e[0].dataSeries.type || "stackedBar" === e[0].dataSeries.type || "stackedBar100" === e[0].dataSeries.type ? g = a - 10 - this.container.clientWidth : (g = e[0].dataSeries.axisX.convertValueToPixel(e[0].dataPoint.x) - this.container.clientWidth << 0, g -= 10), 0 > g && (g += this.container.clientWidth + 20), g + this.container.clientWidth > Math.max(this.chart._container.clientWidth, this.chart.width) && (g = Math.max(0, Math.max(this.chart._container.clientWidth, this.chart.width) - this.container.clientWidth)), g += "px", e = 1 !== e.length || this.shared || "line" !== e[0].dataSeries.type && "stepLine" !== e[0].dataSeries.type && "spline" !== e[0].dataSeries.type && "area" !== e[0].dataSeries.type && "stepArea" !== e[0].dataSeries.type && "splineArea" !== e[0].dataSeries.type ? "bar" === e[0].dataSeries.type || "rangeBar" === e[0].dataSeries.type || "stackedBar" === e[0].dataSeries.type || "stackedBar100" === e[0].dataSeries.type ? e[0].dataSeries.axisX.convertValueToPixel(e[0].dataPoint.x) : b : e[0].dataSeries.axisY.convertValueToPixel(e[0].dataPoint.y), e = 10 - e, 0 < e + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0), this.container.style.left = g, this.container.style.bottom = e + "px", !this.animationEnabled || f ? this.disableAnimation() : this.enableAnimation() } else this.hide(!1) } }, O.prototype.highlightObjects = function (a) { var b = this.chart.overlaidCanvasCtx; this.chart.resetOverlayedCanvas(), b.clearRect(0, 0, this.chart.width, this.chart.height), b.save(); var c = this.chart.plotArea, d = 0; for (b.beginPath(), b.rect(c.x1, c.y1, c.x2 - c.x1, c.y2 - c.y1), b.clip(), c = 0; c < a.length; c++) { var e = a[c]; if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) { var d = this.chart.data[e.dataSeriesIndex], f = d.dataPoints[e.dataPointIndex], g = e.dataPointIndex; !1 === f.highlightEnabled || !0 !== d.highlightEnabled && !0 !== f.highlightEnabled || ("line" === d.type || "stepLine" === d.type || "spline" === d.type || "scatter" === d.type || "area" === d.type || "stepArea" === d.type || "splineArea" === d.type || "stackedArea" === d.type || "stackedArea100" === d.type || "rangeArea" === d.type || "rangeSplineArea" === d.type ? (f = d.getMarkerProperties(g, e.x1, e.y1, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(.1 * f.size), ja.drawMarkers([f]), void 0 !== e.y2 && (f = d.getMarkerProperties(g, e.x1, e.y2, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(.1 * f.size), ja.drawMarkers([f]))) : "bubble" === d.type ? (f = d.getMarkerProperties(g, e.x1, e.y1, this.chart.overlaidCanvasCtx), f.size = e.size, f.color = "white", f.borderColor = "white", b.globalAlpha = .3, ja.drawMarkers([f]), b.globalAlpha = 1) : "column" === d.type || "stackedColumn" === d.type || "stackedColumn100" === d.type || "bar" === d.type || "rangeBar" === d.type || "stackedBar" === d.type || "stackedBar100" === d.type || "rangeColumn" === d.type ? ga(b, e.x1, e.y1, e.x2, e.y2, "white", 0, null, !1, !1, !1, !1, .3) : "pie" === d.type || "doughnut" === d.type ? ha(b, e.center, e.radius, "white", d.type, e.startAngle, e.endAngle, .3, e.percentInnerRadius) : "candlestick" === d.type ? (b.globalAlpha = 1, b.strokeStyle = e.color, b.lineWidth = 2 * e.borderThickness, d = 0 == b.lineWidth % 2 ? 0 : .5, b.beginPath(), b.moveTo(e.x3 - d, Math.min(e.y2, e.y3)), b.lineTo(e.x3 - d, Math.min(e.y1, e.y4)), b.stroke(), b.beginPath(), b.moveTo(e.x3 - d, Math.max(e.y1, e.y4)), b.lineTo(e.x3 - d, Math.max(e.y2, e.y3)), b.stroke(), ga(b, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, !1, !1, !1, !1), b.globalAlpha = 1) : "ohlc" === d.type && (b.globalAlpha = 1, b.strokeStyle = e.color, b.lineWidth = 2 * e.borderThickness, d = 0 == b.lineWidth % 2 ? 0 : .5, b.beginPath(), b.moveTo(e.x3 - d, e.y2), b.lineTo(e.x3 - d, e.y3), b.stroke(), b.beginPath(), b.moveTo(e.x3, e.y1), b.lineTo(e.x1, e.y1), b.stroke(), b.beginPath(), b.moveTo(e.x3, e.y4), b.lineTo(e.x2, e.y4), b.stroke(), b.globalAlpha = 1)) } } b.restore(), b.globalAlpha = 1, b.beginPath() }, O.prototype.getToolTipInnerHTML = function (a) { a = a.entries; for (var b = null, c = null, d = null, e = 0, f = "", g = !0, h = 0; h < a.length; h++)if (a[h].dataSeries.toolTipContent || a[h].dataPoint.toolTipContent) { g = !1; break } if (g && (this.content && "function" == typeof this.content || this.contentFormatter)) a = { chart: this.chart._publicChartReference, toolTip: this._options, entries: a }, b = this.contentFormatter ? this.contentFormatter(a) : this.content(a); else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) { for (var i = "", h = 0; h < a.length; h++)c = a[h].dataSeries, d = a[h].dataPoint, e = a[h].index, f = "", 0 === h && g && !this.content && (i += void 0 !== this.chart.axisX.labels[d.x] ? this.chart.axisX.labels[d.x] : "{x}", i += "</br>", i = this.chart.replaceKeywordsWithValue(i, d, c, e)), null === d.toolTipContent || void 0 === d.toolTipContent && null === c._options.toolTipContent || ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type ? f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}" : "bubble" === c.type ? f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}" : "candlestick" !== c.type && "ohlc" !== c.type || (f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}"), null === b && (b = ""), !0 === this.reversed ? (b = this.chart.replaceKeywordsWithValue(f, d, c, e) + b, h < a.length - 1 && (b = "</br>" + b)) : (b += this.chart.replaceKeywordsWithValue(f, d, c, e), h < a.length - 1 && (b += "</br>"))); null !== b && (b = i + b) } else { if (c = a[0].dataSeries, d = a[0].dataPoint, e = a[0].index, null === d.toolTipContent || void 0 === d.toolTipContent && null === c._options.toolTipContent) return null; "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === c.type || "doughnut" === c.type || "funnel" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.name ? "{name}:</span>&nbsp;&nbsp;" : d.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" !== c.type && "ohlc" !== c.type || (f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}"), null === b && (b = ""), b += this.chart.replaceKeywordsWithValue(f, d, c, e) } return b }, O.prototype.enableAnimation = function () { this.container.style.WebkitTransition || (this.container.style.WebkitTransition = "left .2s ease-out, bottom .2s ease-out", this.container.style.MozTransition = "left .2s ease-out, bottom .2s ease-out", this.container.style.MsTransition = "left .2s ease-out, bottom .2s ease-out", this.container.style.transition = "left .2s ease-out, bottom .2s ease-out") }, O.prototype.disableAnimation = function () { this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "") }, O.prototype.hide = function (a) { this.enabled && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, (void 0 === a || a) && this.chart.resetOverlayedCanvas()) }, C.prototype.getPercentAndTotal = function (a, b) { var c = null, d = null, e = null; if (0 <= a.type.indexOf("stacked")) d = 0, (c = b.x.getTime ? b.x.getTime() : b.x) in a.plotUnit.yTotals && (d = a.plotUnit.yTotals[c], e = isNaN(b.y) ? 0 : 0 === d ? 0 : b.y / d * 100); else if ("pie" === a.type || "doughnut" === a.type) { for (i = d = 0; i < a.dataPoints.length; i++)isNaN(a.dataPoints[i].y) || (d += a.dataPoints[i].y); e = isNaN(b.y) ? 0 : b.y / d * 100 } return { percent: e, total: d } }, C.prototype.replaceKeywordsWithValue = function (a, b, c, d, e) { var f = this; if (e = void 0 === e ? 0 : e, (0 <= c.type.indexOf("stacked") || "pie" === c.type || "doughnut" === c.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) { var h = "#percent", i = "#total", j = this.getPercentAndTotal(c, b), i = isNaN(j.total) ? i : j.total, h = isNaN(j.percent) ? h : j.percent; do { if (j = "", c.percentFormatString) j = c.percentFormatString; else { var j = "#,##0.", k = Math.max(Math.ceil(Math.log(1 / Math.abs(h)) / Math.LN10), 2); !isNaN(k) && isFinite(k) || (k = 2); for (var l = 0; l < k; l++)j += "#" } a = a.replace("#percent", _(h, j, f._cultureInfo)), a = a.replace("#total", _(i, c.yValueFormatString ? c.yValueFormatString : "#,##0.########")) } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total")) } return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function (a) { if ('"' === a[0] && '"' === a[a.length - 1] || "'" === a[0] && "'" === a[a.length - 1]) return a.slice(1, a.length - 1); a = g(a.slice(1, a.length - 1)), a = a.replace("#index", e); var h = null; try { var i = a.match(/(.*?)\s*\[\s*(.*?)\s*\]/); i && 0 < i.length && (h = g(i[2]), a = g(i[1])) } catch (a) { } if (i = null, "color" === a) return b.color ? b.color : c.color ? c.color : c._colorSet[d % c._colorSet.length]; if (b.hasOwnProperty(a)) i = b; else { if (!c.hasOwnProperty(a)) return ""; i = c } return i = i[a], null !== h && (i = i[h]), "x" === a ? !f.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic && ("dateTime" === f.plotInfo.axisXValueType || "dateTime" === c.xValueType || b.x && b.x.getTime) ? $(i, b.xValueFormatString ? b.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : f.axisX && f.axisX.autoValueFormatString ? f.axisX.autoValueFormatString : "DD MMM YY", f._cultureInfo) : _(i, b.xValueFormatString ? b.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : "#,##0.########", f._cultureInfo) : "y" === a ? _(i, b.yValueFormatString ? b.yValueFormatString : c.yValueFormatString ? c.yValueFormatString : "#,##0.########", f._cultureInfo) : "z" === a ? _(i, b.zValueFormatString ? b.zValueFormatString : c.zValueFormatString ? c.zValueFormatString : "#,##0.########", f._cultureInfo) : i }) }, P.prototype.reset = function () { this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.eventObjects = [], S && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath()) }, P.prototype.getNewObjectTrackingId = function () { return ++this.lastObjectId }, P.prototype.mouseEventHandler = function (a) { if ("mousemove" === a.type || "click" === a.type) { var b = [], c = aa(a), d = null; if ((d = this.chart.getObjectAtXY(c.x, c.y, !1)) && void 0 !== this.objectMap[d]) if (d = this.objectMap[d], "dataPoint" === d.objectType) { var e = this.chart.data[d.dataSeriesIndex], f = e.dataPoints[d.dataPointIndex], g = d.dataPointIndex; d.eventParameter = { x: c.x, y: c.y, dataPoint: f, dataSeries: e._options, dataPointIndex: g, dataSeriesIndex: e.index, chart: this.chart._publicChartReference }, d.eventContext = { context: f, userContext: f, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }, b.push(d), d = this.objectMap[e.id], d.eventParameter = { x: c.x, y: c.y, dataPoint: f, dataSeries: e._options, dataPointIndex: g, dataSeriesIndex: e.index, chart: this.chart._publicChartReference }, d.eventContext = { context: e, userContext: e._options, mouseover: "mouseover", mousemove: "mousemove", mouseout: "mouseout", click: "click" }, b.push(this.objectMap[e.id]) } else "legendItem" === d.objectType && (e = this.chart.data[d.dataSeriesIndex], f = null !== d.dataPointIndex ? e.dataPoints[d.dataPointIndex] : null, d.eventParameter = { x: c.x, y: c.y, dataSeries: e._options, dataPoint: f, dataPointIndex: d.dataPointIndex, dataSeriesIndex: d.dataSeriesIndex, chart: this.chart._publicChartReference }, d.eventContext = { context: this.chart.legend, userContext: this.chart.legend._options, mouseover: "itemmouseover", mousemove: "itemmousemove", mouseout: "itemmouseout", click: "itemclick" }, b.push(d)); for (e = [], c = 0; c < this.mouseoveredObjectMaps.length; c++) { for (f = !0, d = 0; d < b.length; d++)if (b[d].id === this.mouseoveredObjectMaps[c].id) { f = !1; break } f ? this.fireEvent(this.mouseoveredObjectMaps[c], "mouseout", a) : e.push(this.mouseoveredObjectMaps[c]) } for (this.mouseoveredObjectMaps = e, c = 0; c < b.length; c++) { for (e = !1, d = 0; d < this.mouseoveredObjectMaps.length; d++)if (b[c].id === this.mouseoveredObjectMaps[d].id) { e = !0; break } e || (this.fireEvent(b[c], "mouseover", a), this.mouseoveredObjectMaps.push(b[c])), "click" === a.type ? this.fireEvent(b[c], "click", a) : "mousemove" === a.type && this.fireEvent(b[c], "mousemove", a) } } }, P.prototype.fireEvent = function (a, b, c) { if (a && b) { var d = a.eventParameter, e = a.eventContext, f = a.eventContext.userContext; f && e && f[e[b]] && f[e[b]].call(f, d), "mouseout" !== b ? f.cursor && f.cursor !== c.target.style.cursor && (c.target.style.cursor = f.cursor) : (c.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext), "click" === b && "dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], d) } }, a(Q, B), R.prototype.animate = function (a, b, c, d, e) { var f = this; for (this.chart.isAnimating = !0, e = e || ia.easing.linear, c && this.animations.push({ startTime: (new Date).getTime() + (a || 0), duration: b, animationCallback: c, onComplete: d }), a = []; 0 < this.animations.length;)b = this.animations.shift(), c = (new Date).getTime(), d = 0, b.startTime <= c && (d = e(Math.min(c - b.startTime, b.duration), 0, 1, b.duration), d = Math.min(d, 1), isNaN(d) || !isFinite(d)) && (d = 1), 1 > d && a.push(b), b.animationCallback(d), 1 <= d && b.onComplete && b.onComplete(); this.animations = a, 0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () { f.animate.call(f) }) : this.chart.isAnimating = !1 }, R.prototype.cancelAllAnimations = function () { this.animations = [], this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId), this.animationRequestId = null, this.chart.isAnimating = !1 }; var ia = { yScaleAnimation: function (a, b) { if (0 !== a) { var c = b.dest, d = b.source.canvas, e = b.animationBase; c.drawImage(d, 0, 0, d.width, d.height, 0, e - e * a, c.canvas.width / ea, a * c.canvas.height / ea) } }, xScaleAnimation: function (a, b) { if (0 !== a) { var c = b.dest, d = b.source.canvas, e = b.animationBase; c.drawImage(d, 0, 0, d.width, d.height, e - e * a, 0, a * c.canvas.width / ea, c.canvas.height / ea) } }, xClipAnimation: function (a, b) { if (0 !== a) { var c = b.dest, d = b.source.canvas; c.save(), 0 < a && c.drawImage(d, 0, 0, d.width * a, d.height, 0, 0, d.width * a / ea, d.height / ea), c.restore() } }, fadeInAnimation: function (a, b) { if (0 !== a) { var c = b.dest, d = b.source.canvas; c.save(), c.globalAlpha = a, c.drawImage(d, 0, 0, d.width, d.height, 0, 0, c.canvas.width / ea, c.canvas.height / ea), c.restore() } }, easing: { linear: function (a, b, c, d) { return c * a / d + b }, easeOutQuad: function (a, b, c, d) { return -c * (a /= d) * (a - 2) + b }, easeOutQuart: function (a, b, c, d) { return -c * ((a = a / d - 1) * a * a * a - 1) + b }, easeInQuad: function (a, b, c, d) { return c * (a /= d) * a + b }, easeInQuart: function (a, b, c, d) { return c * (a /= d) * a * a * a + b } } }, ja = { drawMarker: function (a, b, c, d, e, f, g, h) { if (c) { var i = 1; c.fillStyle = f || "#000000", c.strokeStyle = g || "#000000", c.lineWidth = h || 0, "circle" === d ? (c.moveTo(a, b), c.beginPath(), c.arc(a, b, e / 2, 0, 2 * Math.PI, !1), f && c.fill(), h && (g ? c.stroke() : (i = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = i))) : "square" === d ? (c.beginPath(), c.rect(a - e / 2, b - e / 2, e, e), f && c.fill(), h && (g ? c.stroke() : (i = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = i))) : "triangle" === d ? (c.beginPath(), c.moveTo(a - e / 2, b + e / 2), c.lineTo(a + e / 2, b + e / 2), c.lineTo(a, b - e / 2), c.closePath(), f && c.fill(), h && (g ? c.stroke() : (i = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = i)), c.beginPath()) : "cross" === d && (c.strokeStyle = f, c.lineWidth = e / 4, c.beginPath(), c.moveTo(a - e / 2, b - e / 2), c.lineTo(a + e / 2, b + e / 2), c.stroke(), c.moveTo(a + e / 2, b - e / 2), c.lineTo(a - e / 2, b + e / 2), c.stroke()) } }, drawMarkers: function (a) { for (var b = 0; b < a.length; b++) { var c = a[b]; ja.drawMarker(c.x, c.y, c.ctx, c.type, c.size, c.color, c.borderColor, c.borderThickness) } } }, ka = { Chart: function (a, b) { var c = new C(a, b, this); this.render = function () { c.render(this.options) }, this.options = c._options }, addColorSet: function (a, b) { V[a] = b }, addCultureInfo: function (a, b) { U[a] = b }, formatNumber: function (a, b, c) { if (c = c || "en", U[c]) return _(a, b || "#,##0.##", new Q(c)); throw "Unknown Culture Name" }, formatDate: function (a, b, c) { if (c = c || "en", U[c]) return $(a, b || "DD MMM YYYY", new Q(c)); throw "Unknown Culture Name" } }; ka.Chart.version = "v1.9.0 GA", window.CanvasJS = ka }(), document.createElement("canvas").getContext || function () { function a() { return this.context_ || (this.context_ = new n(this)) } function b(a, b, c) { var d = E.call(arguments, 2); return function () { return a.apply(b, d.concat(E.call(arguments))) } } function c(a) { return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;") } function d(a) { a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML"), a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}") } function e(a) { var b = a.srcElement; switch (a.propertyName) { case "width": b.getContext().clearRect(), b.style.width = b.attributes.width.nodeValue + "px", b.firstChild.style.width = b.clientWidth + "px"; break; case "height": b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight + "px" } } function f(a) { a = a.srcElement, a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px") } function g() { return [[1, 0, 0], [0, 1, 0], [0, 0, 1]] } function h(a, b) { for (var c = g(), d = 0; 3 > d; d++)for (var e = 0; 3 > e; e++) { for (var f = 0, h = 0; 3 > h; h++)f += a[d][h] * b[h][e]; c[d][e] = f } return c } function i(a, b) { b.fillStyle = a.fillStyle, b.lineCap = a.lineCap, b.lineJoin = a.lineJoin, b.lineWidth = a.lineWidth, b.miterLimit = a.miterLimit, b.shadowBlur = a.shadowBlur, b.shadowColor = a.shadowColor, b.shadowOffsetX = a.shadowOffsetX, b.shadowOffsetY = a.shadowOffsetY, b.strokeStyle = a.strokeStyle, b.globalAlpha = a.globalAlpha, b.font = a.font, b.textAlign = a.textAlign, b.textBaseline = a.textBaseline, b.arcScaleX_ = a.arcScaleX_, b.arcScaleY_ = a.arcScaleY_, b.lineScale_ = a.lineScale_ } function j(a) { var b = a.indexOf("(", 3), c = a.indexOf(")", b + 1), b = a.substring(b + 1, c).split(","); return 4 == b.length && "a" == a.charAt(3) || (b[3] = 1), b } function k(a, b, c) { return Math.min(c, Math.max(b, a)) } function l(a, b, c) { return 0 > c && c++ , 1 < c && c-- , 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a } function m(a) { if (a in K) return K[a]; var b, c = 1; if (a = String(a), "#" == a.charAt(0)) b = a; else if (/^rgb/.test(a)) { c = j(a), b = "#"; for (var d, e = 0; 3 > e; e++)d = -1 != c[e].indexOf("%") ? Math.floor(parseFloat(c[e]) / 100 * 255) : +c[e], b += G[k(d, 0, 255)]; c = +c[3] } else if (/^hsl/.test(a)) { if (e = c = j(a), b = parseFloat(e[0]) / 360 % 360, 0 > b && b++ , d = k(parseFloat(e[1]) / 100, 0, 1), e = k(parseFloat(e[2]) / 100, 0, 1), 0 == d) d = e = b = e; else { var f = .5 > e ? e * (1 + d) : e + d - e * d, g = 2 * e - f; d = l(g, f, b + 1 / 3), e = l(g, f, b), b = l(g, f, b - 1 / 3) } b = "#" + G[Math.floor(255 * d)] + G[Math.floor(255 * e)] + G[Math.floor(255 * b)], c = c[3] } else b = J[a] || a; return K[a] = { color: b, alpha: c } } function n(a) { this.m_ = g(), this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.fillStyle = this.strokeStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", this.miterLimit = 1 * C, this.globalAlpha = 1, this.font = "10px sans-serif", this.textAlign = "left", this.textBaseline = "alphabetic", this.canvas = a; var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute", c = a.ownerDocument.createElement("div"); c.style.cssText = b, a.appendChild(c), b = c.cloneNode(!1), b.style.backgroundColor = "red", b.style.filter = "alpha(opacity=0)", a.appendChild(b), this.element_ = c, this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1 } function o(a, b, c, d) { a.currentPath_.push({ type: "bezierCurveTo", cp1x: b.x, cp1y: b.y, cp2x: c.x, cp2y: c.y, x: d.x, y: d.y }), a.currentX_ = d.x, a.currentY_ = d.y } function p(a, b) { var c = m(a.strokeStyle), d = c.color, c = c.alpha * a.globalAlpha, e = a.lineScale_ * a.lineWidth; 1 > e && (c *= e), b.push("<g_vml_:stroke", ' opacity="', c, '"', ' joinstyle="', a.lineJoin, '"', ' miterlimit="', a.miterLimit, '"', ' endcap="', M[a.lineCap] || "square", '"', ' weight="', e, 'px"', ' color="', d, '" />') } function q(a, b, c, d) { var e = a.fillStyle, f = a.arcScaleX_, g = a.arcScaleY_, h = d.x - c.x, i = d.y - c.y; if (e instanceof t) { var j = 0, k = d = 0, l = 0, n = 1; if ("gradient" == e.type_) { j = e.x1_ / f, c = e.y1_ / g; var o = r(a, e.x0_ / f, e.y0_ / g), j = r(a, j, c), j = 180 * Math.atan2(j.x - o.x, j.y - o.y) / Math.PI; 0 > j && (j += 360), 1e-6 > j && (j = 0) } else o = r(a, e.x0_, e.y0_), d = (o.x - c.x) / h, k = (o.y - c.y) / i, h /= f * C, i /= g * C, n = w.max(h, i), l = 2 * e.r0_ / n, n = 2 * e.r1_ / n - l; f = e.colors_, f.sort(function (a, b) { return a.offset - b.offset }), g = f.length, o = f[0].color, c = f[g - 1].color, h = f[0].alpha * a.globalAlpha, a = f[g - 1].alpha * a.globalAlpha; for (var i = [], p = 0; p < g; p++) { var q = f[p]; i.push(q.offset * n + l + " " + q.color) } b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', o, '"', ' color2="', c, '"', ' colors="', i.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', h, '"', ' angle="', j, '"', ' focusposition="', d, ",", k, '" />') } else e instanceof u ? h && i && b.push("<g_vml_:fill", ' position="', -c.x / h * f * f, ",", -c.y / i * g * g, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = m(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />')) } function r(a, b, c) { return a = a.m_, { x: C * (b * a[0][0] + c * a[1][0] + a[2][0]) - D, y: C * (b * a[0][1] + c * a[1][1] + a[2][1]) - D } } function s(a, b, c) { isFinite(b[0][0]) && isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1]) && (a.m_ = b, c && (a.lineScale_ = B(A(b[0][0] * b[1][1] - b[0][1] * b[1][0])))) } function t(a) { this.type_ = a, this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0, this.colors_ = [] } function u(a, b) { if (!a || 1 != a.nodeType || "IMG" != a.tagName) throw new v("TYPE_MISMATCH_ERR"); if ("complete" != a.readyState) throw new v("INVALID_STATE_ERR"); switch (b) { case "repeat": case null: case "": this.repetition_ = "repeat"; break; case "repeat-x": case "repeat-y": case "no-repeat": this.repetition_ = b; break; default: throw new v("SYNTAX_ERR") }this.src_ = a.src, this.width_ = a.width, this.height_ = a.height } function v(a) { this.code = this[a], this.message = a + ": DOM Exception " + this.code } var w = Math, x = w.round, y = w.sin, z = w.cos, A = w.abs, B = w.sqrt, C = 10, D = C / 2; navigator.userAgent.match(/MSIE ([\d.]+)?/); var E = Array.prototype.slice; d(document); var F = { init: function (a) { a = a || document, a.createElement("canvas"), a.attachEvent("onreadystatechange", b(this.init_, this, a)) }, init_: function (a) { a = a.getElementsByTagName("canvas"); for (var b = 0; b < a.length; b++)this.initElement(a[b]) }, initElement: function (b) { if (!b.getContext) { b.getContext = a, d(b.ownerDocument), b.innerHTML = "", b.attachEvent("onpropertychange", e), b.attachEvent("onresize", f); var c = b.attributes; c.width && c.width.specified ? b.style.width = c.width.nodeValue + "px" : b.width = b.clientWidth, c.height && c.height.specified ? b.style.height = c.height.nodeValue + "px" : b.height = b.clientHeight } return b } }; F.init(); for (var G = [], H = 0; 16 > H; H++)for (var I = 0; 16 > I; I++)G[16 * H + I] = H.toString(16) + I.toString(16); var J = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgreen: "#006400", darkgrey: "#A9A9A9", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", grey: "#808080", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgreen: "#90EE90", lightgrey: "#D3D3D3", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", oldlace: "#FDF5E6", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", whitesmoke: "#F5F5F5", yellowgreen: "#9ACD32" }, K = {}, L = {}, M = { butt: "flat", round: "round" }, H = n.prototype; H.clearRect = function () { this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null), this.element_.innerHTML = "" }, H.beginPath = function () { this.currentPath_ = [] }, H.moveTo = function (a, b) { var c = r(this, a, b); this.currentPath_.push({ type: "moveTo", x: c.x, y: c.y }), this.currentX_ = c.x, this.currentY_ = c.y }, H.lineTo = function (a, b) { var c = r(this, a, b); this.currentPath_.push({ type: "lineTo", x: c.x, y: c.y }), this.currentX_ = c.x, this.currentY_ = c.y }, H.bezierCurveTo = function (a, b, c, d, e, f) { e = r(this, e, f), a = r(this, a, b), c = r(this, c, d), o(this, a, c, e) }, H.quadraticCurveTo = function (a, b, c, d) { a = r(this, a, b), c = r(this, c, d), d = { x: this.currentX_ + 2 / 3 * (a.x - this.currentX_), y: this.currentY_ + 2 / 3 * (a.y - this.currentY_) }, o(this, d, { x: d.x + (c.x - this.currentX_) / 3, y: d.y + (c.y - this.currentY_) / 3 }, c) }, H.arc = function (a, b, c, d, e, f) { c *= C; var g = f ? "at" : "wa", h = a + z(d) * c - D, i = b + y(d) * c - D; d = a + z(e) * c - D, e = b + y(e) * c - D, h != d || f || (h += .125), a = r(this, a, b), h = r(this, h, i), d = r(this, d, e), this.currentPath_.push({ type: g, x: a.x, y: a.y, radius: c, xStart: h.x, yStart: h.y, xEnd: d.x, yEnd: d.y }) }, H.rect = function (a, b, c, d) { this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath() }, H.strokeRect = function (a, b, c, d) { var e = this.currentPath_; this.beginPath(), this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath(), this.stroke(), this.currentPath_ = e }, H.fillRect = function (a, b, c, d) { var e = this.currentPath_; this.beginPath(), this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath(), this.fill(), this.currentPath_ = e }, H.createLinearGradient = function (a, b, c, d) { var e = new t("gradient"); return e.x0_ = a, e.y0_ = b, e.x1_ = c, e.y1_ = d, e }, H.createRadialGradient = function (a, b, c, d, e, f) { var g = new t("gradientradial"); return g.x0_ = a, g.y0_ = b, g.r0_ = c, g.x1_ = d, g.y1_ = e, g.r1_ = f, g }, H.drawImage = function (a, b) { var c, d, e, f, g, h, i, j; e = a.runtimeStyle.width, f = a.runtimeStyle.height, a.runtimeStyle.width = "auto", a.runtimeStyle.height = "auto"; var k = a.width, l = a.height; if (a.runtimeStyle.width = e, a.runtimeStyle.height = f, 3 == arguments.length) c = arguments[1], d = arguments[2], g = h = 0, i = e = k, j = f = l; else if (5 == arguments.length) c = arguments[1], d = arguments[2], e = arguments[3], f = arguments[4], g = h = 0, i = k, j = l; else { if (9 != arguments.length) throw Error("Invalid number of arguments"); g = arguments[1], h = arguments[2], i = arguments[3], j = arguments[4], c = arguments[5], d = arguments[6], e = arguments[7], f = arguments[8] } var m = r(this, c, d), n = []; if (n.push(" <g_vml_:group", ' coordsize="', 10 * C, ",", 10 * C, '"', ' coordorigin="0,0"', ' style="width:', 10, "px;height:", 10, "px;position:absolute;"), 1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) { var o = []; o.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", x(m.x / C), ",", "Dy=", x(m.y / C), ""); var p = r(this, c + e, d), q = r(this, c, d + f); c = r(this, c + e, d + f), m.x = w.max(m.x, p.x, q.x, c.x), m.y = w.max(m.y, p.y, q.y, c.y), n.push("padding:0 ", x(m.x / C), "px ", x(m.y / C), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", o.join(""), ", sizingmethod='clip');") } else n.push("top:", x(m.y / C), "px;left:", x(m.x / C), "px;"); n.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', C * e, "px;", " height:", C * f, 'px"', ' cropleft="', g / k, '"', ' croptop="', h / l, '"', ' cropright="', (k - g - i) / k, '"', ' cropbottom="', (l - h - j) / l, '"', " />", "</g_vml_:group>"), this.element_.insertAdjacentHTML("BeforeEnd", n.join("")) }, H.stroke = function (a) { var b = []; b.push("<g_vml_:shape", ' filled="', !!a, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * C, ",", 10 * C, '"', ' stroked="', !a, '"', ' path="'); for (var c = { x: null, y: null }, d = { x: null, y: null }, e = 0; e < this.currentPath_.length; e++) { var f = this.currentPath_[e]; switch (f.type) { case "moveTo": b.push(" m ", x(f.x), ",", x(f.y)); break; case "lineTo": b.push(" l ", x(f.x), ",", x(f.y)); break; case "close": b.push(" x "), f = null; break; case "bezierCurveTo": b.push(" c ", x(f.cp1x), ",", x(f.cp1y), ",", x(f.cp2x), ",", x(f.cp2y), ",", x(f.x), ",", x(f.y)); break; case "at": case "wa": b.push(" ", f.type, " ", x(f.x - this.arcScaleX_ * f.radius), ",", x(f.y - this.arcScaleY_ * f.radius), " ", x(f.x + this.arcScaleX_ * f.radius), ",", x(f.y + this.arcScaleY_ * f.radius), " ", x(f.xStart), ",", x(f.yStart), " ", x(f.xEnd), ",", x(f.yEnd)) }f && ((null == c.x || f.x < c.x) && (c.x = f.x), (null == d.x || f.x > d.x) && (d.x = f.x), (null == c.y || f.y < c.y) && (c.y = f.y), (null == d.y || f.y > d.y) && (d.y = f.y)) } b.push(' ">'), a ? q(this, b, c, d) : p(this, b), b.push("</g_vml_:shape>"), this.element_.insertAdjacentHTML("beforeEnd", b.join("")) }, H.fill = function () { this.stroke(!0) }, H.closePath = function () { this.currentPath_.push({ type: "close" }) }, H.save = function () { var a = {}; i(this, a), this.aStack_.push(a), this.mStack_.push(this.m_), this.m_ = h(g(), this.m_) }, H.restore = function () { this.aStack_.length && (i(this.aStack_.pop(), this), this.m_ = this.mStack_.pop()) }, H.translate = function (a, b) { s(this, h([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1) }, H.rotate = function (a) { var b = z(a); a = y(a), s(this, h([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1) }, H.scale = function (a, b) { this.arcScaleX_ *= a, this.arcScaleY_ *= b, s(this, h([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0) }, H.transform = function (a, b, c, d, e, f) { s(this, h([[a, b, 0], [c, d, 0], [e, f, 1]], this.m_), !0) }, H.setTransform = function (a, b, c, d, e, f) { s(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0) }, H.drawText_ = function (a, b, d, e, f) { var g = this.m_; e = 0; var h, i = 1e3, j = 0, k = []; if (h = this.font, L[h]) h = L[h]; else { var l = document.createElement("div").style; try { l.font = h } catch (a) { } h = L[h] = { style: l.fontStyle || "normal", variant: l.fontVariant || "normal", weight: l.fontWeight || "normal", size: l.fontSize || 10, family: l.fontFamily || "sans-serif" } } var l = h, m = this.element_; h = {}; for (var n in l) h[n] = l[n]; switch (n = parseFloat(m.currentStyle.fontSize), m = parseFloat(l.size), "number" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf("px") ? h.size = m : -1 != l.size.indexOf("em") ? h.size = n * m : -1 != l.size.indexOf("%") ? h.size = n / 100 * m : -1 != l.size.indexOf("pt") ? h.size = m / .75 : h.size = n, h.size *= .981, n = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family, m = this.element_.currentStyle, l = this.textAlign.toLowerCase()) { case "left": case "center": case "right": break; case "end": l = "ltr" == m.direction ? "right" : "left"; break; case "start": l = "rtl" == m.direction ? "right" : "left"; break; default: l = "left" }switch (this.textBaseline) { case "hanging": case "top": j = h.size / 1.75; break; case "middle": break; default: case null: case "alphabetic": case "ideographic": case "bottom": j = -h.size / 2.25 }switch (l) { case "right": e = 1e3, i = .05; break; case "center": e = i = 500 }b = r(this, b + 0, d + j), k.push('<g_vml_:line from="', -e, ' 0" to="', i, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !f, '" stroked="', !!f, '" style="position:absolute;width:1px;height:1px;">'), f ? p(this, k) : q(this, k, { x: -e, y: 0 }, { x: i, y: h.size }), f = g[0][0].toFixed(3) + "," + g[1][0].toFixed(3) + "," + g[0][1].toFixed(3) + "," + g[1][1].toFixed(3) + ",0,0", b = x(b.x / C) + "," + x(b.y / C), k.push('<g_vml_:skew on="t" matrix="', f, '" ', ' offset="', b, '" origin="', e, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', c(a), '" style="v-text-align:', l, ";font:", c(n), '" /></g_vml_:line>'), this.element_.insertAdjacentHTML("beforeEnd", k.join("")) }, H.fillText = function (a, b, c, d) { this.drawText_(a, b, c, d, !1) }, H.strokeText = function (a, b, c, d) { this.drawText_(a, b, c, d, !0) }, H.measureText = function (a) { this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild); var b = this.element_.ownerDocument; return this.textMeasureEl_.innerHTML = "", this.textMeasureEl_.style.font = this.font, this.textMeasureEl_.appendChild(b.createTextNode(a)), { width: this.textMeasureEl_.offsetWidth } }, H.clip = function () { }, H.arcTo = function () { }, H.createPattern = function (a, b) { return new u(a, b) }, t.prototype.addColorStop = function (a, b) { b = m(b), this.colors_.push({ offset: a, color: b.color, alpha: b.alpha }) }, H = v.prototype = Error(), H.INDEX_SIZE_ERR = 1, H.DOMSTRING_SIZE_ERR = 2, H.HIERARCHY_REQUEST_ERR = 3, H.WRONG_DOCUMENT_ERR = 4, H.INVALID_CHARACTER_ERR = 5, H.NO_DATA_ALLOWED_ERR = 6, H.NO_MODIFICATION_ALLOWED_ERR = 7, H.NOT_FOUND_ERR = 8, H.NOT_SUPPORTED_ERR = 9, H.INUSE_ATTRIBUTE_ERR = 10, H.INVALID_STATE_ERR = 11, H.SYNTAX_ERR = 12, H.INVALID_MODIFICATION_ERR = 13, H.NAMESPACE_ERR = 14, H.INVALID_ACCESS_ERR = 15, H.VALIDATION_ERR = 16, H.TYPE_MISMATCH_ERR = 17, G_vmlCanvasManager = F, CanvasRenderingContext2D = n, CanvasGradient = t, CanvasPattern = u, DOMException = v }(); function CreateChart(a, b, c, d, e, f) { return chartx = new CanvasJS.Chart(a, { theme: "theme2", legend: { fontSize: 12, fontFamily: "Source Sans Pro" }, interactivityEnabled: !1, backgroundColor: "#fff", animationEnabled: !0, width: 305, height: 200, title: { text: f, fontFamily: "Source Sans Pro", fontStyle: "Bold" }, total_Count: b + c + d + e, data: [{ explodeOnClick: !1, type: "doughnut", indexLabelFormatter: function (a) { return 0 === a.dataPoint.y ? "" : a.dataPoint.y }, indexLabelPlacement: "outside", indexLabelFontColor: "black", indexLabelFontSize: 11, indexLabelFontFamily: "Source Sans Pro", showInLegend: !1, radius: "85%", innerRadius: "80%", dataPoints: [{ y: b, legendText: "Passed", color: "#008000", indexLabel: "Passed (" + b + ")", indexLabelFontColor: "#008000" }, { y: c, legendText: "Failed", color: "#FF0000", indexLabel: "Failed (" + c + ")", indexLabelFontColor: "#FF0000" }, { y: d, legendText: "Stopped", color: "#ff57ab", indexLabel: "Stopped (" + d + ")", indexLabelFontColor: "#ff57ab" }, { y: e, legendText: "Other", color: "#1B3651", indexLabel: "Other (" + e + ")", indexLabelFontColor: "#1B3651" }] }] }) } function hideIndexLabel(a) { var b = a.options.data[0].dataPoints.length; for (i = 0; i < b; i++)0 === a.options.data[0].dataPoints[i].y || null === a.options.data[0].dataPoints[i].y ? a.options.data[0].dataPoints[i].indexLabel = "" : a.options.data[0].dataPoints[i].indexLabel = a.options.data[0].dataPoints[i].indexLabel }